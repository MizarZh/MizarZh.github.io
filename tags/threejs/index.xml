<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>threejs on MizarZ&#39;s Blog</title>
        <link>https://mizarzh.github.io/tags/threejs/</link>
        <description>Recent content in threejs on MizarZ&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 08 Sep 2021 23:05:27 +0800</lastBuildDate><atom:link href="https://mizarzh.github.io/tags/threejs/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>最近进展2021-9-4 moon3d</title>
        <link>https://mizarzh.github.io/p/2021/09/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952021-9-4-moon3d/</link>
        <pubDate>Wed, 08 Sep 2021 23:05:27 +0800</pubDate>
        
        <guid>https://mizarzh.github.io/p/2021/09/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952021-9-4-moon3d/</guid>
        <description>&lt;h1 id=&#34;最近工作moon-3d2021-9-4&#34;&gt;最近工作（moon-3d，2021-9-4）&lt;/h1&gt;
&lt;h2 id=&#34;概括&#34;&gt;概括&lt;/h2&gt;
&lt;p&gt;目的：模拟月球天平动和月相，即模拟月球在某个时间点的样子。&lt;/p&gt;
&lt;p&gt;科学方向：月球天平动、NASA 科学程序（jpleph, de440, stellarium(st)源码）&lt;/p&gt;
&lt;p&gt;技术栈：three.js, webGL, webpack 为主的一众打包工具, web 模块化&lt;/p&gt;
&lt;p&gt;未来工作：canvas 视频渲染、科学视频、三维引擎学习&lt;/p&gt;
&lt;p&gt;过程中遇到的具体阻碍：403 Forbidden&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;1数据获取&#34;&gt;1、数据获取&lt;/h2&gt;
&lt;h3 id=&#34;天平动及月相数据获取&#34;&gt;天平动及月相数据获取&lt;/h3&gt;
&lt;p&gt;首先有两种方法：力学模拟及直接使用数据。&lt;/p&gt;
&lt;p&gt;前者显然是不可能的，力学模拟天平动考虑的因素和运算量远超个人的能力。因此接下来的工作都在致力于获取天平动的数据集。&lt;/p&gt;
&lt;p&gt;在完全没有任何线索的情况下，我第一时间想到的就是 st 的源代码，因为 st 的模拟不可能没考虑天平动的影响，通过挖掘 st 源代码发现底层数据来源是 NASA 的&lt;a class=&#34;link&#34; href=&#34;https://ssd.jpl.NASA.gov/?planet_eph_export&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jpleph 程序及 de441(de440)&lt;/a&gt;数据集。&lt;/p&gt;
&lt;p&gt;下一个问题是如何生成数据。理论上可以直接通过 jpleph 的 api 直接生成数据，但需要通过 ftp 获取 jpleph(&lt;a class=&#34;link&#34; href=&#34;ftp://ssd.jpl.NASA.gov/pub/eph/planets/ascii/&#34; &gt;ftp://ssd.jpl.NASA.gov/pub/eph/planets/ascii/&lt;/a&gt;)，访问时总是 timeout。接下来尝试使用 python 的&lt;a class=&#34;link&#34; href=&#34;https://pypi.org/project/jplephem/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jplephem&lt;/a&gt;，却又因为文档不清晰的问题而放弃。最后无奈只能使用 NASA 提供的 web 界面&lt;a class=&#34;link&#34; href=&#34;http://ssd.jpl.NASA.gov/?horizons&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;horizons&lt;/a&gt;，虽然自定义参数少了许多，但至少好在方便易用。&lt;/p&gt;
&lt;p&gt;仔细阅读&lt;a class=&#34;link&#34; href=&#34;https://ssd.jpl.NASA.gov/?horizons_doc#specific_quantities&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;horizons 文档&lt;/a&gt;并经历了好几次因找不到对应参数而碰壁的过程后，最终确定了一系列需要的参数（一些是展示和验证需要的参数，有三项是模拟必须的参数，用*号标出）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间。Date__(UT)__HR:MN（UT 时间）以及 L_Ap_SOL_Time（本地太阳时）。&lt;/li&gt;
&lt;li&gt;月相相关参数，如被照亮面积百分比（Illu%）及月相角（S-T-O）&lt;/li&gt;
&lt;li&gt;*月下点经纬度（ObsSub-LON，ObsSub-LAT）&lt;/li&gt;
&lt;li&gt;*日照中心点经纬度（SunSub-LON，SunSub-LAT）&lt;/li&gt;
&lt;li&gt;*北极点位置（只需要其中的角度一个参数，NP.ang）&lt;/li&gt;
&lt;li&gt;其他重要参数。星等 APmag，表面亮度 S-brt，距离 d 等等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 horizons 中导出了这些数据的 csv 文件，保存备用。&lt;/p&gt;
&lt;p&gt;其实在过程当中发现了 NASA 的一个页面：&lt;a class=&#34;link&#34; href=&#34;https://svs.gsfc.NASA.gov/4874&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Moon Phase and Libration&lt;/a&gt;，在这里可以快速找到 2021 一整年的月相及天平动参数，后来发现和 jpleph 生成的参数如出一辙（其实本页下面引用就写着使用的是 jpleph 的数据），但好在 jpleph 的时间跨度和自定义程度远超这个页面，也不枉前面这么久的研究。&lt;/p&gt;
&lt;h3 id=&#34;月球模型&#34;&gt;月球模型&lt;/h3&gt;
&lt;p&gt;又是 NASA 的数据，不得不说 NASA 的科普做得真的好，我们什么时候才能赶上呢……&lt;/p&gt;
&lt;p&gt;来自 NASA 页面&lt;a class=&#34;link&#34; href=&#34;https://svs.gsfc.NASA.gov/4720&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CGI Moon Kit&lt;/a&gt;，这里提供了各种分辨率的月球表面的图和月球高度图。&lt;/p&gt;
&lt;p&gt;有了以上的数据，就可以开始思考使用什么技术栈实现模拟了。&lt;/p&gt;
&lt;h2 id=&#34;2技术选择&#34;&gt;2、技术选择&lt;/h2&gt;
&lt;p&gt;实现的技术有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似 st 的确定太阳月球地球星体位置及各种数据后综合计算&lt;/li&gt;
&lt;li&gt;类似 NASA 页面的直接进行三维模拟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于这个项目来说，显然后者是更好的选择。&lt;/p&gt;
&lt;p&gt;接下来就是技术栈的选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大型三维软件 unity，blender 等&lt;/li&gt;
&lt;li&gt;openGL，使用 python, C++语言&lt;/li&gt;
&lt;li&gt;webGL，使用浏览器的渲染&lt;/li&gt;
&lt;li&gt;echarts、plotly 等及它们 python 的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于这类科学数据可视化，进行编程的渲染大概率是最可靠的（其实是我不会用第一种的软件）。openGL 和 webGL 的引擎都是偏底层的（应该吧），并不利于快速实现。接下来我将目标转向了 echarts，发现的确是有类似的三维图例，但自由度不能达到项目的需求。最后选择第三种的原因是因为 three.js 库。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://threejs.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;three.js&lt;/a&gt;是在 webGL 上层的一个库，比 webGL 更加高级一点。&lt;/p&gt;
&lt;h2 id=&#34;3编程实现&#34;&gt;3、编程实现&lt;/h2&gt;
&lt;p&gt;这段过程就只讲一点点，其他详情直接看源代码。&lt;/p&gt;
&lt;h3 id=&#34;坐标轴的确立旋转方向的确定&#34;&gt;坐标轴的确立/旋转方向的确定&lt;/h3&gt;
&lt;p&gt;因为程序导入月球表面图的中心点是该图的左侧中心点，而 NASA 提供的表面图的经纬度原点是在该图的中心，导致导入后原点位置与预想并不相符。最后选择将摄影机移到经纬度为(0,0)的位置，但这样会导致坐标轴出现问题，因此可以看到 js 其中的一个程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lon&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有一个负号。&lt;/p&gt;
&lt;p&gt;其实这个问题是刚上手 three.js 遇到的问题，现在一想直接将球转 90 度不就好了吗……。不过程序既定，就懒得改了。&lt;/p&gt;
&lt;p&gt;旋转方向这个就是玄学问题了……。three.js 里面的 rotate 根本不知道绕着哪个轴转，只能通过实验确定。最后还闹了个笑话：北极点的旋转代码&lt;code&gt;camera.rotateZ(-(rotateAng / 180) * Math.PI)&lt;/code&gt;之前是没有负号的，导致月球倾斜方向与正确的方向完全对称。差点就要因为严谨性问题被拉出去打了……&lt;/p&gt;
&lt;h3 id=&#34;打包&#34;&gt;打包&lt;/h3&gt;
&lt;p&gt;说实话，对打包/前端工程化的概念在这个暑假才有确切的概念，曾经仅仅是学过而已。一开始选择的是 parcel，因为它的零配置可以让我在时间紧急的情况下（这个项目只用了两天做出来）快速得到编程结果。但到了后面这种简单性变成了累赘：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parcel 的体积大到离谱。global 安装一次，本地安装一次，我的 C 盘直接就告急了。&lt;/li&gt;
&lt;li&gt;到了后期，这种简单的无配置打包逐渐不能适应愈发增加的资源。如这个项目要用到的 png/csv 资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，最后全面倒向了 webpack。在前段时间学习的 webpack 也算是派上了用场。&lt;/p&gt;
&lt;h3 id=&#34;nginx-403-forbidden-及-gzip-压缩没错又是你-nginx&#34;&gt;nginx 403 Forbidden 及 gzip 压缩（没错，又是你 nginx）&lt;/h3&gt;
&lt;p&gt;最后发现是需要将所有文件夹和文件都调成可读及可运行，之前是忘记调成可运行了。&lt;/p&gt;
&lt;p&gt;对于 gzip 压缩，仅需&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取消这一段的注释即可。&lt;/p&gt;
&lt;h2 id=&#34;4一点想法&#34;&gt;4、一点想法&lt;/h2&gt;
&lt;p&gt;曾经的我还未被物理摧毁信心时，总会想着做一些数据驱动的科普小视频。这类视频没办法简单用 AE 做，因为 AE 的图像难以使用科学数据量化。&lt;/p&gt;
&lt;p&gt;可视化编程则是没有什么思路，特别是三维。这个项目前我大概只知道 matplotlib 和 plotly 等一系列可视化项目，但 matplotlib 的三维简直垃圾，echarts 等可视化项目的包装程度太高了，有时候一些想法没办法做。&lt;/p&gt;
&lt;p&gt;在这个项目后，确实是打开了思路。three.js/echarts/d3 等等优秀的前端可视化库也可以做到优秀的数据可视化。至于导出图片/视频的问题，因为 webGL 是渲染在 canvas 元素上，因此我们只需考虑如何导出 canvas 的数据即可。一些库如 node-canvas 和 CCapture.js 等就能做到。&lt;/p&gt;
&lt;p&gt;当然，并不意味着 python 就一无是处了，有一些我以前不知道的优秀的 python3d 库也是很能胜任这个任务的，且 python 的科学库比 node 多得多，以后有机会也会去体验一下。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
