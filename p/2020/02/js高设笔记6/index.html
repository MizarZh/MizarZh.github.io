<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='6 面向对象的程序设计 （注意：js中的面向对象实现与C&#43;&#43;中不同） 6.1 理解对象 var person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; person.age = 29; person.job = &amp;#34;Software Engineer&amp;#34;; person.sayName = function(){ alert(this.name); }; var person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, job: &amp;#34;Software Engineer&amp;#34;, sayName: function(){'>
<title>js高设笔记6</title>

<link rel='canonical' href='https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/'>

<link rel="stylesheet" href="/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css"><meta property='og:title' content='js高设笔记6'>
<meta property='og:description' content='6 面向对象的程序设计 （注意：js中的面向对象实现与C&#43;&#43;中不同） 6.1 理解对象 var person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; person.age = 29; person.job = &amp;#34;Software Engineer&amp;#34;; person.sayName = function(){ alert(this.name); }; var person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, job: &amp;#34;Software Engineer&amp;#34;, sayName: function(){'>
<meta property='og:url' content='https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/'>
<meta property='og:site_name' content='MizarZ&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='js' /><meta property='article:tag' content='笔记' /><meta property='article:published_time' content='2020-02-07T18:14:42&#43;08:00'/><meta property='article:modified_time' content='2020-02-07T18:14:42&#43;08:00'/>
<meta name="twitter:title" content="js高设笔记6">
<meta name="twitter:description" content="6 面向对象的程序设计 （注意：js中的面向对象实现与C&#43;&#43;中不同） 6.1 理解对象 var person = new Object(); person.name = &amp;#34;Nicholas&amp;#34;; person.age = 29; person.job = &amp;#34;Software Engineer&amp;#34;; person.sayName = function(){ alert(this.name); }; var person = { name: &amp;#34;Nicholas&amp;#34;, age: 29, job: &amp;#34;Software Engineer&amp;#34;, sayName: function(){">
    <link rel="shortcut icon" href="img/favicon-32x32.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu06d6ebd0fb0ddfbf4635527d9aae802d_36938_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">MizarZ&#39;s Blog</a></h1>
            <h2 class="site-description">半吊子物理系学生/啥都不会程序员/喜爱泛理科内容</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/MizarZh'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/academics/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>Academic</span>
            </a>
        </li>
        
        

        <li >
            <a href='/project/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Projects</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#6-面向对象的程序设计">6 面向对象的程序设计</a></li>
    <li><a href="#61-理解对象">6.1 理解对象</a>
      <ol>
        <li><a href="#611-属性类型">6.1.1 属性类型</a></li>
        <li><a href="#612-多个属性">6.1.2 多个属性</a></li>
        <li><a href="#613-读取属性的特性">6.1.3 读取属性的特性</a></li>
      </ol>
    </li>
    <li><a href="#62-创建对象">6.2 创建对象</a>
      <ol>
        <li><a href="#621-工厂模式">6.2.1 工厂模式</a></li>
        <li><a href="#622-构造函数模式">6.2.2 构造函数模式</a></li>
        <li><a href="#623-原型模式">6.2.3 原型模式</a></li>
        <li><a href="#624-组合使用构造函数模式和原型模式">6.2.4 组合使用构造函数模式和原型模式</a></li>
        <li><a href="#625-动态原型模式理解">6.2.5 动态原型模式(理解？)</a></li>
        <li><a href="#626-寄生构造函数模式">6.2.6 寄生构造函数模式</a></li>
        <li><a href="#627-稳妥构造函数模式">6.2.7 稳妥构造函数模式</a></li>
      </ol>
    </li>
    <li><a href="#63-继承">6.3 继承</a>
      <ol>
        <li><a href="#631-原型链">6.3.1 原型链</a></li>
        <li><a href="#632-借用构造函数">6.3.2 借用构造函数</a></li>
        <li><a href="#633-组合继承">6.3.3 组合继承</a></li>
        <li><a href="#634-原型式继承">6.3.4 原型式继承</a></li>
        <li><a href="#635-寄生式继承">6.3.5 寄生式继承</a></li>
        <li><a href="#636-寄生组合式继承">6.3.6 寄生组合式继承</a></li>
      </ol>
    </li>
    <li><a href="#总结">总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%BC%96%E7%A8%8B/" style="background-color: #0177b8; color: ;">
                编程
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/">js高设笔记6</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2020-02-07</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="6-面向对象的程序设计">6 面向对象的程序设计</h2>
<p>（注意：js中的面向对象实现与C++中不同）</p>
<h2 id="61-理解对象">6.1 理解对象</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span>      
</span></span><span class="line"><span class="cl">    <span class="nx">age</span><span class="o">:</span> <span class="mi">29</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">job</span><span class="o">:</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="611-属性类型">6.1.1 属性类型</h3>
<p><strong>数据属性</strong>
ECMA-262第 5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。 实现 JavaScript引擎用的，因此在 JavaScript中不能直接访问它们。
为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。</p>
<ol>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ol>
<p>要修改属性默认的特性，必须使用 ECMAScript 5的<strong>Object.defineProperty()</strong> 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span> 
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;Nicholas&#34;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">});</span> 
</span></span></code></pre></div><p>这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。</p>
<p>把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。</p>
<p><strong>访问器属性</strong>
访问器属性不包含数据值；它们包含一对 getter和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter函数并传入新值，这个函数负责决定如何处理数据。</p>
<ol>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为 undefined。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">book</span> <span class="o">=</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">_year</span><span class="o">:</span> <span class="mi">2004</span><span class="p">,</span>      
</span></span><span class="line"><span class="cl">    <span class="nx">edition</span><span class="o">:</span> <span class="mi">1</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">book</span><span class="p">,</span> <span class="s2">&#34;year&#34;</span><span class="p">,</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_year</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="p">},</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">&gt;</span> <span class="mi">2004</span><span class="p">)</span> <span class="p">{</span>             
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="nx">_year</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>             
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">.</span><span class="nx">edition</span> <span class="o">+=</span> <span class="nx">newValue</span> <span class="o">-</span> <span class="mi">2004</span><span class="p">;</span>         
</span></span><span class="line"><span class="cl">            <span class="p">}</span>     
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">});</span> 
</span></span><span class="line"><span class="cl"><span class="nx">book</span><span class="p">.</span><span class="nx">year</span> <span class="o">=</span> <span class="mi">2005</span><span class="p">;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">book</span><span class="p">.</span><span class="nx">edition</span><span class="p">);</span>  <span class="c1">//2
</span></span></span></code></pre></div><p>_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。
只指定 getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。</p>
<h3 id="612-多个属性">6.1.2 多个属性</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">book</span> <span class="o">=</span> <span class="p">{};</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">book</span><span class="p">,</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">_year</span><span class="o">:</span> <span class="p">{</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">value</span><span class="o">:</span> <span class="mi">2004</span>     
</span></span><span class="line"><span class="cl">    <span class="p">},</span>          
</span></span><span class="line"><span class="cl">    <span class="nx">edition</span><span class="o">:</span> <span class="p">{</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>     
</span></span><span class="line"><span class="cl">    <span class="p">},</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">year</span><span class="o">:</span> <span class="p">{</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_year</span><span class="p">;</span>         
</span></span><span class="line"><span class="cl">            <span class="p">},</span> 
</span></span><span class="line"><span class="cl">        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newValue</span><span class="p">){</span>             
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nx">newValue</span> <span class="o">&gt;</span> <span class="mi">2004</span><span class="p">)</span> <span class="p">{</span>                 
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">_year</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>        
</span></span><span class="line"><span class="cl">                <span class="k">this</span><span class="p">.</span><span class="nx">edition</span> <span class="o">+=</span> <span class="nx">newValue</span> <span class="o">-</span> <span class="mi">2004</span><span class="p">;</span>             
</span></span><span class="line"><span class="cl">                <span class="p">}</span>         
</span></span><span class="line"><span class="cl">            <span class="p">}</span>     
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="p">});</span> 
</span></span></code></pre></div><h3 id="613-读取属性的特性">6.1.3 读取属性的特性</h3>
<p>Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述 符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">book</span><span class="p">,</span> <span class="s2">&#34;_year&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>         <span class="c1">//2004 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span><span class="p">);</span> <span class="c1">//false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">get</span><span class="p">);</span>    <span class="c1">//&#34;undefined&#34; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">book</span><span class="p">,</span> <span class="s2">&#34;year&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>        <span class="c1">//undefined 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">enumerable</span><span class="p">);</span>   <span class="c1">//false 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">get</span><span class="p">);</span>   <span class="c1">//&#34;function&#34; 
</span></span></span></code></pre></div><h2 id="62-创建对象">6.2 创建对象</h2>
<h3 id="621-工厂模式">6.2.1 工厂模式</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">};</span>         
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;Greg&#34;</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&#34;Doctor&#34;</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="622-构造函数模式">6.2.2 构造函数模式</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">};</span>     
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Greg&#34;</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&#34;Doctor&#34;</span><span class="p">);</span> 
</span></span></code></pre></div><p>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。
使用了函数就是对象的想法，将属性添加到this上。</p>
<p>两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。</p>
<p>若Person不使用new，则认为是在为window添加属性
可使用call将作用域限定为某个对象</p>
<p>使用构造函数的主要<strong>问题</strong>，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。不同实例上的同名函数是不相等的。</p>
<h3 id="623-原型模式">6.2.3 原型模式</h3>
<p>解决构造函数的方法不相等问题。
prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
<p>原型对象的理解：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。</p>
<p><img src="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype1.jpg"
	width="848"
	height="360"
	srcset="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype1_hu98233ca4b998eb9df3b9f8954a41fc26_43053_480x0_resize_q75_box.jpg 480w, /p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype1_hu98233ca4b998eb9df3b9f8954a41fc26_43053_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="prototype1"
	
	
		class="gallery-image" 
		data-flex-grow="235"
		data-flex-basis="565px"
	
>
Person 的每个实例—— person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与构造函数没有直接的关系。
所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。
ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。</p>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。
当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。</p>
<p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。</p>
<p><strong>in操作符</strong>
单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">person1</span><span class="p">;</span>
</span></span></code></pre></div><p>ECMAScript 5也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。
要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5的 Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。
如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。</p>
<p>更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(){</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">name</span> <span class="o">:</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">age</span> <span class="o">:</span> <span class="mi">29</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">job</span><span class="o">:</span> <span class="s2">&#34;Software Engineer&#34;</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">sayName</span> <span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">        <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span></code></pre></div><p>有一个例外：constructor 属性不再指向 Person 了，指向Object
如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可用defineproperty重设回来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">constructor</span> <span class="o">:</span> <span class="nx">Person</span><span class="p">,</span>
</span></span></code></pre></div><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。
如果是重写整个原型对象，实例中的指针仅指向原来的原型，而不指向构造函数。
调用构造函数时会为实例添加一个指向初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与初原型之间的联系。
总结：先定义原型再创建实例，不然实例指向的是原prototype
<img src="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype2.jpg"
	width="873"
	height="669"
	srcset="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype2_hu74bd5609e3a6f26a45e486cb7acd986a_77997_480x0_resize_q75_box.jpg 480w, /p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype2_hu74bd5609e3a6f26a45e486cb7acd986a_77997_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="prototype2"
	
	
		class="gallery-image" 
		data-flex-grow="130"
		data-flex-basis="313px"
	
></p>
<p><strong>问题</strong>
它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。
共享，有时候需要分离的属性
因此不经常单独使用</p>
<h3 id="624-组合使用构造函数模式和原型模式">6.2.4 组合使用构造函数模式和原型模式</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">friends</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;Shelby&#34;</span><span class="p">,</span> <span class="s2">&#34;Court&#34;</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">constructor</span> <span class="o">:</span> <span class="nx">Person</span><span class="p">,</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">sayName</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，大限度地节省了内存。</p>
<p>是目前在 ECMAScript中使用广泛、认同度高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
<h3 id="625-动态原型模式理解">6.2.5 动态原型模式(理解？)</h3>
<p>它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//属性     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//方法     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">!=</span> <span class="s2">&#34;function&#34;</span><span class="p">){</span>              
</span></span><span class="line"><span class="cl">         <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>             
</span></span><span class="line"><span class="cl">             <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>         
</span></span><span class="line"><span class="cl">        <span class="p">};</span>              
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><h3 id="626-寄生构造函数模式">6.2.6 寄生构造函数模式</h3>
<p>寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">};</span>         
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。</p>
<p>首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。
我们建议在可以使用其他模式的情况下，不要使用这种模式。</p>
<h3 id="627-稳妥构造函数模式">6.2.7 稳妥构造函数模式</h3>
<p>稳妥对象（durable objects）。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">job</span><span class="p">){</span>          
</span></span><span class="line"><span class="cl">    <span class="c1">//创建要返回的对象     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//可以在这里定义私有变量和函数 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//添加方法     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>         
</span></span><span class="line"><span class="cl">        <span class="nx">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">};</span>              
</span></span><span class="line"><span class="cl">        <span class="c1">//返回对象     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">o</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>除了使用 sayName()方法之外，没有其他办法访问 name 的值。</p>
<h2 id="63-继承">6.3 继承</h2>
<p>继承分为接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript使用实现继承。
通过原型链实现</p>
<h3 id="631-原型链">6.3.1 原型链</h3>
<p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">SubType</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">//继承了 SuperType SubType.prototype = new SuperType(); 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubValue</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="nx">alert</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">getSuperValue</span><span class="p">());</span>      <span class="c1">//true  
</span></span></span></code></pre></div><p><img src="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype_chain.png"
	width="1568"
	height="780"
	srcset="/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype_chain_hu0b2c25ab46449d4a6937c3b60757748a_135611_480x0_resize_box_3.png 480w, /p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/prototype_chain_hu0b2c25ab46449d4a6937c3b60757748a_135611_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="prototype_chain"
	
	
		class="gallery-image" 
		data-flex-grow="201"
		data-flex-basis="482px"
	
></p>
<p>instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，后一步才会找到该方法。</p>
<p>最上层的原型链继承自Object，因此也可以使用Object的方法。</p>
<p>使用instanceof/isPrototypeof()对原型链上的对象进行比较都会返回true</p>
<p>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p><strong>即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链</strong></p>
<p><strong>问题</strong>
1 SubType 的所有实例都会共享属性。
2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h3 id="632-借用构造函数">6.3.2 借用构造函数</h3>
<p>在子类型构造函数的内部调用超类型构造函数。通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(){</span>     
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">SubType</span><span class="p">(){</span>       
</span></span><span class="line"><span class="cl">    <span class="c1">//继承了 SuperType     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>两者没有关系
如果SuperType可以传递参数，则使用call()方法也可传递参数
<strong>问题</strong>：方法都在构造函数中定义，无法复用函数。</p>
<h3 id="633-组合继承">6.3.3 组合继承</h3>
<p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</p>
<p>过程：先定义supertype的属性，再定义subtype的私有属性，再定义原型链。
js中最常用的继承模式</p>
<h3 id="634-原型式继承">6.3.4 原型式继承</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>     
</span></span><span class="line"><span class="cl">    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>进行浅复制，复制后仍指向原来的对象（共享属性）</p>
<p>ECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。
Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<h3 id="635-寄生式继承">6.3.5 寄生式继承</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">original</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">original</span><span class="p">);</span>  <span class="c1">//通过调用函数创建一个新对象     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>      <span class="c1">//以某种方式来增强这个对象         
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;hi&#34;</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">    <span class="p">};</span>     
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>         <span class="c1">//返回这个对象 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span></code></pre></div><h3 id="636-寄生组合式继承">6.3.6 寄生组合式继承</h3>
<p>组合继承大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<p>寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。|
不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">subType</span><span class="p">,</span> <span class="nx">superType</span><span class="p">){</span>     
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">superType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>     <span class="c1">//创建对象     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subType</span><span class="p">;</span>              <span class="c1">//增强对象     
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">subType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>               <span class="c1">//指定对象 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> 
</span></span></code></pre></div><p>在定义完supertype和subtype之后调用此函数，则完成了继承。</p>
<h2 id="总结">总结</h2>
<p>[[xxx]]当作是属性的属性，则可理解defineProperty和defineProperties的写法，以及getOwnPropertyDescripter指向的东西
模式：
[[Prototype]]实例所有，指向该实例的构造函数的原型对象
prototype为构造函数所有，指向该构造函数的原型对象
constructor实例所有，指向构造函数</p>
<ol>
<li>工厂模式 createPerson() + return</li>
<li>构造函数模式 Person() + new</li>
<li>原型模式 Person()的对象名prototype含有的属性Person.prototype.xxx</li>
<li>上面两个组合</li>
<li>动态原型</li>
<li>寄生构造函数、稳妥构造函数</li>
</ol>
<p>继承：</p>
<ol>
<li>原型链。subType的prototype指向superType的实例，则逻辑：subType为superType的一个实例 -&gt; subType拥有[[Prototype]]属性，且指向构造函数superType的原型对象superType.prototype -&gt; 原型链构造完成，可以寻找到superType.prototype的属性</li>
<li>借用构造函数：在subType内使用call()或apply()构建superType属性的深复制。</li>
<li>上面两者组合</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/js/">js</a>
        
            <a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/2022/02/canvas%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">Canvas笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/2022/01/js%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E5%85%B6%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">Js的模块系统以及其零碎知识</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/2022/01/echarts%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">Echarts基本使用</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/2022/01/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD%E5%8E%9F%E5%A7%8B%E5%AE%9E%E7%8E%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">前端下载原始实现</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/2022/01/date%E6%96%B9%E6%B3%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">Date方法</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2022 MizarZ&#39;s Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
