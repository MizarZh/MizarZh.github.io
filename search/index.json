[{"content":"1 通用提示 1、Array#someMethod()的含义是Array.prototype.someMethod()。\n2、通常，callback即测试每个元素的函数，接收element：当前值、index：当前索引、array：当前数组三个值。若不解释，则默认为此格式。\n3、thisArg是传入执行callback时作为this对象的值。\n4、修改数组的许多操作都是浅复制的。浅复制对于原生类型来说就是直接复制，新值与旧值没有关系，而对于引用类型来说类似于复制指向他们的指针，修改其中一个，其余被复制的都会改变。\n2 构造 Array() Array(3)：构造出[ , , ]，其中是空槽（与undefined不同）。\nArray(1,2,3)：构造出[1,2,3]。\n与new Array()相同。\n3 静态方法 Array.from() 语法：\nArray.from(arrayLike[, mapFn[, thisArg]]) 从类数组对象或者可迭代对象（arrayLike参数）中创建一个新的数组实例。能转换的类型有：\n1、伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）\n2、可迭代对象（可以获取对象中的元素,如 Map和 Set 等）\n有一个可选参数mapFn：如果指定了该参数，新数组中的每个元素会执行该回调函数（使用map方法）。\nArray.isArray() 用来判断某个变量是否是一个数组对象\n语法：\nArray.isArray() 返回：bool\nArray.of() 创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\n语法：\nArray.of(element0[, element1[, ...[, elementN]]]) 返回：Array\n同样也是创建数组，但与Array()的不同点是Array.of(3)构造出[3]，而Array(3)构造出[ , , ]。\n4 实例方法 I 查找 以下方法都不会修改原数组。\nArray#includes() 方法用来判断一个数组是否包含一个指定的值\n语法：\narr.includes(valueToFind[, fromIndex]) fromIndex参数指的是从某个索引开始搜索，负数索引即从尾部某个元素开始。\n输出：bool\n注意点\n如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。\nincludes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\nArray#indexOf() 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。\n语法：\narr.indexOf(searchElement[, fromIndex]) 输出：number\nArray#LastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。\n语法：\narr.lastIndexOf(searchElement[, fromIndex]) 输出：number\nArray#find() 返回数组中满足提供的测试函数的第一个元素的值。\n语法：\narr.find(callback[, thisArg]) 返回：找到的元素，失败则返回undefined\nfind方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。\n当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。\n注意点\n在第一次调用 callback函数时会确定元素的索引范围，因此在 find方法开始执行之后添加到数组的新元素将不会被 callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到，但是其值已经是undefined了。\nArray#findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\n语法：\narr.findIndex(callback[, thisArg]) 返回：number\n与Array#find()原理相同，只是返回的是元素的索引。\nII 遍历 以下方法都不会修改原数组。\nArray#every() 测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n语法：\narr.every(callback[, thisArg]) 输出：bool\nevery 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 falsy 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。\n注意点\nevery 不会改变原数组。\n若传入一个空数组，无论如何都会返回 true。\nArray#some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。\n语法：\narr.every(callback(element[, index[, array]])[, thisArg]) 输出：bool\n与Array#every()类似。some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some() 将会立即返回 true。否则，some() 返回 false。\nArray#map() 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n语法：\narr.map(callback[, thisArg]) map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。\nArray#filter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\n语法：\narr.filter(callback[, thisArg]) 返回： Array\nfilter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。\nArray#forEach() 对数组的每个元素执行一次给定的函数。\n语法：\narr.forEach(callback[, thisArg]) 返回：无输出\nforEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。\nforEach() 被调用时，不会改变原数组，也就是调用它的数组（尽管 callback 函数在被调用时可能会改变原数组）。\nArray#flat() 会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n语法：\narr.flat([depth]) depth指提取嵌套数组的结构深度，默认值为 1。\n返回：Array\n例子：\nvar arr1 = [1, 2, [3, 4]]; arr1.flat(); // [1, 2, 3, 4] Array#flatMap() 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\n语法：\narr.flatMap(callback[, thisArg]) 翻译：先使用map()，再使用flat(1)。\n返回： 一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。\n例子：\nvar arr1 = [1, 2, 3, 4]; arr1.map(x =\u0026gt; [x * 2]); // 这里的map对每个数操作之后会返回一个数组，意思就是每个元素都是数组 // [[2], [4], [6], [8]]  arr1.flatMap(x =\u0026gt; [x * 2]); // 先使用map()，再使用flat(1)，就会把返回的数组flat掉 // [2, 4, 6, 8]  // only one level is flattened arr1.flatMap(x =\u0026gt; [[x * 2]]); // [[2], [4], [6], [8]] 注意点：\n使用flatMap()比先使用map()，再使用flat(1)的效率更高一些。\nIII 遍历（累加） Array#reduce() 对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n语法：\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])   callback（其实就是祖传的callback+第一个参数为累加器而已）\n执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：\naccumulator ：累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。\ncurrentValue ：数组中正在处理的元素。\nindex 可选 ：数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。\narray可选 ：调用reduce()的数组。\n  initialValue可选\n作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。\n  翻译：初始值取为initialValue或者数组第一个值（initialValue未指定），然后每次进行callback的函数运算，回调函数的return值就是下一次的accumulator值（意味着第一个accumulator值就是initialValue或第一个数）。\n返回：函数累计处理的结果。\nreduce为数组中的每一个元素依次执行callback函数，返回最后的accumulator。\n注意点\n在空数组上调用 reduce 或 reduceRight 且未提供初始值（例如 [].reduce( (acc, cur, idx, arr) =\u0026gt; {} ) ）的话，会导致类型错误。\nArray#reduceRight() 法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\n与Array#reduce()类似，只不过方向是从右到左。\nIV 修改 以下方法会修改原数组。\nArray#pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。\n语法：\narr.pop() 返回：最后一个元素的值\n注意点\npop 方法有意具有通用性。\n如果在一个空数组上调用 pop()，它返回 undefined。\nArray#push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n语法：\narr.push(element1, ..., elementN) 返回：新的length，类型为number。\n注意点\npop 方法有意具有通用性。\nArray#shift() 从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\n语法：\narr.shift() 返回：第一个元素的值\n与Array#pop()类似。\nArray#unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度。\n语法：\narr.unshift(element1, ..., elementN) 返回：新的length，类型为number。\n与Array#push()类似。\nArray#sort() 用原地算法对数组的元素进行排序，并返回数组。\n语法：\narr.sort([compareFunction(firstEl, secondEl)])   compareFunction 可选\n用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。\nfirstEl 第一个用于比较的元素。\nsecondEl 第二个用于比较的元素。\n  返回：排序后的数组。请注意，数组已原地排序，并且不进行复制。\n如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：\n  如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n  如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n  如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。\n  compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。\n  Array#fill() 语法：\narr.fill(value[, start[, end]])   value\n用来填充数组元素的值。\n  start 可选\n起始索引，默认值为0。\n  end 可选\n终止索引，默认值为 this.length。\n  返回：Array\n例子：\nvar arr = [1,2,3] arr.fill(4) // [4,4,4] console.log(arr) // [4,4,4] arr.fill(2,0,1) // [2,4,4] console.log(arr) // [2,4,4]  var arr = Array(3).fill({}) // [{}, {}, {}]; // 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型 arr[0].hi = \u0026#34;hi\u0026#34;; // [{ hi: \u0026#34;hi\u0026#34; }, { hi: \u0026#34;hi\u0026#34; }, { hi: \u0026#34;hi\u0026#34; }] 注意点\n会修改原数组。\nfill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。\n如果使用arr.fill({})，传入的是引用类型。\nArray#copyWithin() 浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\n语法：\narr.copyWithin(target[, start[, end]])   target\n0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。\n如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。\n  start\n0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。\n如果 start 被忽略，copyWithin 将会从0开始复制。\n  end\n0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。\n如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）。\n  返回：Array，改变后的数组。\n若超过长度而复制未完成，就会截止（不改变原数组长度）。\ncopyWithin 函数被设计为通用式的，其不要求其 this 值必须是一个Array对象。\nArray#splice() 通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。\n语法：\narray.splice(start[, deleteCount[, item1[, item2[, ...]]]])   start\n指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。\n  deleteCount 可选\n整数，表示要移除的数组元素的个数。\n如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。\n如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。\n如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。\n  item1, item2, ... 可选\n要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。\n  翻译：从start位置往后数deleteCount个元素都会被删除，并填入item1, item2, ...元素。\n返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。\nV 打印/输出 以下方法都不会修改原数组。\nArray#join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\n语法：\narr.join([separator]) separator：若不选此参数，则分隔符为,，常用的如空字符串\u0026quot;\u0026quot;，则所有元素之间都没有任何字符。\n返回：String\n注意点\n如果一个元素为 undefined 或 null，它会被转换为空字符串。\nArray#slice() 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\n语法：\narr.slice([begin[, end]]) 返回：Array, 原数组一部分的浅拷贝\n对于引用元素是浅拷贝，对于原生类型是复制。\nArray#reverse() 将数组中元素的位置颠倒，并返回该数组。\n语法：\narr.reverse() 返回：Array, 颠倒的数组\n注意点\nreverse方法是特意类化的；此方法可被应用于类似数组对象。对象如果不包含反映一系列连续的、基于零的数值属性中的最后一个长度的属性，则该对象可能不会以任何有意义的方式运行。\nArray#concat() 用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n语法：\nold_array.concat(value1[, value2[, ...[, valueN]]]) valueN：数组和/或值。\n如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝。\n返回：Array, 合并的新数组\nArray#toString() Array#toLocaleString() 返回一个字符串，表示指定的数组及其元素。\n数组中的对象将使用各自的Object#toString()和Object#toLocaleString()\nVI 迭代器 可以用于es6中新的迭代器语法。如for of、.next()方法等。\nArray#entries() 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。\n例子：\nconst array1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const iterator1 = array1.entries(); console.log(iterator1.next().value); // expected output: Array [0, \u0026#34;a\u0026#34;]  console.log(iterator1.next().value); // expected output: Array [1, \u0026#34;b\u0026#34;] Array#keys() 返回一个包含数组中每个索引键的Array Iterator对象。\nArray#values() 返回一个包含数组中每个值的Array Iterator对象。\nArray#[@@iterator]() 数组的 iterator 方法，默认情况下，与 values()返回值相同\n语法：\narr[Symbol.iterator]() VII 实验性功能 Array#at() 支持正数和负数的索引取值。 语法：\nat(index) 返回：相对应的值。 例子：\nvar arr = [1,2,3,4] arr[-1] // undefined, js不支持负数索引 arr[arr.length - 1] // 4 arr.slice(-2, -1) // 4 arr.at(-1) // 4 ","date":"2021-11-10T22:10:09+08:00","permalink":"https://mizarzh.github.io/p/2021/11/array%E6%96%B9%E6%B3%95/","title":"Array方法"},{"content":"本文章是 You Dont Konw JS 类型部分的一个笔记。\n原生函数 常用的原生函数有：\n  String()\n  Number()\n  Boolean()\n  Array()\n  Object()\n  Function()\n  RegExp()\n  Date()\n  Error()\n  Symbol()——ES6 中新加入的\n  实际上，它们就是内建函数。\n原生函数可以被当作构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：\nvar a = new String( \u0026#34;abc\u0026#34; ); typeof a; // 是\u0026#34;object\u0026#34;，不是\u0026#34;String\u0026#34; a instanceof String; // true Object.prototype.toString.call( a ); // \u0026#34;[object String]\u0026#34; typeof 在这里返回的是对象类型的子类型。\n补充：instanceof（用class太多，该回去复习原型链了……）\nobject instanceof constructor // object 某个实例对象, constructor 某个构造函数 内部属性[[Class]] 所有 typeof 返回值为 \u0026ldquo;object\u0026rdquo; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类）。\n可以使用Object.prototype.toString(..)来查看：\nObject.prototype.toString.call( [1,2,3] ); // \u0026#34;[object Array]\u0026#34; Object.prototype.toString.call( null ); // \u0026#34;[object Null]\u0026#34; Object.prototype.toString.call( \u0026#34;abc\u0026#34; ); // \u0026#34;[object String]\u0026#34; 虽然null和undefined的原生构造函数并不存在，但仍然具有内部类型。\nString等类型是包装类型。\n封装对象包装 基本类型是不存在.length 和 .toString() 这样的属性和方法，因此需要通过封装对象才能访问。\n如果想要自行封装基本类型值，可以使用 Object(..) 函数（不带 new 关键字）\n拆封 如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数。\n原生函数作为构造函数 数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常 量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的。应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。\nArray Array(1,2,3) 和 new Array(1,2,3) 是一样的\nObject(..)、Function(..) 和 RegExp(..) 除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)。\nObject可以使用常量值的方法解决。\n构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候。\n强烈建议使用常量形式（如 /^a*b+/g）来定义正则表达式。\nDate(..) 和 Error(..) Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量 形式来作为它们的替代。\n创建日期对象必须使用 new Date()。Date(..) 可以带参数，用来指定日期和时间，而不带 参数的话则使用当前的日期和时间。\n构造函数 Error(..)带不带 new 关键字都可。错误对象通常与 throw 一起使用。\nSymbol(..) Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。但它不支持语法：\u0026ldquo;new Symbol()\u0026quot;。\n原生原型 Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式（无 任何匹配），而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。这种方法的一个好处是 .prototypes 已被创建并且仅创建一次。需要注意的一点是，如果默认值随后会被更改，那就不要使用 Array.prototype。\n","date":"2021-11-10T19:49:42+08:00","permalink":"https://mizarzh.github.io/p/2021/11/js%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/","title":"Js原生方法"},{"content":"本文章是 You Dont Konw JS 类型部分的一个笔记。\n1 js类型 js有七种内置类型：\n  空值（null）\n  未定义（undefined）\n  布尔值（boolean）\n  数字（number）\n  字符串（string）\n  对象（object）：包含array, function等子类型\n  符号（symbol，ES6 中新增）\n  类型可以使用typeof进行判断，但是有一些类型或特殊情况的判断是不同的：\n   类型 typeof判断类型     null \u0026lsquo;object\u0026rsquo;, 应该是\u0026rsquo;null'   function \u0026lsquo;function\u0026rsquo;, 应该是\u0026rsquo;object'   未定义变量（undeclared） \u0026lsquo;undefined\u0026rsquo;   其他（包括array） 相对应的类型（array对应的是\u0026rsquo;object'）    undefined和undeclared不同：已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。使用 undeclared 的变量会报错（ReferenceError）。\n2 数组、字符串、数字 仔细探讨这三个最常用的类型\n数组 1、内部可以容纳任何值。\n2、\nvar a = []; a[0] = 1; a[2] = 1; a[1] // undefined 但是a[1]的undefined和普通的undefined不同。\n3、因为array是对象，因此可以进行对象的操作：\nvar a = []; a[\u0026#39;foobar\u0026#39;] = \u0026#39;xxx\u0026#39;; // 合法 a[\u0026#39;13\u0026#39;] = \u0026#39;xxx\u0026#39; // 会被转换成13 但是并不算入length属性中。\n4、类数组\n类数组（一组通过数字索引的值）转换成真正的数组的方法：\nindexOf(..)、concat(..)、forEach(..)等方法\nArray.prototype.slice.call( arguments )方法\nArray.from(..)方法\n字符串 有很多地方和数组很像\n1、字符串不可变。\n2、可以借用一些数组的函数：\nvar a = \u0026#39;xwefqwef\u0026#39; Array.prototype.join.call( a, \u0026#34;,\u0026#34; ); Array.prototype.map.call Array.prototype.reverse.call无法调用，因为字符串不可变。\n一个经典的方法：\na.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); 对Unicode会无效。\n数字 js 没有真正意义上的整数。\nNumber转换的一些方法（Number.prototype）：\n   方法 作用     toExponential() 指数输出   tofixed(..) 指定小数数位   toPrecision(..) 指定有效数位   toLocaleString(..)    toString(..)    valueOf(..)     42.toFixed(3) // 无效，因为42.被认为是是浮点数 (42).toFixed( 3 ); // \u0026#34;42.000\u0026#34; 0.42.toFixed( 3 ); // \u0026#34;0.420\u0026#34; 42..toFixed( 3 ); // \u0026#34;42.000\u0026#34; 各种进制开头：0b 0o 0x\nIEEE 754浮点数的问题：\n0.1 + 0.2 === 0.3 // false 方法是使用机器精度判断（Number.EPSILON，值为2^-52 (2.220446049250313e-16)）：\nfunction numbersCloseEnoughToEqual(n1,n2) { return Math.abs( n1 - n2 ) \u0026lt; Number.EPSILON; } Number中各种特殊值：\n   特殊值 值 解释     Number.EPSILON 2^-52 ，2.220446049250313e-16 机器精度   Number.MAX_VALUE 1.798e+308 最大值   Number.MIN_VALUE e-324 最小值   Number.MAX_SAFE_INTEGER 2^53 - 1，9007199254740991 最大安全整数   Number. MIN_SAFE_INTEGER -9007199254740991 最小安全整数   Number.NaN NaN 非数字   Number.NEGATIVE_INFINITY -Inf 负无穷大值   Number.POSITIVE_INFINITY Inf 正无穷大值    方法：\n   方法 解释     Number.isInteger(..) 检测整数   Number.isSafeInteger(..) 是否是安全的整数   Number.isNaN(..) 检测是否是NaN   Number.isInfinite(..) 是否为有限数   Number.parseFloat(..) 转换为浮点数   Number.parseInt(..) 转换为整数    特殊值 1、void 运算符：没有返回值，即返回结果为undefined。\n2、检测NaN的另一方法：NaN 是 JavaScript 中唯 一一个不等于自身的值。\nif (!Number.isNaN) { Number.isNaN = function(n) { return n !== n; }; }; 3、Object.is(..)判断两个值是否绝对相等。\n3 值与引用 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。标量基本类型值是不可更改的（字符串和布尔也是如此）。\n而复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值 / 传递。\n即简单值表现为值，复合值表现为引用。\n4 更多的内置对象 见JavaScript 标准内置对象。\n","date":"2021-11-09T20:16:46+08:00","permalink":"https://mizarzh.github.io/p/2021/11/js%E7%B1%BB%E5%9E%8B/","title":"Js类型"},{"content":"background是css属性中经常会遇到的属性，接下来将详解这个属性的各个参数的含义。\nintro background 是一个复合属性，由：\n\u0026lt;attachment\u0026gt; \u0026lt;box\u0026gt; \u0026lt;background-color\u0026gt; \u0026lt;bg-image\u0026gt; \u0026lt;position\u0026gt; \u0026lt;repeat-style\u0026gt; \u0026lt;bg-size\u0026gt; 组成。\n后面是这些值的详解：\nbg-image 决定它的属性是background-image，作用是为一个元素设置一个或者多个背景图像。\n指定的背景可以是none，url()函数指定的图片，gradient()函数指定的梯度颜色。\nbackground-color 顾名思义，就是背景颜色\n可以使用#, rgb(), rgba()等指定颜色，也可以使用transparent（透明）。\nattachment 决定它的属性是background-attachment\n主要区分点是假设有一个元素，这个元素内部有一个滚动条，而外部（如整个窗口）也有一个滚动条。\n\rimage-20211105194635375\r\nfixed：外部和内部滑动都不动\n此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\nlocal：外部和内部滑动都随之而动\n此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\nscroll：内部滑动不动，而外部滑动随之动\n此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。\n可以使用逗号分隔，指定多个不同背景的attachment。\np { background-image: url(\u0026#34;picture1.png\u0026#34;), url(\u0026#34;picture2.png\u0026#34;); background-attachment: fixed, scroll; } position 决定它的属性是background-position。\n语法：\n 关键字 center，用来居中背景图片。关键字 top, left, bottom, right 中的一个，用来指定放在某个方向边缘的中间位置。 两个长度或百分比，指定相对于top和left的距离。 关键字top, left, bottom, right + 长度或百分比 x2。  例子：\nbackground-position: top; background-position: center; background-position: 25% 75%; background-position: 100px 200px; background-position: bottom 10px right 20px; background-position: right 3em bottom 10px; background-position: top right 10px; /* 距离top 0，距离right 10px */ 可以使用负值，即背景在框外。\n可以用逗号隔开，指定多个不同背景的position。\nrepeat-style 定义背景图像的重复方式。\n/* 单值语法 */ background-repeat: repeat-x; /* 相当于 repeat no-repeat，以下同理 */ background-repeat: repeat-y; background-repeat: repeat; background-repeat: space; background-repeat: round; background-repeat: no-repeat; /* 双值语法: 水平horizontal | 垂直vertical */ background-repeat: repeat space; background-repeat: repeat repeat; background-repeat: round space; background-repeat: no-repeat round; repeat：重复，边缘图像会裁剪。\nspace：图像会尽可能得重复，中间会有空隙，最边缘的图像会贴在边缘上, 不会裁剪。background-position会被无视除非只有一张图像。\nround：图像会被拉伸，直到有足够的空间来添加一个图像。当下一个图像被添加后, 所有的当前的图像会被压缩来腾出空间。什么时候添加下一个图像由浏览器决定。\nno-repeat：无重复。\n可以用逗号隔开，指定多个不同背景的background-repeat\nbackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。\n/* 关键字 */ background-size: cover background-size: contain /* 一个值: 这个值指定图片的宽度，图片的高度隐式的为auto */ background-size: 50% background-size: 3em background-size: 12px background-size: auto /* 两个值 */ /* 第一个值指定图片的宽度，第二个值指定图片的高度 */ background-size: 50% auto background-size: 3em 25% background-size: auto 6px background-size: auto auto 没有被背景图片覆盖的背景区域仍然会显示用background-color属性设置的背景颜色。\n关键字：\ncontain：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见，会尽可能保持图像的比例。\ncover：缩放背景图片以完全装入背景区，可能背景区部分空白，会尽可能保持图像的比例。\nbox 由两个属性决定： background-clip 和 background-origin\nbackground-clip：决定背景图片覆盖盒模型中的哪些部分。\nbackground-clip: border-box; background-clip: padding-box; background-clip: content-box; background-clip: text; background-origin：规定了指定背景图片background-image 属性的原点位置的背景相对区域。\nbackground-origin: border-box; background-origin: padding-box; background-origin: content-box; 当使用 background-attachment为fixed时，该属性将被忽略不起作用。\n综合 \u0026lt;box\u0026gt; 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 background-origin和 background-clip。如果出现 2 次，第一次的出现设置 background-origin，第二次的出现设置 background-clip。\n其他的能出现0次或1次。\n\u0026lt;bg-size\u0026gt; 只能紧接着 \u0026lt;position\u0026gt; 出现，以\u0026quot;/\u0026ldquo;分割，如： \u0026ldquo;center/80%\u0026rdquo;.\n\u0026lt;background-color\u0026gt; 只能被包含在最后一层。\n例子：\nbackground: center / contain no-repeat url(\u0026#34;logo.svg\u0026#34;), #eee 35% url(\u0026#34;logo2.svg\u0026#34;); background: left 5% / 15% 60% repeat-x url(\u0026#34;star.png\u0026#34;); ","date":"2021-11-05T19:37:44+08:00","permalink":"https://mizarzh.github.io/p/2021/11/css%E4%B8%ADbackground%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7/","title":"css中background相关属性"},{"content":"mathjax/katex test: $$ abc+edf $$\npicture test:\n\r\n本来是想要留个纪念（转hugo了），但是一上来就出现了大问题：hugo的运作机制和hexo大为不同，是没有mathjax的插件的，需要自己手动添加代码。\n目测有两种方法：一是在theme中插入mathjax代码从而渲染，二是安装hugo默认markdown渲染引擎goldmark的mathjax插件，或者使用pandoc之类的支持mathjax的渲染引擎。\n因为第一种方法较简单就直接使用第一种。解决方法：在themes/some-theme/layouts/partials/footer/footer.html的\u0026lt;footer\u0026gt;中添加语句：\n{{ if .Params.mathjax}} \u0026lt;!-- 判断文件中是否设置mathjax: true --\u0026gt; \u0026lt;!-- 引入mathjax3 --\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 文件头开启mathjax：\ntitle: \u0026#34;balabala\u0026#34; ... mathjax: true ... ​\n不得不说，hugo和hexo的运转机制十分不同，hugo的速度快，自由度也高许多，期望以后会有更好的使用体验。\n","date":"2021-10-27T16:21:58+08:00","image":"https://mizarzh.github.io/p/2021/10/my-first-post-mathjax-problem/%E5%B0%81%E9%9D%A2%E6%B5%8B%E8%AF%95_hue219db1679193659d52ea91d8c32cf29_372450_120x120_fill_q75_box_smart1.jpg","permalink":"https://mizarzh.github.io/p/2021/10/my-first-post-mathjax-problem/","title":"My First Post \u0026 Mathjax Problem"},{"content":"1 TeX TeX是Donald E. Knuth开发的一个排版系统。用户可以使用一系列的低级控制指令指导系统排版，同时支持变量、作用域、控制流和函数定义。\nTeX可执行文件/引擎是一个将源文件渲染成排版后可供阅读的文件的二进制程序。较早期的输出文件为DVI，目前较流行的文件为PDF。以下方括号内代表对应的可执行文件。\n2 TeX宏包/TeX格式 由于TeX的使用十分繁杂，因此就发展出了更高级别的宏包方便人们使用。\nPlain TeX [tex]: 最原始的TeX宏包。包含了一些基本的宏命令。\nLaTeX [latex]: 目前版本为LaTeX2e，早先版本为LaTeX2.09。目前最常用的格式。\nConTeXt [context]\nTexinfo [tex, makeinfo]: 将Texinfo文件转换成HTML、DocBook、Emacs info、XML和文本。配合其他的工具可以转换为DVI或PDF。\nEplain [eplain]: Plain TeX的拓展。\n3 改良的TeX可执行文件/引擎 由于TeX是一个1970年代的程序，因此并不能适应现在的一些渲染需求。\npdfTeX [pdftex]: 一个可直接渲染pdf文件的引擎。\nXeTeX [xetex]: 与pdfTeX差不多，但支持UTF-8。\nLuaTeX [luatex]: 使用lua作为脚本语言，可以进行更加方便的编程。\ne-TeX [etex]: 是TeX的一个拓展。\n引擎与渲染格式的配合：\n使用pdftex --fmt=latex\n为方便使用，就定义了pdflatex这个命令。\n\r\n使用不同的方法渲染至pdf的步骤：\n\rimage-20211006214418135\r\n4 TeX发行版 TeX发行版能够提供一套成体系的TeX工具。通常人们说安装TeX是指安装发行版。\nTeX Live: 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是“官方”的 TeX 系统。\nMiKTeX: 较为轻量级的一个发行版，初始安装仅包含最基本的宏命令，后续按需安装。\nMacTeX: TeX Live在mac上的替代品。\n5 编辑器 vscode、vim、tex studio之类\n用于编辑tex文件，渲染工作由引擎进行。\n6 CTAN CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。\n7 参考 [1] https://texfaq.org/FAQ-texthings\n[2] https://www.tug.org/levels.html 。通过这里也可以访问tug官网。\n[3] LaTeX入门 by 刘海洋\n[4]https://liam.page/2018/11/26/introduction-to-TeX-engine-format-and-distribution/ 。更加详细的介绍。\n","date":"2021-10-06T20:44:39+08:00","permalink":"https://mizarzh.github.io/p/2021/10/%E5%90%84%E7%B1%BBtex/","title":"各类“TeX”"},{"content":"0 整体参数 参数：速度、尺寸、容量/成本、耐用性/寿命\n1 机械硬盘（Hard Disk Drive, HDD） 大牌：西数，东芝，希捷\n1.1 物理结构 使用磁介质储存数据\n\r\n硬盘的物理结构一般由磁头与盘片、电动机、主控芯片与排线等部件组成；当主电动机带动盘片旋转时，副电动机带动一组（磁头）到相对应的盘片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与盘片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n 磁道  当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。资料存储手段从LMR进展到PMR这中又有CMR、SMR等技术。\n 柱面  在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n 扇区  磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。硬盘的第一个扇区，叫做引导扇区。\n\r\n磁道（Track），柱面（Cylinder），扇区（Sector），磁头（Heads），盘片（Platters）\n每个盘片都有两面，因此也会相对应每盘片有2个磁头。\n\r\nA：磁道 B：扇面 C：扇区 D：簇（扇区组）\n1.2 参数 **尺寸 **2.5寸（笔记本、移动机械硬盘）和3.5寸（主机）。\n转速 7200rpm或5400rpm，显然转速越快读取速度越快。\n传输速度\n5400rpm硬盘平均读写速度大致在60-90MB/s这个区间。\n7200rpm硬盘大致在130-250MB/s区间。\n垂直式（CMR）与叠瓦式（SMR）：推荐CMR。SMR建议用作只读盘而不修改。\n将一个磁道拿出来并近似为平面。\n古早的机械硬盘的磁性颗粒是水平排列的（因为写探头的大小问题）。\n\r\n后来，写探头变小了，因此可以将磁性颗粒竖着排放，这种排列方式被称为PMR：\n\r\n为了提高存储的密度，厂家开发出了更加丧心病狂的SMR（也属于PMR），即将磁性颗粒部分相重叠：\n\r\n原来的传统PMR技术就被称为C(conventional)MR。CMR磁道间有间隔，而SMR叠在了一起，因此没有间隔。\n\r\n\r\n读取探头比写入探头要小。CMR的读写很好理解，写入和读取不同的磁道完全是相互独立的。而对于SMR来说，后写入的数据会覆盖较前写入的数据的磁道的下半部分，但是由于读取探头较小，因此可以正常读取数据（读取之前写入数据的磁道的上半部分）。但是如果要修改之前写入过的数据，就需要缓存后写入的数据，写入新数据，再一层一层写入后面的数据。这就是为什么SMR的缓存较大且最好写入后就不要再修改的原因。\n\r\n空气/氦气\n目前空气硬盘最多可以容纳 6 片盘片（西部数据 HC330，1.67TB x 6 = 10TB），氦气硬盘依靠氦气的低密度降低磁盘间距和盘片厚度，盘体内最多可以容纳 9 片盘片（2.0TB x 9 = 18TB），同时常常兼具功耗低、噪音小等附带属性，但是因为氦气需要被完全密封在盘体内，硬盘的死法又多了一个氦气漏气的类型。\n接口 SATA, USB(移动硬盘)\n1.3 扇区管理 MBR GBT\n主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是电脑引导后访问硬盘时所必须要读取的首个扇区，主引导扇区记录着硬盘本身的相关消息以及硬盘各个分割的大小及位置消息，是资料消息的重要入口。如果它受到破坏，硬盘上的基本数据结构消息将会丢失，需要用繁琐的方式试探性的重建数据结构消息后才可能重新访问原先的资料，对于那些扇区为512位组的磁盘，MBR分割表不支持容量大于2.2TB（2.2×1012字节）的扇区。\n全局唯一标识分区表（GUID Partition Table，GPT）是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准的一部分。GPT分配64bits给逻辑块地址，因而使得最大分区大小为$2^{64}-1$个扇区。对于每个扇区大小为512字节的磁盘，相当于9.4ZB（9,444,732,965,739,290,426,880字节或 18,446,744,073,709,551,615（$2^{64}-1$）个扇区x 512（$2^9$）字节每扇区）。\n\r\n1.4 历史 来源链接：https://zhuanlan.zhihu.com/p/74275200\n1973年Winchester技术硬盘，确定了硬盘的基本架构，利用几个同轴涂上磁性材料的金属圆盘和可移动磁头密封在一个盒子里，通过圆盘旋转读出信号的改变。 1979年IBM研发了薄膜磁头技术，进一步减小硬盘体积。 1981年IBM研发了MR（Magnerto Resistive磁阻）技术，将存储密度从200Mbpsi提高了数十倍，为大容量硬盘的诞生奠定了基础。 1991年，经过了10年推出了MR技术3.5英寸的1GB硬盘。3.5寸也成为了现在计算机硬盘的标准规格。 1997年，GMR巨磁阻效应磁头诞生，存储密度比MR技术高了8倍多，但是好景不长也基本达到了瓶颈。 2005年，**垂直写入技术（Perpendicular Recording，PMR）**的大量使用使得在2007年日立推出了第一款突破TB级容量的硬盘。进入1TB时代。（单盘1TB） 2010年后SSD走上舞台。 2012年才有了第一款4TB的硬盘。 受限于机械硬盘的瓶颈，2012-2017年机械硬盘技术发展基本处于停滞状态，价格对于今天而言略降。 2017年推出了叠瓦式磁记录(Shingled Magneting Recording，SMR)技术，允许磁轨互相重叠，像屋顶的瓦片。这种方式使得单盘容量能够达到2TB。但是SMR硬盘的缺点是比较致命的，对于一些存有数据的磁轨，如果写入，针对的是磁轨的全部宽度，而磁轨的重叠会导致临近的磁轨被重写。\n1.5 杂项 护理\n不要拆开！不要拆开！不要拆开！机械硬盘拆开直接报废。\nSMR硬盘最好不要频繁修改数据。\n2 固态硬盘（Solid-state Drive,SSD） 牌子有很多\n来源：https://www.zhihu.com/question/355642710/answer/897977012\n第一梯队（自产自销）：\n三星，西数/闪迪，东芝，英特尔/镁光。\n其中三星最贵也最好，西数性价比略高，东芝性能一般，英特尔便宜的真便宜，贵的真™贵。\n第二梯队（原厂颗粒）：\n浦科特，金士顿。\n浦科特近年来都没出几个好的固态，性价比不算高。金士顿用的是买原厂颗粒自己封装的，颗粒稳定性不如第一梯队。\n第三梯队（白片）：\n各种品牌定制，联想，宏碁，影驰，七彩虹等等。这些一般都是拿原厂检测不合格但能用的白片，可靠性一般，性能还行。\n第四梯队（黑片）：\n光威悍将，以及各种便宜到不可思议的固态，多是国产品牌。黑片的可靠性不用多说了吧，说不准哪天突然就boom了。\n以下部分数据来源：https://www.zhihu.com/question/19926569/answer/547791508\nhttps://zh.wikipedia.org/wiki/固态硬盘\n1.1 物理结构 \r\n用非易失性存储器（主要以闪存中的 NAND Flash）作为永久性存储设备。\n固态硬盘由主控、缓存、闪存（NAND Flash）组成。\n主控 主控是SSD非常重要的一部分，相当于电脑的CPU，是决定固态性能优劣的核心。由于技术门槛较高，所以主控品牌比较少，目前头部品牌有马牌（Marvell）、三星、英特尔（Intel），另外还有瑞昱、东芝（铠侠）、慧荣、群联等表现不错。\n闪存 NAND Flash分为四种：SLC, MLC, TLC, QLC。分别代表一个Cell能存储1bit、2bit、3bit和4bit的数据。能储存的数据量从QLC至SLC依次递增。\n\r\n读取速度SLC依次递减至QLC，价格同理。\n目前主流是TLC，QLC也在逐渐占领市场，SLC和MLC基本只能在高端产品中见到。\n1.2 接口/外形 根据物理外形可以分为2.5英寸、M.2和AIC（独立显卡那样的插卡式）三类。\n根据电气标准可以分为SATA和PCIe两类。\n根据数据协议可以分为AHCI和NVMe两类。\nSSD的类型：\n\r\nPCIe接口和SATA接口的区别：\n\r\nm.2的长度：\n\r\nPCIe4.0与PCIe3.0 PCIe 4.0的传输速率定义为16GT/s，比3.0翻番。但PCIe 4.0技术较新，价格昂贵，因此不一定适合需求。\n1.3 参数 成本 比机械硬盘昂贵。\n速度 sata协议的硬盘接口：m.2接口，sata3接口，PCI-E x2接口。速度在500-700MB/SNVME协议的硬盘接口：m.2接口，PCIE-E x4接口。3000MB/S以上。\n与机械硬盘相比，固态硬盘拥有更快的读写速度（无论是顺序读写还是随机读写）、更高的IOPS（每秒响应次数）以及更低的响应延迟（类比机械硬盘的寻道时间）。\n寿命 由于浮栅MOSFET中本征电场的存在，随着时间流逝产生的电荷泄漏，会逐渐导致NAND闪存中的数据出错甚至无法读取。由于陷阱辅助隧穿（Trap-assisted tunneling (TAT)）效应，随着擦写次数（编程/擦除周期数，Program/Erase Cycle (P/E Cycle)）的增加，氧化物绝缘层逐渐磨损，NAND闪存的可靠性会逐渐降低（数据保持时间缩短）。升高温度也会使数据保持时间缩短。\n一些特性 由于没有像机械硬盘那样的运动部件，固态硬盘对振动/震动没那么敏感，较为耐摔，运行时发出的噪音几乎不可闻。但是，固态硬盘在发生故障或因误操作删除、覆盖数据时基本无法恢复。\nU盘 结构类似固态硬盘。\n同样使用NAND Flash作为储存，同样有主控进行写入。最大差别是便携性、容量和接口。\n各种接口在下篇文章有详解。\nSD/TF卡 同样使用NAND作为储存\n链接：https://zhuanlan.zhihu.com/p/66018996\n外观区分：\nSD卡体积为24mm×32mm×2.1mm；\nTF卡体积为15mm×11mm×1mm！\n名称区分：\nSD卡即Secure Digital Memory Card，中文翻译为安全数码卡。\nTF卡即T-Flash又称MicroSD，是一种记忆卡。后改称为TransFlash；而重新命名为MicroSD的原因是因为被SD协会（SDA）采立。另一些被SDA采立的记忆卡包括miniSD和SD卡。\n用途区分：\nSD卡被广泛地于便携式装置上使用，例如数码相机、个人数码助理(PDA)和多媒体播放器等。\nTF卡主要于手机使用，但因它拥有体积极小的优点，随着不断提升的容量，它慢慢开始于GPS设备、便携式音乐播放器和一些快闪存储器盘中使用。\nSD卡级别：\n\r\n","date":"2021-09-27T19:44:52+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E7%A1%AC%E7%9B%98/%E5%82%A8%E5%AD%98%E4%BB%8B%E8%B4%A8%E7%AC%94%E8%AE%B0/","title":"硬盘/储存介质笔记"},{"content":"天文光度学 几个重要参数和概念 衡量光的强度使用的是能量$E$，衡量光单位时间内的强度用的是功率$P$。由于光不断在运动，恒星不断在产能，因此使用后者是较为合理的。\n定义以下参数：\n流量(flux): 单位$\\text W$，指单位时间内某个面积流过的总能量。\n流量密度(flux density) $F$: 单位$\\text{W/m}^2$，即单位面积单位时间上流过的总能量。\n光度(luminosity) $L$：即天文学上对恒星使用的流量，某些情境中可交替使用。\n有时候单位中会有$\\text{Hz}^{-1}$，这种情况指的是在某个不同频率的波段上的相应参数。\n导出参数及关系 如果源是各向同性发射的，那么有一条关系式： $$ L=4\\pi r^2 F $$ 即众所周知的平方反比定律：\n\r\n星等 历史 公元前二世纪，Hipparchos定义了一套星等系统：将天上所有可见的星分为六等，最明亮的为一等星，勉强可见的最暗星为六等星。\n这个定义十分的不准确，因此到了1856年，Norman R. Pogson定义了一套全新的系统，这就是现在的星等系统。\n原理及推导 人眼对光的响应是对数的。假如有三颗星，它们的流量密度之比为1:10:100，人眼就会感觉一二颗星及二三颗星之间的差别是相等的。即每降一个星等，星的流量密度就要乘一个倍数，这是一个对数运算。\n利用这个特性，我们可以定义一等星与六等星的流量密度之比为100。那么对于人眼来说，n比n+1等要亮$\\sqrt[5]{100}=2.512$等。那么： $$ \\frac{F_n}{F_{n+1}}=\\sqrt[5]{100}\\Rightarrow\\lg\\frac{F_n}{F_{n+1}}=2/5\\Rightarrow-2.5\\lg\\frac{F_n}{F_{n+1}}=-1=n-(n+1) $$\n即假设星等和对应流量密度$m_1,F_1,m_2,F_2$，则有普森（Pogson）公式： $$ m_1-m_2=-2.5\\lg\\frac{F_1}{F_2} $$\n有时候为便运算，可定义零等星对应的流量密度为$F_0$，则任意星等$m$及对应流量密度$F$的定义式为： $$ m=-2.5\\lg \\frac{F}{F_0} $$\n星等系统 星等可以代表不同波段上的光的强度。如我们可以定义眼睛看到的星等为$m_V$，摄像机拍到的星等为$m_{\\text{pg}}$等。\n如果可以测量所有波长的光，那么我们得到的星等就是热星等$m_{\\text{bol}}$，这是一个十分有用的参数，但难以测量，因此天文学家定义了一个参数热改正$\\text{BC}$(bolometric correction)来快速计算热星等： $$ m_{\\text{bol}}=m_{V}-\\text{BC} $$ 当然也有可能是正号，看具体情况。\n$m_V$，$m_{\\text{pg}}$定义的星等并不准确，因此在1950年早期Harold L. Johnson 和 William W. Morgan定义了一套星等系统叫做UBV系统，即加入不同波段的透镜让望远镜接收不同波段的光从而判断颜色。后续发展出了UBVRI和ubvy系统：\n\r\n\r\n我们常用色指数(color index)这个参数来判断星的颜色，常用的如$U-B,B-V$，对于A0型星，这两个指数都为0。\n绝对星等 之前的星等都是一个相对的概念，为了绝对地衡量一颗星的亮度，需要使用绝对星等。\n绝对星等$M$的定义即为一颗星放在10pc处的星等。根据定义： $$ m-M=-2.5\\lg\\frac{F(r)}{F(10\\mathrm{pc})}=-2.5\\lg\\frac{\\frac{L}{4\\pi r^2}}{\\frac{L}{4\\pi (10\\mathrm{pc})^2}}\\\n=5\\lg\\frac{r}{10\\mathrm{pc}}\\\n=5\\lg r-5\\ (r单位为\\mathrm{pc}) $$ 可以定义绝对星等之间的比较。如，假设有一颗星对应的参数为$M_{\\text{bol}},F,L$，太阳对应的参数为$M_{\\text{bol}\\odot},F_\\odot,L_\\odot$，则： $$ M_{\\text{bol}}-M_{\\text{bol}\\odot}=-2.5\\lg\\frac{F}{F_\\odot}=-2.5\\lg\\frac{L/4\\pi r^2}{L_\\odot/4\\pi r^2}=-2.5\\lg\\frac{L}{L_\\odot} $$\n消光(extinction)和光深(optical thickness) 解说待补充 $$ dL=−\\alpha Ldr $$ $\\alpha$ opacity\noptical thickness: $$ d\\tau = \\alpha dr $$ thus: $$ dL=-Ld\\tau\\Rightarrow L=L_0e^{-\\tau} $$ 对星等系统的影响： $$ m-M=5\\lg\\frac{r}{10\\mathrm{pc}}+(2.5 \\lg e)\\tau=5\\lg\\frac{r}{10\\mathrm{pc}}+A $$ 若均匀，则： $$ \\tau=\\alpha\\int^r_0dr=\\alpha r\\\nm-M=5\\lg\\frac{r}{10\\mathrm{pc}}+ar, a=2.5\\alpha $$\n色余(color excess) 色指数： $$ B-V=M_B-M_V+A_B-A_V=(B-V)0+E{B-V} $$\n$(B-V)0$被称为intrinsic color，$E{B-V}=(B-V)-(B-V)_0$被称为色余(color excess)。星际介质导致：\n$$ R=\\frac{A_V}{E_{B-V}}\\approx 3.0 $$ 几乎一致。这个现象被称为星际红化。\n大气消光 \r $$ X=\\sec z \\\nm=m_0+kX $$ $X$被称为空气质量(air mass)，$k$被称为消光系数。\n","date":"2021-09-11T15:34:01+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E5%A4%A9%E6%96%87%E5%85%89%E5%BA%A6%E5%AD%A6/","title":"天文光度学"},{"content":"天文望远镜基本知识 天文望远镜类型  折射望远镜 反射望远镜 折反式望远镜  折射与反射望远镜示意图：\n\rreflect-and-refract\r\n折射望远镜 最老的是伽利略式望远镜，使用的是一凸一凹的镜片。\n\r伽利略\r\n后来改进成两个凸透镜，但出现了另一个问题：色差(chromatic aberration)，即不同颜色聚焦在不同的焦点上，导致成像有色彩分离和偏差现象。\n\r色差\r\n解决方法是加入一个或多个凸透镜从而消除色差的影响。可以分为普通消色差和复消色差望远镜。\n由于复消色差望远镜如此优秀，其仍是拍摄的最佳选择，就是贵。\n反射望远镜 分牛反和其他反，牛反在开头的示意图，卡塞格林反射镜如下：\n\r卡塞格林\r\n反射望远镜的问题有彗差(coma)和球差(spherical aberration)。\n彗差是由于是轴外物点发出宽光束通过光学系统后，并不会聚一点，相对于主光线而是呈彗星状图形的一种失对称的像差。\n球差是由于电磁透镜中心区域和边缘区域对电磁波会聚能力不同而造成的。\n\r彗差\r\n\r球差\r\n折反射望远镜 为了解决反射望远镜的种种问题，就需要在前面增加矫正镜。有两种不同的添加方式，对应两种不同的望远镜。\n\r施卡和马卡\r\nmounting 系统 实在不知道怎么翻译……\n望远镜有两种 mounting 系统，即地平式及赤道式。对于普通望远镜来说赤道式的望远镜是最适合的，但对于大型望远镜来说，赤道式所承受的重量不够，且有软件的辅助，基本都采用地平式。\n参数 基本参数   口径$D$：最重要的参数。\n  焦距$f$\n  目镜焦距 $f'$\n  人眼参数：瞳孔直径$d_{\\text{pupil}}=6\\text{mm}$，对 555nm 光线最敏感。最小分辨角$e_{\\text{pupil}}\\approx2'$。\n  推导参数 放大率 $$G=f/f'$$ \r\n推导：放大率顾名思义即镜中看到的大小与实际物体角大小的比值。即：\n$$ G=u'/u \\\ns=f\\tan u\\approx fu = f\u0026rsquo;u' \\\nG=u'/u=f/f' $$\n焦比 $F=f/D$，通常写法 f/3.5,f/10 等等。这个数与望远镜收集光的数量相关。\n理论视场 $\\tan(\\omega/2)=D/f$，及其小角近似。简单推导即可得。\n分辨本领、最小分辨角 \r $$\\theta=1.22\\lambda/D$$ 取$\\lambda=550\\text{nm}$，可得：$\\theta(^\u0026quot;)=140/D(\\text{mm})$。\n底片比例尺 $$\\omega=d/f$$ 意为底片上$d$的长度相当于视场中$\\omega$的角大小。推导：\n\r\n极限星等 推导：人眼极限星等 6，口径 6mm。 $$m=6+2.5\\lg(\\frac{D}{6})^2=2.1+5\\lg D$$\n最大放大率 眼睛的最小分辨角/望远镜的最小分辨角即为最大放大率 $$G_{\\text{max}}=2'/\\theta\\approx 2'\\cdot D/\\lambda\\approx D/1\\text{mm}$$\n最小放大率、出瞳口径 \r\n如图，出瞳口径$L$必须比瞳孔大小要小。 $$L=\\frac{f'}{f}D=\\frac{D}{G}$$ 由$L\\le d_{\\text{pupil}}$即可知$G\\ge D/d_{\\text{pupil}}$\n常识 影响观测的因素 seeing（视宁度）：大气的抖动。视宁度越好，大气抖动越少，观测条件越好。\n接收器材 照相底片-\u0026gt;光电倍增管-\u0026gt;CCD（电子耦合器件）\n量子效率逐渐提升，线性性逐渐增加，光子利用率逐渐增大。\n还有另一类重要的观测方法即光谱。\n有两种方法分光：棱镜分光和光栅分光。光栅分光的损耗率远远低于棱镜分光，因此基本都在用光栅分光。\n波段观测 概况 波段分类：\n\r\n波段在大气中的通过率及相关信息：\n\r \r\n蟹状星云在不同波段下的相片：\n\r\n以下的例子都是大型望远镜。\n射电 两种模式：steerable（可转动的）和不可转动的。\n组合模式：单体和多体（使用干涉技术提升等效口径）\n例子：\n可转动的如飞马, green bank\n不可转动如 FAST, Arecibo。这类望远镜其实并不是完全不可动，它可以将一部分球形变形为抛物线形从而接收信号并获得一部分的转向能力。\n多体如 ALMA, VLA。\n微波 微波与射电较为相似，但镜面更加光滑。\n红外 和光学望远镜较为相似。\n由于大气的阻隔，大部分是太空望远镜，只有少部分在高海拔地区的地面望远镜。\n例子：\nHerschel 太空望远镜，鸽王 James Webb 太空望远镜。\n可见光 地面望远镜、太空望远镜。\n分折射、反射。\n最大的折射望远镜是在 Yerkes Observatory 的 1m 折射望远镜。\n现在主流的大口径望远镜都是反射望远镜，有单体磨成的镜片和许多块单独镜面拼成，目前最大 10m，详情见望远镜排行榜。未来的大望远镜有 E-ELT 39m 及 TMT 30m。新技术有主动光学和有限的干涉。\n太空望远镜最著名的就是 Hubble 望远镜。\n紫外 分软紫外及硬紫外。\n说实话，没啥著名的（\nX 射线 分软 X 射线及硬 X 射线。\n由于 X 射线极强的穿透性，导致传统的折射和反射类型望远镜都无法使用。\n有两种解决方案：\n1、grazing（掠射）。如瞳（反向调节最为致命），钱德拉 X 射线天文台。\n2、做成桶状，直接接收。如 HXMT（慧眼）\n$\\gamma$射线 同样的使用掠射的方案。\n著名的卫星有：swift（雨燕）卫星，Fermi（费米）伽马射线太空望远镜。\n有一种间接观测的方法是观测通过$\\gamma$射线与空气之间的切伦科夫效应发出的光，如 MAGIC 望远镜。\n其他媒介 中微子\n中微子与其他物质难以作用，但也不是完全不可作用。主要方法是探测中微子在重水中的切伦科夫辐射。\n著名天文台：日本的神冈、南极的 IceCube。\n引力波\n原理是通过迈克尔逊干涉仪测量空间上的微小震荡从而观测引力波的发生。科学仪器：LIGO。\n后记 望远镜介绍这里好多图都没有放，就是懒……以后有机会补上吧。\n","date":"2021-09-09T23:27:17+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E5%A4%A9%E6%96%87%E6%9C%9B%E8%BF%9C%E9%95%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"天文望远镜基础知识"},{"content":"webpack 学习 介绍 webpack 不用多介绍，一个大名鼎鼎的前端打包工具。\n官网上是这么介绍的：\n 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n 关键概念 webpack 的核心概念有四个：\n 入口(entry) 输出(output) loader 插件(plugins)  webpack 配置文件：\nconst path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./src/js/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;index.bundle.js\u0026#39;, }, module: { rules: [{ test: /\\.txt$/, use: \u0026#39;raw-loader\u0026#39; }], }, plugins: [new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; })], mode: \u0026#39;development\u0026#39;, }; entry 指从指定文件处开始进行打包，output 指定打包后输出的位置及名称。\nmodule(loader)对于引入的特定文件会有特殊的处理。文件通过正则表达式进行匹配，可选择不同的 loader 从而达成不同的操作效果。\nplugin 相较于 loader 则有着更为强大的功能。\nmode 指定工作模式。development 生成文件易读，production 则会开启代码压缩等等。\n一些应用 总体配置 const path = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); // 导入html插件  module.exports = { mode: \u0026#39;production\u0026#39;, entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;index.bundle.js\u0026#39;, }, module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;], }, { test: /\\.sass/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39;], }, { test: /\\.(jpg|png|gif)$/, use: [ { loader: \u0026#39;file-loader\u0026#39;, options: { outputPath: \u0026#39;img\u0026#39;, name: \u0026#39;[hash:10].[ext]\u0026#39;, }, }, ], }, { test: /\\.(csv|txt)$/, use: [\u0026#39;raw-loader\u0026#39;], }, { exclude: /\\.(html|js|css|jpg|png|gif)$/, use: [ { loader: \u0026#39;file-loader\u0026#39;, options: { outputPath: \u0026#39;media\u0026#39;, name: \u0026#39;[hash:10].[ext]\u0026#39;, }, }, ], }, ], }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, }), ], devServer: { hot: true, compress: true, port: 9000, }, }; 学习过程中迷惑的点  在 js 文件中引入的 html 文件使用HTMlWebpackPlugin不需要在\u0026lt;script\u0026gt;\u0026lt;link\u0026gt;等标签中再引入 js 和 css。 一种情况：  import someFile from \u0026#39;./data/someFile\u0026#39;; 若使用file-loader，则 someFile 返回的是地址（网址+目录）\n若使用raw-loader，则返回的是纯文本\n","date":"2021-09-08T23:10:32+08:00","permalink":"https://mizarzh.github.io/p/2021/09/webpack%E5%AD%A6%E4%B9%A0/","title":"webpack学习"},{"content":"最近工作（moon-3d，2021-9-4） 概括 目的：模拟月球天平动和月相，即模拟月球在某个时间点的样子。\n科学方向：月球天平动、NASA 科学程序（jpleph, de440, stellarium(st)源码）\n技术栈：three.js, webGL, webpack 为主的一众打包工具, web 模块化\n未来工作：canvas 视频渲染、科学视频、三维引擎学习\n过程中遇到的具体阻碍：403 Forbidden\n1、数据获取 天平动及月相数据获取 首先有两种方法：力学模拟及直接使用数据。\n前者显然是不可能的，力学模拟天平动考虑的因素和运算量远超个人的能力。因此接下来的工作都在致力于获取天平动的数据集。\n在完全没有任何线索的情况下，我第一时间想到的就是 st 的源代码，因为 st 的模拟不可能没考虑天平动的影响，通过挖掘 st 源代码发现底层数据来源是 NASA 的jpleph 程序及 de441(de440)数据集。\n下一个问题是如何生成数据。理论上可以直接通过 jpleph 的 api 直接生成数据，但需要通过 ftp 获取 jpleph(ftp://ssd.jpl.NASA.gov/pub/eph/planets/ascii/)，访问时总是 timeout。接下来尝试使用 python 的jplephem，却又因为文档不清晰的问题而放弃。最后无奈只能使用 NASA 提供的 web 界面horizons，虽然自定义参数少了许多，但至少好在方便易用。\n仔细阅读horizons 文档并经历了好几次因找不到对应参数而碰壁的过程后，最终确定了一系列需要的参数（一些是展示和验证需要的参数，有三项是模拟必须的参数，用*号标出）：\n 时间。Date__(UT)__HR:MN（UT 时间）以及 L_Ap_SOL_Time（本地太阳时）。 月相相关参数，如被照亮面积百分比（Illu%）及月相角（S-T-O） *月下点经纬度（ObsSub-LON，ObsSub-LAT） *日照中心点经纬度（SunSub-LON，SunSub-LAT） *北极点位置（只需要其中的角度一个参数，NP.ang） 其他重要参数。星等 APmag，表面亮度 S-brt，距离 d 等等  在 horizons 中导出了这些数据的 csv 文件，保存备用。\n其实在过程当中发现了 NASA 的一个页面：Moon Phase and Libration，在这里可以快速找到 2021 一整年的月相及天平动参数，后来发现和 jpleph 生成的参数如出一辙（其实本页下面引用就写着使用的是 jpleph 的数据），但好在 jpleph 的时间跨度和自定义程度远超这个页面，也不枉前面这么久的研究。\n月球模型 又是 NASA 的数据，不得不说 NASA 的科普做得真的好，我们什么时候才能赶上呢……\n来自 NASA 页面CGI Moon Kit，这里提供了各种分辨率的月球表面的图和月球高度图。\n有了以上的数据，就可以开始思考使用什么技术栈实现模拟了。\n2、技术选择 实现的技术有很多：\n 类似 st 的确定太阳月球地球星体位置及各种数据后综合计算 类似 NASA 页面的直接进行三维模拟  对于这个项目来说，显然后者是更好的选择。\n接下来就是技术栈的选择：\n 大型三维软件 unity，blender 等 openGL，使用 python, C++语言 webGL，使用浏览器的渲染 echarts、plotly 等及它们 python 的版本  对于这类科学数据可视化，进行编程的渲染大概率是最可靠的（其实是我不会用第一种的软件）。openGL 和 webGL 的引擎都是偏底层的（应该吧），并不利于快速实现。接下来我将目标转向了 echarts，发现的确是有类似的三维图例，但自由度不能达到项目的需求。最后选择第三种的原因是因为 three.js 库。\nthree.js是在 webGL 上层的一个库，比 webGL 更加高级一点。\n3、编程实现 这段过程就只讲一点点，其他详情直接看源代码。\n坐标轴的确立/旋转方向的确定 因为程序导入月球表面图的中心点是该图的左侧中心点，而 NASA 提供的表面图的经纬度原点是在该图的中心，导致导入后原点位置与预想并不相符。最后选择将摄影机移到经纬度为(0,0)的位置，但这样会导致坐标轴出现问题，因此可以看到 js 其中的一个程序：\nreturn [ r * Math.cos(lat) * Math.cos(lon), r * Math.sin(lat), -r * Math.cos(lat) * Math.sin(lon), ]; 有一个负号。\n其实这个问题是刚上手 three.js 遇到的问题，现在一想直接将球转 90 度不就好了吗……。不过程序既定，就懒得改了。\n旋转方向这个就是玄学问题了……。three.js 里面的 rotate 根本不知道绕着哪个轴转，只能通过实验确定。最后还闹了个笑话：北极点的旋转代码camera.rotateZ(-(rotateAng / 180) * Math.PI)之前是没有负号的，导致月球倾斜方向与正确的方向完全对称。差点就要因为严谨性问题被拉出去打了……\n打包 说实话，对打包/前端工程化的概念在这个暑假才有确切的概念，曾经仅仅是学过而已。一开始选择的是 parcel，因为它的零配置可以让我在时间紧急的情况下（这个项目只用了两天做出来）快速得到编程结果。但到了后面这种简单性变成了累赘：\n parcel 的体积大到离谱。global 安装一次，本地安装一次，我的 C 盘直接就告急了。 到了后期，这种简单的无配置打包逐渐不能适应愈发增加的资源。如这个项目要用到的 png/csv 资源。  因此，最后全面倒向了 webpack。在前段时间学习的 webpack 也算是派上了用场。\nnginx 403 Forbidden 及 gzip 压缩（没错，又是你 nginx） 最后发现是需要将所有文件夹和文件都调成可读及可运行，之前是忘记调成可运行了。\n对于 gzip 压缩，仅需\ngzip_vary on;\rgzip_proxied any;\rgzip_comp_level 6;\rgzip_buffers 16 8k;\rgzip_http_version 1.1;\rgzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r取消这一段的注释即可。\n4、一点想法 曾经的我还未被物理摧毁信心时，总会想着做一些数据驱动的科普小视频。这类视频没办法简单用 AE 做，因为 AE 的图像难以使用科学数据量化。\n可视化编程则是没有什么思路，特别是三维。这个项目前我大概只知道 matplotlib 和 plotly 等一系列可视化项目，但 matplotlib 的三维简直垃圾，echarts 等可视化项目的包装程度太高了，有时候一些想法没办法做。\n在这个项目后，确实是打开了思路。three.js/echarts/d3 等等优秀的前端可视化库也可以做到优秀的数据可视化。至于导出图片/视频的问题，因为 webGL 是渲染在 canvas 元素上，因此我们只需考虑如何导出 canvas 的数据即可。一些库如 node-canvas 和 CCapture.js 等就能做到。\n当然，并不意味着 python 就一无是处了，有一些我以前不知道的优秀的 python3d 库也是很能胜任这个任务的，且 python 的科学库比 node 多得多，以后有机会也会去体验一下。\n","date":"2021-09-08T23:05:27+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952021-9-4-moon3d/","title":"最近进展2021-9-4 moon3d"},{"content":"初始配置 2020-12-23 这真的是大工程…… 简单说来，由于学生机服务器带宽过于拉跨，因此想使用学生机frp做内网穿透，使用raspberry作为wordpress服务器。 wordpress中文官网 此文章主要参考这个教程以及这个配置来操作。 以下内容默认开启su\n1、下载 使用wget获取官网下载内容：\nwget https://cn.wordpress.org/latest-zh_CN.tar.gz tar -zxvf latest-zh_CN.tar.gz 然后见到一大堆php文件，不要慌，先将文件夹中wp-config-sample.php复制一份并改名为wp-config.php。 复制一份到/var/www/html或者其子文件夹处，这一份是被别人访问的。修改访问权限（不知道这步有没有用）：\nchown -R www-data:www-data /var/www/html 接下来整一些别的东西。\n2、数据库 wordpress是需要使用数据库的，我嫌弃mysql安装太麻烦而且不在apt中，改用mariadb，其用法与mysql基本一致。\napt install mariadb-server #安装 mysqladmin -u root password \u0026#34;[enter your password here]\u0026#34; #设置root密码 mysql -u root -p #用root用户密码登录 #以下是在mysql环境中操作CREATEDATABASEwordpress#创建新数据库wordpress#这两句似乎是授予权限，但是感觉就在服务器本机做这个没什么必要GRANTALLPRIVILEGESONdatabasename.*TO\u0026#34;wordpressusername\u0026#34;@\u0026#34;hostname\u0026#34;FLUSHPRIVILEGES;EXIT;#退出3、配置wp-config.php 修改其中的内容：\n/** WordPress数据库的名称 */ define( \u0026#39;DB_NAME\u0026#39;, \u0026#39;database_name_here\u0026#39; ); /** MySQL数据库用户名 */ define( \u0026#39;DB_USER\u0026#39;, \u0026#39;username_here\u0026#39; ); /** MySQL数据库密码 */ define( \u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;password_here\u0026#39; ); /** MySQL主机 */ define( \u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39; ); 这几句将之前创建的数据库数据填入即可\ndefine( \u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); 填入随机数，在此处获取，直接复制进去就好了。 填入后即完成配置\n4、服务器配置（nginx） nginx代理这部分对于我这种新手来说做起来非常复杂（主要是由于php的原因），在网上也见到不下于三种对nginx的操作，这里选择了成功的一种讲。 首先需要安装php相关服务：\napt install php-fpm php-mysql 接下来修改nginx中的server block configuration部分：\nvim /etc/nginx/sites-available/default 在server出做出如下修改：\n 在index index.html那一行加上index.php 取消对location ~ .php$和location ~/.ht部分的注释，但注意location ~ .php 中只需要开启fastcgi_pass unix://那一条即可（记得匹配fpm版本号） nginx.conf就不需要修改了 此步玩成了就算正式完成了wordpress的配置，打开nginx服务：  service nginx start 打开http://yourip/wp-login.php登陆使用gui配置就方便多啦。 ps：如果是放在/var/www/html的子文件夹处，如/var/www/html/blog，那么就需要在访问网址后加上这个名称，如http://yourip/wp-login.php/blog，或者将nginx配置中的root设为这个目录处。\n5、frp配置 放在有公网的学生机的frps配置：\n[common] bind_port = 7000 vhost_http_port = 80 放在内网web服务的frpc配置：\n[common] server_addr = frp服务器ip server_port = 7000 [web] type = http local_port = 80 custom_domains = frp服务器ip或服务器域名 使用nohup挂载在后台即可\nip迁移 在宿舍迁回家，由于ip不同导致wordpress打开缓慢，这里写下解决方法以备不时之需。\n暴力解决法 在数据库中，修改以下几个表中的值：\n wp_options 直接将表中的option_value 字段中所有的老地址都替换成新地址 update wp_options set option_value = replace(option_value,\u0026lsquo;老地址\u0026rsquo;, \u0026lsquo;新地址\u0026rsquo;); wp_posts 修改guid字段和post_content字段，将其中的老ip替换为新IP wp_dtree_cache 在我的侧边栏菜单里，还需要修改一下这个表才能变过来： update wp_dtree_cache set content = replace(content, \u0026lsquo;老地址\u0026rsquo;, \u0026lsquo;新地址\u0026rsquo;);  UPDATEwp_optionsSEToption_value=replace(option_value,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;)WHEREoption_name=\u0026#39;home\u0026#39;ORoption_name=\u0026#39;siteurl\u0026#39;;UPDATEwp_postsSETpost_content=replace(post_content,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;);UPDATEwp_postsSETguid=replace(guid,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;);在nginx中/etc/nginx/sites-available/default中修改地址为新地址\n简单方法 wp-login应该还是可以访问的。通过它进入管理界面，在设置中修改ip地址即可。\n","date":"2021-01-10T20:54:39+08:00","permalink":"https://mizarzh.github.io/p/2021/01/wordpress%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%8F%8Aip%E8%BF%81%E7%A7%BB/","title":"wordpress初始配置及ip迁移"},{"content":"github网址 虽然离开学只有一个月了这个脚本估计也没什么用了233，但是研究这套系统对以后的自动化也是有帮助的。\n研究历程： 其实在五六月份的时候就已经开始想做这个脚本了。我以为只需要直接post账号和密码即可，但是发现是带加密的，当时又很菜不知道怎么搞定lt会更新的问题，于是便搁置了一段时间。但是在某日看到某位dalao在知乎发的贴子，突然就想到使用session保持状态即可（我太菜了）。登录的方法和知乎文章几乎一致。以下是过程：\nlt的值每次会话都会不一样。lt的值储存在页面\u0026lt;input id=\u0026ldquo;lt\u0026rdquo;\u0026gt;的控件中，因此需要使用get方法获取页面并得到lt值\n接下来使用post登录，post需要传递的数据是rsa,ul,pl,lt,execution,_eventId。通过翻阅登录按钮的事件函数发现：\n ul、pl分别为账号和密码长度 rsa是由一个叫strEnc(u+p+lt,\u0026lsquo;1\u0026rsquo;,\u0026lsquo;2\u0026rsquo;,\u0026lsquo;3\u0026rsquo;)的函数算出来的 execution看不懂是什么，一般为e1s1，目测和url的长短有关 _eventId为固定值submit 接下来要解决的问题是如何运行strEnc。首先将strEnc所在的des.js下载到本地，再通过pyExesJS的包运行js得到rsa，再由同一个session post即可完成登录验证。  接下来需要解决上报信息的问题。 这里的表单比较长，建议不要自己填而是抓取网页中post的json下载到本地再加以改造。 表单是报平安的各项数据，基本是固定值，但其中几个时间需要注意，不然可能时间冲突导致无法更新。\n   键 值     \u0026ldquo;inHubeiToHubeiDate\u0026rdquo; 固定为1580910916335   \u0026ldquo;recordDate\u0026rdquo; \u0026ldquo;visitingRelativesOrTravelToWenzhouDate\u0026rdquo; \u0026ldquo;recordShowDate\u0026rdquo; 每日0时的毫秒值   \u0026ldquo;createTime\u0026rdquo; 此页面创建时间的毫秒值，亲测可以使用当前时间代替   \u0026ldquo;updateTime\u0026rdquo; 当前时间的毫秒值    将这些时间数据更新后post即可\n最后是每日定时执行脚本。使用python内部的sched的话需要一直运行python不太方便，于是转而使用系统的定时执行 win系统为例：\n win + R，输入compmgmt.msc 打开任务计划程序栏，创建基本任务 输入名称和描述，设置每天某个时间点运行，操作为启动程序 最重要的一步：程序或脚本输入python.exe，添加参数为.py文件所在位置，起始于为python.exe的位置（添加到了PATH的话应该不需要填写这项）  ","date":"2020-07-04T16:49:29+08:00","permalink":"https://mizarzh.github.io/p/2020/07/%E5%8D%8E%E5%B7%A5%E8%87%AA%E5%8A%A8%E6%8A%A5%E5%B9%B3%E5%AE%89%E8%84%9A%E6%9C%AC/","title":"华工自动报平安脚本"},{"content":"Nodejs服务器 写了一个Tool-box，其中有下载视频的功能。 原理是使用服务端的you-get识别下载网址的url从而得到下载地址，但却冒出一堆奇妙的bug。emm\n起初的想法是用户端发送get/post到服务端，然后服务端调用you-get识别URL并将其返回，再由客户端开启下载。\n首先解决要解决的问题是python的运行环境问题。对于我这种python渣渣来说，用了好一会才搞明白python（或者是anaconda吧）除了REPL还有命令行的直接运行环境（就是有一个base前面的）。使用you-get必须激活这个环境。\nconda activate base you-get -u URL 然后是服务器的routing。用express并不难解决，但是后端功力仍需锻炼。\n最后发现在下载bilibili时遇到了CORS不能跨域的问题（客户端无法调节referer，似乎使用xhr.setRequestHeader也无法设定access-control-allow-origin不过我觉得是我不会用），可能需要改用服务端下载并传输。然后发现无法调用下载的界面emmm，可能需要使用下载.js之类的组件。总之慢慢改善好了。\n\u0026ndash;6/4\u0026ndash; access-control-allow-origin是使用在服务端的回应上的，客户端的Referer单纯用js无法伪造，这类的技术叫做防盗链。但是使用服务端可以伪造referer，因为可能需要将下载放在服务端了。 bootstrap的使用还是比较正常的，就是在使用tab的时候使用flex结构会导致不能相互隐藏，可能是内部还要再套一层div吧。 正在制作新主页。\n计算机组成原理 开始啃四大了233，计算机组成原理6/3到130页，继续加油。 \u0026ndash;6/4\u0026ndash; 计算机组成原理到170页，实在是太难刷了qwq。js算法也快读完了，接下来可以开始搞算(gua)法(ke)了。\n","date":"2020-06-03T23:40:33+08:00","permalink":"https://mizarzh.github.io/p/2020/06/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-6-3/","title":"最近进展2020-6-3"},{"content":"众所周之frp是一款内网穿透工具，可以用来干很多神奇的事情。我使用frp也有很多种目的，接下来就慢慢细说。\nMC服务器 在某个ddl成堆的晚上，某损友找上了我说要帮他整个MC服务器，并向我吹嘘它家的电脑多么强劲。我想着回头再帮他看看吧，最终碍于爱搞事情的本性愉快的放弃了一堆没做的东西开始折腾起怎么搭建mc服务器的事情。\n其实搭建mc服务器本身并不难，在有一台云主机（没有公网ip也想整frp就别想了→_→）的情况下，第一反应就是在云主机上搭建mc服务器。我在之前的blog中已经写过mc服务器应该如何搭建了，但是这孱弱的性能怕撑不起这么多人，加上他吹嘘他家的电脑，我决定使用本地主机搭建服务器+内网穿透的方法搭建多人mc服务器。\n首先先下载frp。 frps是frp的服务器，应放置在有公网ip的服务器上（这里指的是孱弱服务器）。 使用scp传文件到服务器上 frpc是frp的客户端，应放置在要暴露服务的机器上（这里指的是损友电脑）。\n接下来在服务端配置frps.ini：\n[common] bind_port = // 其他机器访问的端口 客户端frpc.ini的配置:\n[common] server_addr = // 服务器的地址 server_port = // frps.ini中的bind_port [minecraft] type = tcp local_ip = 127.0.0.1 // 本地 local_port = 25565 // mc开启的端口 remote_port = 25565 都配置好之后就在命令行中分别运行\n./frps ./frpc 同时开启mc服务器，在其他机器上输入连接frpc.ini中的server_addr:server_port即可开始游戏。\n","date":"2020-05-19T23:36:19+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8Bfrp/","title":"瞎折腾之frp"},{"content":"自从上大学换了新电脑以后，家里的这台没啥电脑知识的我爸在电脑城买的联想傻大黑粗配置还不怎么样的旧笔记本就闲置在家多月。前几个月疫情肆虐，待在家里使用内网的需求也大大提升，于是这台旧电脑就被我改造成了家庭内网服务器。\nVNC viewer 由于旧电脑存了太多的黑历史，一时半会还整理不完全，于是没有办法装linux系统。众所周知win的cmd是个废柴，因此决定使用VNC来远程操控服务器。\n去到VNC的官网下载Windows版本的Server，在一系列操作后就装好了VNC Server。新电脑装上VNC Client就可以访问服务器电脑了。\nPlex 在家庭服务器上部署plex媒体服务，然后就可以在其他设备上自由浏览家庭服务器上的视频资源了。\n去Plex下载处下载windows server，也是和VNC一样简单易用。再给电视装上Plex的应用就可以直接访问服务器的视频资源而不是用蠢到要死的自带资源了。\n初级文件管理及分享 使用windows的鸡肋分享功能做了个简易的文件分享。不得不说windows的配置和用户管理让我摸不着头脑。 首先是文件夹右键-属性-共享-共享\u0026hellip;，然后在下拉框内选择Everyone并添加。这还没完，还需要在高级共享\u0026hellip;勾选共享此文件夹，并在权限内添加everyone的读取/写入权限，才能算完全开启文件夹的共享功能。 这一套下来就搞不懂用户的用处以及为什么要分两个共享……，之前有一段时间似乎是想明白有什么区别，但是现在又搞不清楚了。 anyway，总之共享上能用，没有什么问题了。然后android手机安装文件管理器app，就可以远程访问服务器内的资源了。只不过访问必须要使用anonymous访问，不然不管输入什么用户名什么密码都无法连接。\naria2 ","date":"2020-05-19T23:36:02+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8B%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"瞎折腾之家庭服务器"},{"content":"nodejs入门笔记 全局对象 global process属性 提供了一个与操作系统的简单接口\n process.argv是命令行参数数组 process.stdout是标准输出流。stdout.write()更加底层 process.stdin是标准输入流。初始被暂停，要读取必须恢复流：  process.stdin.resume(); process.nextTick(callback)的功能是为事件循环设置一项任务，Node.js 会在下次事件循环调响应时调用 callback。  console 用于向标准输出流（stdout）或标准错误流（stderr）输出字符\n log() error() trace(),向标准错误流输出当前的调用栈。  常用工具 util  inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。  还有isArray(),isRegExp(),isDate(),isError(),format(),debug()\n事件驱动 events  EventEmitter事件发射器。  var events = require(\u0026#39;events\u0026#39;); var emitter = new events.EventEmitter(); emitter.on(\u0026#39;aEvent\u0026#39;,function(arg1,arg2){ //dosomething(); }) emitter.emit(\u0026#39;aEvent\u0026#39;,arg1,arg2) EventEmitter.on(event, listener) 为指定事件注册一个监听器 EventEmitter.emit(event, [arg1], [arg2], [\u0026hellip;]) 发射 event 事件 EventEmitter.once(event, listener) 为指定事件注册一个单次监听器 EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。 2. error事件\nemitter.emit(\u0026#39;error\u0026#39;); 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它  fs  readFile(filename,[encoding],[callback(err,data)]) 或readFile(filename,[callback(err,data)]) 同步版本readFileSync(filename, [encoding]) open(path, flags, [mode], [callback(err, fd)]) flags:r r+ w w+ a a+ mode:用于创建文件时给文件指定权限 fd:文件描述符。是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引 read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)]) write同理  http HTTP 服务器 var http = require(\u0026#39;http\u0026#39;); http.createServer(function (req,res){ res.writeHead(\u0026#39;200\u0026#39;,{\u0026#39;Content-Type\u0026#39;:\u0026#39;text/html\u0026#39;}); res.write(\u0026#39;\u0026lt;h1\u0026gt;Node.js\u0026lt;/h1\u0026gt;\u0026#39;); res.end(\u0026#39;\u0026lt;p\u0026gt;test\u0026lt;/p\u0026gt;\u0026#39;); }).listen(3000); console.log(\u0026#39;http server is listening at port 3000\u0026#39;); http.createServer 创建了一个 http.Server 的实例\nhttp.Server 的事件  request:当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是 http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。 connection:当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为 net.Socket 的实例。 close:当服务器关闭时，该事件被触发。 除此之外还有 checkContinue、upgrade、clientError 事件 createServer（创建一个 HTTP 服务器并将requestListener 作为 request 事件的监听函数）拆开写法：  var server = new http.Server(); // 新建http.Server实例 // 在服务器收到请求时的事件响应 server.on(\u0026#39;request\u0026#39;, function (req, res) { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); res.write(\u0026#39;\u0026lt;h1\u0026gt;Node.js\u0026lt;/h1\u0026gt;\u0026#39;); res.end(\u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;); }); // 指定服务器监听端口 server.listen(3000); http.ServerRequest 事件\n data:当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。 end:当请求体数据传输完成时，该事件被触发 close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。  属性 complete 客户端请求是否已经发送完成 httpVersion,method,url,headers,trailers,connection,socket,client\n获取GET内容 使用url模块中的parse解析url参数，生成一个对象\n获取POST内容 var querystring = require(\u0026#39;querystring\u0026#39;); http.createServer(function (req, res) { var post = \u0026#39;\u0026#39;; // 侦测POST传入的data事件并记录  req.on(\u0026#39;data\u0026#39;, function (chunk) { post += chunk; }); // 检测传入是否结束  req.on(\u0026#39;end\u0026#39;, function () { post = querystring.parse(post); res.end(util.inspect(post)); }); }).listen(3000); http.ServerResponse 返回给客户端的信息\n writeHead(statusCode, [headers])：向请求的客户端发送响应头。 write(data, [encoding])：向请求的客户端发送响应内容。 end([data], [encoding])：结束响应，必须被调用一次。  HTTP 客户端 http.request(options, callback) 发起 HTTP 请求。 options:\n{ host : 127.0.0.1, // 请求网站的ip地址  port : 3000, // 请求网站的端口  method : \u0026#39;get\u0026#39;, //请求方法  path : //相对于根的路径，应该包括queryString  headers : //请求头的内容 } callback 传递一个参数，为 http.ClientResponse 的实例。 http.request 返回一个 http.ClientRequest 的实例。\nhttp.get(options, callback),自动将请求方法设为了 GET 请求，同时不需要手动调用req.end()。\nhttp.ClientRequest 它提供一个 response 事件 提供了 write 和 end 函 数，用于向服务器发送请求体 request.abort()：终止正在发送的请求。 request.setTimeout(timeout, [callback])：设置请求超时时间 request.setNoDelay([noDelay])、request.setSocketKeepAlive ([enable], [initialDelay])\nhttp.ClientResponse 事件 data、end 和 close response.setEncoding([encoding])：设置默认的编码 response.pause()：暂停接收数据和发送事件 response.resume()：从暂停的状态中恢复\n","date":"2020-05-19T22:54:13+08:00","permalink":"https://mizarzh.github.io/p/2020/05/nodejs%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","title":"nodejs入门笔记"},{"content":"科学动画\n5-10 有两种类型的图片： 1、类似于js中canvas和python中matplotlib的位图 2、类似于svg或操作html DOM元素的矢量图\n使用js做动画 本来想使用canvas或anime.js做动画，但碍于一些原因（比如不能生成图片），甚至不如python直接画\n使用python做动画 本来想使用matplotlib.animation做动画，但是发现ffmpeg的配置有问题（即使将ffmpeg放到PATH或者使用pip和conda安装ffmpeg都不行）。于是就使用最原始的方法：生成图片再使用ffmpeg合成视频\nimport matplotlib.pyplot as plt import numpy as np import scipy as sci import math import random a = 100 b = 90 c = math.sqrt(abs(a**2 - b ** 2)) theta = [] x = [] y = [] color = [\u0026#39;red\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;green\u0026#39;] SMI_max = 2 * c #ellipse for i in np.linspace(0 , math.pi * 2, 300): x.append(a * math.cos(i)) y.append(b * math.sin(i)) line = np.linspace(-b,b,100) #for theta in np.linespace(0, math.pi * 2, 10000) #知道theta的情况 def calc(theta): SMI = (math.sqrt((a+c)**2 - (c * math.sin(theta))**2) - c * math.cos(theta) - \\ math.sqrt((a * math.cos(theta))**2 + (b * math.sin(theta))**2)) / (2 * c) return SMI plt.figure(figsize=[6,6],dpi = 300) count = 0 for theta in np.linspace(0, math.pi * 8, 300): ax = plt.gca() ax.set_aspect(1) plt.axis(\u0026#39;off\u0026#39;) plt.plot(x,y,c=\u0026#39;C1\u0026#39;,zorder=0) for i in range(0,99): plt.plot([120,120],[line[i],line[i+1]],c = color[i % 3],zorder=0) plt.scatter(-c,0,s = 100) plt.scatter(a * math.cos(theta),b * math.sin(theta),zorder = 1, c=\u0026#39;gray\u0026#39;,s=10) plt.scatter(120,calc(theta) * 2 * b - b,zorder = 1,c=\u0026#39;purple\u0026#39;,s=10) plt.savefig(\u0026#39;pictures2/\u0026#39; + str(count) + \u0026#39;.jpg\u0026#39;) plt.clf() count += 1 然后就在pictures2中生成了300张图片，再使用ffmpeg：\nffmpeg -i %d.jpg -r 25 output.mp4 -r指fps\n5-11 将右侧坐标变为渐变色： plot是不能直接使用渐变色的，因此这里使用scatter强行画出渐变色\n# 渐变颜色 cmap_i = np.linspace(-b, b, 100) plt.scatter([110]*100, cmap_i, zorder=0,c=cmap_i, cmap=plt.get_cmap(\u0026#39;cool\u0026#39;),marker=\u0026#39;s\u0026#39;,s=5) # 标注 plt.plot([109, 111], [-b, -b], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [b, b], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [0, 0], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [b/2, b/2], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [-b/2, -b/2], zorder=0, c=\u0026#39;black\u0026#39;) plt.text(112, -b - 2, \u0026#39;0%\u0026#39;, fontsize=8) plt.text(112, b - 2, \u0026#39;100%\u0026#39;, fontsize=8) plt.text(112, -2, \u0026#39;50%\u0026#39;, fontsize=8) plt.text(112, b/2 - 2, \u0026#39;75%\u0026#39;, fontsize=8) plt.text(112, -b/2 - 2, \u0026#39;25%\u0026#39;, fontsize=8) 去除图片周围空白：\nplt.savefig(\u0026#39;pictures3/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;, bbox_inches=\u0026#39;tight\u0026#39;) 每次打开生成图片使用clf()清理后，循环内使用的就是一个新的figure，其他图片设置中的设置就不会起作用。如果将plt.figure放到循环内，就会因为生成太多figure而出错 原代码：\nplt.figure(figsize=[6, 6], dpi=300) for theta in np.linspace(0, 8 * math.pi, 300): #其他图片设置 #作图 plt.clf() 使用plt.close()就可以真正的清理掉一个figure 修改后：\nfor theta in np.linspace(0, 8 * math.pi, 300): plt.figure(figsize=[6, 6], dpi=300) #其他图片设置 #作图 plt.close() 生成图片后，使用PIL放入月球和地球的图片。接下来就遇到了最难受的坐标转化问题。 一开始月球和点之间总是差一点点距离，后来强行乘了一个系数后便正常了\nmoon = Image.open(\u0026#39;moon.png\u0026#39;).resize([50, 50]) earth = Image.open(\u0026#39;earth.png\u0026#39;).resize([500, 500]) im = Image.open(\u0026#39;pictures3/0.png\u0026#39;) arg = 0.96 centerX = im.size[0] / 2 centerY = im.size[1] / 2 c_c = c / figlen / 2 * im.size[0] * arg imc = 0 for theta in np.linspace(0, 8 * math.pi, 300): im = Image.open(\u0026#39;pictures3/\u0026#39; + str(imc) + \u0026#39;.png\u0026#39;) c_x = a * math.cos(theta) / figlen / 2 * im.size[0] * arg c_y = b * math.sin(theta) / figlen / 2 * im.size[1] * arg layer = Image.new(\u0026#39;RGBA\u0026#39;, im.size, (0, 0, 0, 0)) layer.paste( earth, (int(centerX - c_c - earth.size[0] / 2), int(centerY - earth.size[1] / 2))) layer.paste(moon, (int(centerX + c_x - moon.size[0] / 2), int(centerY - c_y - moon.size[1] / 2))) out = Image.composite(layer, im, layer) out.save(\u0026#39;output/\u0026#39; + str(imc) + \u0026#39;.png\u0026#39;, \u0026#39;PNG\u0026#39;) imc += 1 最终效果： \r2.jpg\r\n（未完待续）\n","date":"2020-05-10T23:17:07+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-5-10/","title":"最近进展2020-5-10"},{"content":"这两天闲来无事，写了两个和展示文字相关的页面，其中遇到了读取文本与跨网页通信的问题。\n文件操作 js中直接读取和处理本地的文件是很困难的（除非nodejs），这种事情还是交给python比较好 但是可以手动上传文件从而达到读取的目的。使用HTML5的新功能。 首先使用\u0026lt;input type=\u0026ldquo;file\u0026rdquo;\u0026gt; 从而获得文件。\n选择文件后可以通过inputDOM.files获取文件的FileList，再通过数组访问则可以得到文件（但是不能直接显示内容）\ninputDOM = document.querySelector(input[type=file]) inputDOM.files // FileList file = inputDOM.files[0] file.name //文件名 file.size //文件大小 file.webkitRelativePath //路径 file.type //文件类型 使用FileReader来读取文件中的内容。\nvar fReader = new FileReader() fReader.readAsText(file) //读取文件 fReader.result //显示文本内容 FileReader有四种打开方式，我们这里只用到了readAsText。\n跨网页通信 跨域通信可以直接使用XHR，不在这里的讨论范围。 使用H5的新功能localStorage：\nlocalStorage.setItem(\u0026#39;name\u0026#39;,\u0026#39;value\u0026#39;) //设置本地储存值 localStorage.removeItem(\u0026#39;name\u0026#39;) //移除本地储存值 这样在两个不同的网页也可以读取相同的本地存储 另一种方法（H5之前）是使用Cookie。\n","date":"2020-04-24T23:23:20+08:00","permalink":"https://mizarzh.github.io/p/2020/04/js%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8E%E8%B7%A8%E7%BD%91%E9%A1%B5/","title":"js的读取文本与跨网页"},{"content":"wincmd脚本 ffmpeg ffmpeg -ss 00:00:00 -t 00:00:03.000 -i \u0026#34;x.wav\u0026#34; -filter_complex afade=t=out:st=1:d=2 \u0026#34;y.wav\u0026#34; -filter_complex afade=t=out:st=1:d=2 代表从1s开始淡出，持续2s\njs 文件读取 界面 机理 html \u0026lt;audio\u0026gt; 的使用\npython 月球项目 首先调用astropy的solar_system_ephemeris.set(\u0026lsquo;jpl\u0026rsquo;)，从jpl处下载数据 然后使用astropy.coordinates中的get_moon()和get_sun()函数获取日月的RA、DEC、distance 先找到满月的第一个点，然后取下一次时间时增加一个朔望月周期，并在其周围(-1.2,1.2,0.1)进行校正，矫正次数记录在err.txt，因此这种计算的误差为+-0.05d\nfrom astropy import units as u from astropy.time import Time import numpy as np from astropy.coordinates import solar_system_ephemeris from astropy.coordinates import get_moon, get_sun x = open(\u0026#39;datafull.txt\u0026#39;, \u0026#39;w\u0026#39;) y = open(\u0026#39;datanew.txt\u0026#39;, \u0026#39;w\u0026#39;) z = open(\u0026#39;err.txt\u0026#39;, \u0026#39;w\u0026#39;) jds = Time(\u0026#39;1900-01-15T19:12:00.000\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd jds2 = Time(\u0026#39;1900-01-01T14:24:00.000\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd jde = Time(\u0026#39;2100-01-01T00:00:00\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd # 2488069.5 circle = 29.53059 #一个朔望月周期 h = True #进度条相关 m = (jde + jds)/2 #进度条相关 def diff(ra1, ra2): dra = abs(ra1-ra2) if dra \u0026gt; 180: dra = 360 - dra return dra for i in np.arange(jds, jde, circle): largest = 0 #最大RA距离 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i \u0026gt; m and h): print(\u0026#39;half1\u0026#39;) h = False z.write(\u0026#39;--------------\\n\u0026#39;) for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format=\u0026#39;jd\u0026#39;, scale=\u0026#39;tdb\u0026#39;) #在朔望月周期附近微调 moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra \u0026gt; largest): #判断是否为最大 largest = dra #最大RA距离 dis = moon.distance.value #最大RA距离时距离 time = t #最大RA距离时时间 errcount += 1 z.write(str(errcount)) z.write(\u0026#39;\\n\u0026#39;) x.write(time.iso + \u0026#39; \u0026#39;) x.write(str(time.jd) + \u0026#39; \u0026#39;) x.write(str(dis)) x.write(\u0026#39;\\n\u0026#39;) print(\u0026#39;end1\u0026#39;) h = True m = (jde + jds2)/2 x.close() z.write(\u0026#39;++++++++++++++++++++++++++\\n\u0026#39;) for i in np.arange(jds2, jde, circle): smallest = 180 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i \u0026gt; m and h): print(\u0026#39;half2\u0026#39;) h = False z.write(\u0026#39;--------------\\n\u0026#39;) for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format=\u0026#39;jd\u0026#39;, scale=\u0026#39;tdb\u0026#39;) moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra \u0026lt; smallest): smallest = dra dis = moon.distance.value time = t errcount += 1 z.write(str(errcount)) z.write(\u0026#39;\\n\u0026#39;) y.write(time.iso + \u0026#39; \u0026#39;) y.write(str(time.jd) + \u0026#39; \u0026#39;) y.write(str(dis)) y.write(\u0026#39;\\n\u0026#39;) print(\u0026#39;end2\u0026#39;) y.close() z.close() 文件读取：\nx = open(\u0026#39;xxx\u0026#39;,\u0026#39;r\u0026#39;) #有很多选项 x.read() x.readlines() csv:\nwith open(\u0026#39;xxx.csv\u0026#39;,\u0026#39;r\u0026#39;) as f freader = csv.reader(f) for row in freader: #... fdreader = csv.DictReader(f) #读字典 with open(\u0026#39;xxx.csv\u0026#39;,\u0026#39;w\u0026#39;,newline=\u0026#39;\u0026#39;) as f #newline = \u0026#39;\u0026#39;是为了防止每次写完之后都换行 fwriter = csv.writer(f) fwriter.writerow([xx,xx,xx]) fdwriter = csv.DictWriter(f) #写字典 json:\nimport json json.dumps(某个数据结构) #将某个数据结构转化为json j = json.loads(某json) #将json转化为python内置数据结构 从香港天文台获取数据，使用爬虫：\nfrom urllib.request import urlopen from urllib.request import Request import time #for i in range(0,100): maping = {} file = open(\u0026#39;s2l.txt\u0026#39;,\u0026#39;a\u0026#39;) url = \u0026#39;https://www.hko.gov.hk/tc/gts/time/calendar/text/files/\u0026#39; headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39; } for i in range(0,200): fileName = \u0026#39;T\u0026#39; + str(1901 + i) +\u0026#39;c.txt\u0026#39; req = Request(url = url + fileName,headers = headers) x = urlopen(req) fulltext = x.read().decode(\u0026#39;Big5\u0026#39;) fulllist = fulltext.split(\u0026#39;\\n\u0026#39;)[3:-1] for j in range(0,len(fulllist)): file.write(fulllist[j] + \u0026#39;\\n\u0026#39;) print(i) time.sleep(1) file.close() 后续将尝试转化农历和公历\n","date":"2020-04-09T11:50:15+08:00","permalink":"https://mizarzh.github.io/p/2020/04/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-9/","title":"最近进展2020-4-9"},{"content":"1、写了一个网页 前端练习 website\n2、配置服务器 Jupyter notebook\n3、学习爬虫 4、事件相关 某同学的一个网页，写一个js脚本，重复点击四（五）个按钮。\n首先找出每个按钮（button）的定位，这里使用document.querySelector()定位\nvar x = document.querySelector(str[0]); var button = [\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#34;.ut-button-group:first-child\u0026#34;,\u0026#34;ut-navigation-button-control\u0026#34;]; 接下来调试，发现无法使用x.click()点击按钮。使用浏览器查看事件发现使用了mousedown和mouseup确定点击事件 修改代码：\nfunction handler(str){ var x = document.querySelector(str); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } var button = [\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#34;.ut-button-group:first-child\u0026#34;,\u0026#34;ut-navigation-button-control\u0026#34;]; 再令其每隔一段时间点击一次按钮，则：\nwhile(true){ for(let i = 0;i \u0026lt; button.length;++i){ setTimeout(handler(button[i]),1000); } } 发现setTimeout好像并不是很符合要求（似乎是因为setTimeout并不会真的等待一段时间才执行下一个循环，而是生成四个setTimeout进程）。于是改用了setInterval，并增加了一些东西：\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var i = button.length - 1; var count = 0; var id; function handler(){ loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 500){ clearInterval(id) } } id = setInterval(handler,5000); （所有代码，以后可能会增加try catch块）\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var input = document.querySelector(\u0026#39;.numericInput\u0026#39;); var i = button.length - 1; var count = 0; var id; function doer(ci = i){ var x = document.querySelector(button[ci]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function handler(){ try{ loop_i(); doer(); } catch(e){ if(e instanceof TypeError){ console.error(\u0026#34;TypeError\u0026#34;); i = 0; doer(4); } else{ console.error(\u0026#34;UnknownError\u0026#34;); i = 0; doer(4); } } } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 20){ input.value = 0; } } id = setInterval(handler,5000); clearInterval(id) 加入try catch块\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var i = button.length - 1; var clear = document.querySelector(\u0026#39;.flat.camel-case\u0026#39;); var count = 0; var id; function handler(){ loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 5){ var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); clear.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); clear.dispatchEvent(up); count = 0; } } id = setInterval(handler,5000); 另一种解法\n","date":"2020-04-02T23:39:38+08:00","permalink":"https://mizarzh.github.io/p/2020/04/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-2/","title":"最近进展2020-4-2"},{"content":"远端jupyter notebook的配置 python下载 这里使用anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh ./Anaconda3-2020.02-Linux-x86_64.sh 并一直yes，安装anaconda\njupyter notebook配置 conda jupyter notebook #anaconda安装jupyter notebook jupyter notebook --generate-config #生成配置文件 配置文件为.jupyter/jupyter_notebook_config.py\n打开IPython，产生密码：\nIn [1]: from notebook.auth import passwd In [2]: passwd() 接下来就会让你输入密码，输入密码后就会生成一个\u0026rsquo;sha1:xxx\u0026rsquo;的东西，复制它。\nvim .jupyter/jupyter_notebook_config.py 修改以下选项（可以使用vim \u0026lsquo;/\u0026lsquo;的搜索功能）：\nc.NotebookApp.ip=\u0026#39;*\u0026#39; #可以由所有ip访问jupyter notebook c.NotebookApp.password = \u0026#39;sha:xx\u0026#39; #刚刚复制的东西 c.NotebookApp.open_browser = False #启动不打开浏览器 c.NotebookApp.port =8888 #使用的端口 启动：\njupyter notebook 或者后台一直启动：\nnohup jupyter notebook\u0026amp; 使用插件 conda install -c conda-forge jupyter_contrib_nbextensions jupyter contrib nbextension install --user 然后在header处就能见到多一个nbextensions选项卡，进入里面选择所需的插件即可\n","date":"2020-03-25T17:01:13+08:00","permalink":"https://mizarzh.github.io/p/2020/03/jupyter-notebook%E9%85%8D%E7%BD%AE/","title":"jupyter notebook配置"},{"content":"一个文学渣的瞎唠嗑\n《雪国》[日]川端康成 创作于1935-1948年\n自己的想法： 这的确是一本非常晦涩难懂的书。驹子对岛村的感情表达地十分晦涩（当然在岛村每次到雪国时感情都会深入，但书中没有明说），而岛村对她的感想则是全书的核心：“徒劳”。岛村认为驹子的生活是徒劳的，也能在书中读出来驹子平日生活（忍不住打扫）、待人（为了行男和养家而做艺妓）的辛苦。结尾最后很短的篇幅爆发，虽然结尾很难读懂就是了……\n参考资料后： 岛村追求的是一种虚幻的美丽（虚无主义）。他热衷于写舞蹈的文章，却不去追求真正的舞蹈；他对叶子映在车窗上的倒影入迷，却对驹子注重现实生活而感到徒劳。他觉得现实生活中的一切东西都是“徒劳”的，去做也没有什么用。 叶子暗喻了驹子的精神。叶子对驹子的责怪就是驹子对自己的责怪；叶子对驹子的嫉妒就是驹子对自己的嫉妒；叶子对岛村的爱慕就是驹子对岛村的爱慕。而最后叶子在火灾中死去，驹子失去了精神，便是结尾处的“疯掉了”。 展现了作者的一些看法：死的唯美意境，虚无与悲观。\n 《雷雨》曹禺 1934年7月发表，背景在1925年前后 受某人推荐，同时因为在教科书中有出现过所以感觉挺有意思的，就决定开始看了。\n自己的想法： 如果不考虑什么文学性和时代背景的话，剧情可以说算是很狗血了233。当然评判这一部冲突性极强的戏剧单纯考虑男欢女爱的情节是不合适的。文章主要围绕着当时贫苦人民和资本家之间的矛盾与冲突，非常生动的展示了当时的社会大环境——资本家毫无同情心的剥削普通民众，普通人民苦不堪言；男权（不知道作者有没有这方面的想法了）主导，女性成为附庸。 在这个背景下，许多人的关系交织。鲁家有没文化的鲁贵频频向资本家低头不肯斗争，有涉世未深的四凤还未看出资本家的邪恶，也有鲁侍萍、鲁大海坚决与资本家势不两立（但是反抗程度有所不同）；周家有象征着当时资本家的周朴园，有在周朴园压迫下的蘩漪，有儒弱的周萍，也有作为地主和资本家的儿子但却关心鲁家的周冲。路人也有在吃到甜头后就不再反抗的工人。人物代表了当时各种态度的人，性格丰富，冲突也十分激烈，着实精彩（就是情节是有点狗血233）。 虽然我并不是很认同将这部作品强加在工人阶级觉醒之类的上面（不然鲁大海的下场也不会是这样了，但显然语文课本就是这么做的），但是可以确定这部作品绝对是有对于资本家和大地主对普通人民各种手段的剥削和压制的严厉的批判的。\n参考资料后（直接抄百度）： 《雷雨》所展示的是一幕人生大悲剧，是不平等的社会里，命运对人残忍的捉弄。周朴园的专制、冷酷和伪善；周冲的热情和单纯；以及蘩漪对爱情的深挚乃至略显变态的执着；痛悔着罪孽却又不自知地犯下更大罪孽的软弱的周萍；被侮辱的被捉弄的悲苦的鲁妈……还有家庭的秘密，身世的秘密，所有这一切在一个雷雨夜爆发。最后，有错的、有罪的，无错的、无辜的人，竟然一起走向了毁灭。它讲述了资产阶级周家和城市平民鲁家两个家庭纠结复杂的悲剧故事。一是以周朴园为代表的带有浓厚封建色彩的资产阶级家庭的生活悲剧：二是以鲁妈为代表的城市平民不能把握自己命运、被别人所操控的悲惨境遇。而周、鲁两家复杂的血缘联系，更是突出、生动地反映了两个不同阶层的家庭之间的矛盾。揭露了旧中国旧家庭的种种黑暗现象以及地主资产阶级的专横、冷酷与伪善，反映了中国20世纪二、三十年代正在酝酿着一场大变动的社会现实，对受压迫者给予了深切的同情。\n","date":"2020-03-16T23:12:57+08:00","permalink":"https://mizarzh.github.io/p/2020/03/%E5%90%8D%E8%91%97%E7%9F%AD%E8%AF%84/","title":"名著短评"},{"content":"思路： 模型： $$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$\n其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离\n轨道计算：先计算出椭圆轨道的参数，再映射到实际轨道当中\n数据 Orbital elements: C/2019 Y4 (ATLAS) Epoch 2020 May 31.0 TT = JDT 2459000.5 T 2020 May 30.99149 TT Bell q 0.2522871 (2000.0) P Q z +0.0052736 Peri. 177.54315 +0.48067371 +0.62763038 +/-0.0005749 Node 120.47328 -0.81617007 +0.57558163 e 0.9986695 Incl. 45.27974 -0.32065433 -0.52420025 From 171 observations 2019 Dec. 28-2020 Jan. 9, mean residual 0\u0026quot;.4.\ne (eccentricity) : 0.9991890 q (perihelion distance) : 0.2529910 i (inclination) : 45.39050 Ω (Longitude of ascending node) : 120.57800 ω (Argument of perihelion) : 177.39850 L (Longitude of perihelion) : 118.75041 B (Latitude of perihelion) : 1.85172 T (Time of perihelion passage) : 2459000.54440 P (Orbital period in years) : 5509.68 Epoch : 2020 Feb 27 Family/Group: : Nearly isotropic\n02 January 2020 00:00 UTC\n轨道根数： – semimajor axis a, – eccentricity e, – inclination i (or ι), – longitude of the ascending node Ω, – argument of the perihelion ω, – time of the perihelion τ. (或者true anomaly或者mean anomaly)\n作图 三维图： mplot3d\nfrom mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import numpy as np ax1 = plt.axes(projection=\u0026#34;3d\u0026#34;) ax1.set_xlim3d(-lim,lim) ax1.set_ylim3d(-lim,lim) ax1.set_zlim3d(-lim,lim) ax1.plot3D(x,y,z) plt.show() 在jupyter notebook上：\n%matplotlib notebook ax1.mouse_init() #使用鼠标操控 ax1.view_init(elev=number, azim=number) #调整视角 交互式plotly\n天文相关 poliastro 问题：使用Orbit.from_classical时的ecc过大，导致数据精度不足（或者是使得运行时间过长），但是使用直接绘图就没有这个问题 poliastro\nastropy\nfrom astropy import units as u from astropy.coordinates import CartesianRepresentation u.deg u.one u.km u.AU #单位 CartesianRepresentation.x.value #带单位转化为值 astropy\n目前状况（2020-03-16） 爆肝到两点emm 之前某个时间也强行写了很久\n结构：轨道运算、画图、Mk计算 轨道运算：poliastro库 导入轨道后再导出数据 使用近日点的true anomaly和mean anomaly都为0的方法规避这个库只能输入true anomaly的缺点（使用t代替，然后再使用propagation()确定相应的时间）\ntime2 = \u0026#34;2020-05-31T00:51:39\u0026#34; t2 = Time(time2, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;) se = Orbit.from_body_ephem(Earth,t2) sc = Orbit.from_classical(Sun,a,ecc,inc,raan,argp,0 * u.deg,t2) setemp = Orbit.from_classical(Sun,se.a,se.ecc,se.inc,se.raan,se.argp,se.nu,t2) #鬼知道我遇到了什么，必须再导入时间才能正常 orbnc = [[],[],[]] #comet[[xs],[ys],[zs]] orbne = [[],[],[]] #earth for x in np.linspace(-60 * u.day,60 * u.day,120): #-60 - 60 天 orbnctemp = sc.propagate(x) #x为astropy.unit的时间，用来计算经过某段时间后的轨道 pn1 = orbnctemp.represent_as(CartesianRepresentation) #表示为xyz轴 orbnc[0].append(pn1.x.value) orbnc[1].append(-pn1.y.value) orbnc[2].append(-pn1.z.value) xc = pn1.x.value / (1.5 * 10**8) #转化为AU yc = pn1.y.value / (1.5 * 10**8) zc = pn1.z.value / (1.5 * 10**8) orbnetemp = setemp.propagate(x) pn2 = orbnetemp.represent_as(CartesianRepresentation) orbne[0].append(pn2.x.value) orbne[1].append(-pn2.y.value) orbne[2].append(-pn2.z.value) xe = pn2.x.value / (1.5 * 10**8) ye = pn2.y.value / (1.5 * 10**8) ze = pn2.z.value / (1.5 * 10**8) r.append(math.sqrt(xc**2+yc**2+zc**2)) d.append(math.sqrt((xe-xc)**2+(ye-yc)**2+(ze-zc)**2)) #计算 m = M + 5lgd + klgr 的参数r,d 最小二乘：\n#此处lgr lgd m已输入数据 A = np.vstack([lgr, np.ones(len(lgr))]).T np.linalg.lstsq(A,m - 5 * lgd,rcond=None) #输出[[斜率，截距],[方差],xx,xx] plt.scatter(lgr,m - 5 * lgd) #观察离散程度 M = 3.94 k = 25 y1 = [] y2 = [] for x in np.linspace(0,119,120): x = int(x) #此处使用 m - 5lgd = klgr + M 进行最小二乘拟合 y1.append(M + 5 * math.log10(d[x]) + k * math.log10(r[x])) y2.append(12 + 5 * math.log10(d[x]) + 10 * math.log10(r[x])) x = np.linspace(-60,61,120) plt.figure(figsize = [6,4],dpi=150) #设置图的大小 plt.xlabel(\u0026#39;days from perihelion\u0026#39;) plt.ylabel(\u0026#39;magnitude\u0026#39;) plt.title(\u0026#39;picutre\u0026#39;) plt.plot(x,y1,color=\u0026#34;blue\u0026#34;) plt.plot(x,y2,color=\u0026#34;red\u0026#34;) plt.ylim(max([max(y1),max(y2)])+1,min([min(y1),min(y2)])-1) #奇妙的做法，为了翻转y轴，想使用plt.gca().invert_yaxis()但不起作用，于是使用ylim反转上下限 plt.savefig(\u0026#34;figure.jpg\u0026#34;) #保存图片 plt.show() 目前状况（2020-03-17） 解决plt绘图重复的问题（前面分开，后面合并，连着直接绘制会出现问题）（可能是和figure()相关的问题） plt.grid() plt.legend()的配置 plt.subplot linewidth matplotlib的documentation:matplotlib\n重构了代码，更多地使用数组储存数据\n双曲线a为负数 Time(2439054.6837, format=\u0026lsquo;jd\u0026rsquo;,scale=\u0026lsquo;tdb\u0026rsquo;) #JD时间\npoliastro.twobody.propagation.propagate相关： 可以由orbit.propagate()调用，其中第一个参数为经过的时间，第二个参数为求解的方法（mean_motion,kepler,cowell），返回经过时间后的轨道\n下一步：研究python的封装（函数、库、class之类） 下一步：自写轨道库\nmatplotlib颜色映射（默认颜色） np.arange([start,],stop,[step])\n目前状况（2020-03-19） plt.xticks([array]) x轴的刻度标记（如[1,2,3,4,5]，则刻度显示出来的就是12345） xticks系列大概都是用来设置轴的刻度标记的吧 plt.xtickslabel([array]) 使用string设置x轴刻度\nplt.axis([xlim,-xlim,ylim,-ylim]) 相当于设置plt.xlim和plt.ylim\n","date":"2020-02-28T17:57:43+08:00","permalink":"https://mizarzh.github.io/p/2020/02/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97c-2019-y4-comet/","title":"工作日志(C 2019 Y4 comet)"},{"content":"推箱子 pushbox 过于羞耻.jpg\n\rprinciple\r\nHTML与CSS知识相关 这次使用的是外层创建div并限定长度、窗口居中（margin : auto），内部嵌套float:left的元素 应该有更高效的（absolute+计算坐标），但还没搞清楚盒式模型\njs文件过程 js的调用并不是一次性的，可以使用函数重复调用（文件只可以进行一次，但是函数可以进行多次）\n事件监听 事件的监听是并行的，前面定义了click，后面定义了keydown，并不会停留在监听的函数中。 （另外的问题：每个对象的监听是否只能有一个）\n全局变量 在window定义变量，再用window.xxx调用全局变量\n数组嵌套对象 concat(),slice(0)对一维数组有效 数组中如果嵌套了对象，那么concat()、slice(0))也会对数组中的东西产生影响，换句话说就是没有进行深复制。 这里应该深入对作用链的理解\n混乱不堪的代码  运动系统过于复杂 或许可以换种架构，不需要每次移动都更新全部的DOM 全局变量和局部变量纠缠不清   贪吃蛇 Greedy-Snake-js\n随机数 使用Math.random()生成[0-1)的一个数，配合Math.floor()食用更佳\n数组判断相等 数组的判断无法直接使用===号 如果是较简单的数组可以使用Array.toString()方法比较。 嵌套且长短不一的数组可能就需要单独比较了\n深复制 假设一个对象/数组a需要深复制，可使用JSON进行转化\ncopy = JSON.parse(JSON.stringify(a)); 方法 对于数组与对象的方法不熟悉（例如迭代等）\n全局变量 这次使用了对象包裹的方法定义全局变量，应该是稍微科学一点了 也使用了ES6的let及const，更好的控制变量范围\nthrow throw错误之后程序将停止运行\n","date":"2020-02-19T12:42:14+08:00","permalink":"https://mizarzh.github.io/p/2020/02/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-2-19/","title":"最近进展2020-2-19"},{"content":"13事件 js与HTML之间的交互是通过事件实现的 可以使用侦听器（或处理程序）来预订事件\n13.1事件流 13.1.1事件冒泡 即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）\n13.1.2事件捕获 事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。\n13.1.3DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n13.2事件处理程序 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以\u0026quot;on\u0026quot;开头\n13.2.1HTML事件处理程序 属性onclick=\u0026ldquo;javascript代码\u0026rdquo;\n//前面定义了showMessage() \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;ClickMe\u0026#34; onclick=\u0026#34;showMessage()\u0026#34;/\u0026gt; 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。 这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象 在这个函数内部，this值等于事件的目标元素 在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。\n很多HTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面\n13.2.2DOM0级事件处理程序 每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。\nvarbtn=document.getElementById(\u0026#34;myBtn\u0026#34;); btn.onclick=function(){ alert(\u0026#34;Clicked\u0026#34;); }; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行 也可以删除通过DOM0级方法指定的事件处理程序，将onclick属性设为null即可。\n13.2.3DOM2级事件处理程序 addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法。 它们都接受3个参数：要处理的事件名（意味着没有on前缀）、作为事件处理程序的函数和一个布尔值。这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。\n大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。\n13.2.4IE事件处理程序 过时了吧emm\n13.2.5跨浏览器的事件处理程序 IE、DOM2、DOM0三种方法创建，创建为一个EventUtil的对象。\n13.3事件对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。\n13.3.1DOM中的事件对象 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。\nevent属性：见书355页 其中两个属性： currentTarget：其事件处理程序当前正在处理事件的那个元素 target：事件的目标 this始终等于currentTarget的值 要阻止特定事件的默认行为，可以使用preventDefault()方法。 只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为 stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则event-Phase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。 只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。\n13.3.2IE中的事件对象 过时了吧\n13.3.3跨浏览器的事件对象 13.4事件类型  UI（UserInterface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为IME（InputMethodEditor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层DOM结构发生变化时触发。  13.4.1UI事件 详细见书362 DOMActivate,(un)load,abort,error,select,resize,scroll 除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件\n13.4.2焦点事件 blur,focus,focusin,focusout\n13.4.3鼠标与滚轮事件 click,dblclick,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup\n鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。 通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，坐标是从页面本身而非视口的左边和顶边计算的。 在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。 screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。\nDOM规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。\n对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。 但对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠标按钮（鼠标滚轮按钮），2表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。\n“DOM2级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。\n当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件。 与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。 Firefox支持一个名为 DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。与 mousewheel 事件一样，DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在 detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是-3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是 3 的倍数\n触摸设备：\n 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生； 如果屏幕没有因此变化，那么会依次发生 mousedown、mouseup 和 click 事件。 轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。 mousemove 事件也会触发 mouseover 和 mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。  13.4.4 键盘与文本事件 keydown,keypress,keyup 前两者如果按住不放的话，会重复触发此事件。 只有一个文本事件：textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。\n在发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同。 表见P380\nIE9、Firefox、Chrome 和 Safari的 event 对象都支持一个 charCode 属性，这个属性只有在发生 keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的 ASCII 编码。此时的 keyCode 通常等于0或者也可能等于所按键的键码\nDOM3级变化：不再包含 charCode 属性，而是包含两个新属性：key 和 char。 key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时，key 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift” 或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。 不同浏览器有不同实现\nDOM3级事件还添加了一个名为 location 的属性，这是一个数值，表示按下了什么位置上的键： 0表示默认键盘，1表示左侧位置（例如左位的 Alt键），2表示右侧位置（例如右侧的 Shift键），3表示 数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂 Wii控制器）。\n后是给 event 对象添加了 getModifierState()方法。这个方法接收一个参数，即等于 Shift、Control、AltGraph 或 Meta 的字符串，表示要检测的修改键。\n“DOM3级事件”规范中引入了一个新事件，名叫 textInput。根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。 由于 textInput 事件主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符（而非字符编码）。 event 对象上还有一个属性，叫 inputMethod，表示把文本输入到文本框中的方式。 （值见P383）\n13.4.5 复合事件 复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。 compositionstart,compositionupdate,compositionend\n13.4.6 变动事件 DOM2级的变动（mutation）事件能在 DOM中的某一部分发生变化时给出提示。 DOMSubtreeModified,DOMNodeInserted,DOMNodeRemoved,DOMNodeInsertedIntoDocument,DOMNodeRemovedFromDocument,DOMAttrModified,DOMCharacterDataModified\n13.4.7 HTML5事件  contextmenu 事件：上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单 beforeunload 事件：是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件的意图是将离开页面的控制权交给用户。 DOMContentLoaded 事件：在形成完整的 DOM树之后就会触发，不理会图像、JavaScript 文件、CSS文件或其他资源是否已经下载完毕。 readystatechange 事件：这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。 pageshow 和 pagehide 事件：这个事件在页面显示时触发，无论该页面是否来自 bfcache（来自bfcache的页面不会有load事件）。 hashchange 事件：在 URL的参数列表（及 URL中“#”号后面的所有字符串）发生变化时通知开发人员。  13.4.8 设备事件  orientationchange 事件 MozOrientation 事件 deviceorientation 事件 devicemotion 事件  13.4.9 触摸与手势事件  触摸事件 手势事件  13.5 内存和性能 在 JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。\n13.5.1 事件委托 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。\nvar list = document.getElementById(\u0026#34;myLinks\u0026#34;); EventUtil.addHandler(list, \u0026#34;click\u0026#34;, function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id){ case \u0026#34;doSomething\u0026#34;: document.title = \u0026#34;I changed the document\u0026#39;s title\u0026#34;; break; case \u0026#34;goSomewhere\u0026#34;: location.href = \u0026#34;http://www.wrox.com\u0026#34;; break; case \u0026#34;sayHi\u0026#34;: alert(\u0026#34;hi\u0026#34;); break; } }); //而不是三个对象分别设置不同的方法 这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。 适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress\n13.5.2 移除事件处理程序 内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的主要原因。 直接移除元素（removeChild()) 好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。\n13.6 模拟事件 13.6.1 DOM中的事件模拟 document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。 在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3级中都变成了单数。\n UIEvents：一般化的 UI事件。鼠标事件和键盘事件都继承自 UI事件。DOM3级中是 UIEvent。 MouseEvents：一般化的鼠标事件。DOM3级中是 MouseEvent。 MutationEvents：一般化的 DOM变动事件。DOM3级中是 MutationEvent。 HTMLEvents：一般化的 HTML事件。没有对应的 DOM3级事件（HTML事件被分散到其他类别中）。  传入参数见书\n","date":"2020-02-12T18:28:18+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B013/","title":"js高设笔记13"},{"content":"10 DOM DOM（文档对象模型）是针对 HTML和 XML文档的一个 API\n10.1 节点层次 DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。 \u0026lt;html\u0026gt; 文档元素 文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。 在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。\n每一段标记都可以通过树中的一个节点来表示： HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。\n10.1.1 Node类型 DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现，JavaScript中的所有节点类型都继承自 Node 类型。 每个节点都有一个 nodeType 属性，用于表明节点的类型。 节点类型由在 Node 类型中定义的下列12个数值常量来表示 Node.ELEMENT_NODE(1)； Node.ATTRIBUTE_NODE(2)； Node.TEXT_NODE(3)； Node.CDATA_SECTION_NODE(4)； Node.ENTITY_REFERENCE_NODE(5)； Node.ENTITY_NODE(6)； Node.PROCESSING_INSTRUCTION_NODE(7)； Node.COMMENT_NODE(8)； Node.DOCUMENT_NODE(9)； Node.DOCUMENT_TYPE_NODE(10)； Node.DOCUMENT_FRAGMENT_NODE(11)； Node.NOTATION_NODE(12)。\nnodeName 和 nodeValue：对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。\n每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。 NodeList 是一种类数组对象（类似但不是Array），用于保存一组有序的节点，可以通过位置来访问这些节点。 访问NodeList可通过方括号，也可以使用 item()方法 转化为数组（或者手动循环）：\nvar arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。 包含在 childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中后一个节点的 nextSibling 属性的值同样也为 null。 父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和后一个节点。\nhasChildNodes()方法\n所有节点都有的后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。\nappendChild()，用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点及以前的后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild() 返回新增的节点。\ninsertBefore() 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作\nreplaceChild() 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。\nremoveChild() 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。\n并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。\ncloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制（复制节点及其整个子节点树，浅复制只复制节点本身）。副本没有指定父节点。\nnormalize()，这个方法唯一的作用就是处理文档树中的文本节点。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。\n10.1.2 Document类型 JavaScript通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。\n nodeType 的值为 9； nodeName 的值为\u0026quot;#document\u0026quot;； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null；其子节点可能是一个 DocumentType（多一个）、Element（多一个）、ProcessingInstruction 或 Comment。  documentElement 属性，该属性始终指向HTML页面中的元素。 document 对象还有一个 body 属性，直接指向元素。 Document 另一个可能的子节点是 DocumentType。通常将\u0026lt;!DOCTYPE\u0026gt;标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息。 不同浏览器支持情况不同 出现在元素外部的注释的引用不同浏览器的支持程度不同。\ndocument.title：通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变\u0026lt;title\u0026gt;元素 URL、domain 和 referrer。只有 domain 是可以设置的。但由于安全方面的限制，也并非可以给 domain 设置任何值。\ngetElementById()和getElementsByTagName()。 前者id不存在返回null，id特性（attribute）严格匹配，包括大小写。 后者返回的是包含零或多个元素的 NodeList。在 HTML文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。 HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name 特性取得集合中的项。（方括号访问亦可） 后者可传入*，代表全部\n虽然标准规定标签名需要区分大小写，但为了最大限度地与既有 HTML 页面兼容，传给 getElementsByTagName()的标签名是不需要区分大小写的。但对于 XML 页面而言（包括 XHTML），getElementsByTagName()方法就会区分大小写。\n只有 HTMLDocument 类型才有的方法，是 getElementsByName()。顾名思义，这个方法会返回带有给定 name 特性的所有元素。\n特殊集合：anchors(\u0026lt;a name=\u0026ldquo;xxx\u0026rdquo;\u0026gt;),forms(\u0026lt;form\u0026gt;),images(\u0026lt;img\u0026gt;),links(\u0026lt;a href=\u0026ldquo;xxx\u0026rdquo;\u0026gt;)\ndocument.implementation 属性为浏览器实现了DOM的哪些部分提供相应信息和功能的对象，其中的方法hasFeature()接受两个参数：要检测的 DOM功能的名称及版本号。若支持返回true。\nwrite()、writeln()、open()和 close()\ndocument.write(\u0026#34;\u0026lt;strong\u0026gt;\u0026#34; + (new Date()).toString() + \u0026#34;\u0026lt;/strong\u0026gt;\u0026#34;); //载入外部脚本 document.write(\u0026#34;\u0026lt;script type=\\\u0026#34;text/javascript\\\u0026#34; src=\\\u0026#34;file.js\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;\\/script\u0026gt;\u0026#34;); 如果在文档加载结束后再调用 document.write()，那么输出的内容将会重写整个页面\n10.1.3 Element类型  nodeType 的值为 1； nodeName 的值为元素的标签名； nodeValue 的值为 null； parentNode 可能是 Document 或 Element； 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。  要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性 在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。\nHTML元素\n id，元素在文档中的唯一标识符。 title，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang，元素内容的语言代码，很少使用。 dir，语言的方向，值为\u0026quot;ltr\u0026quot;（left-to-right，从左至右）或\u0026quot;rtl\u0026quot;（right-to-left，从右至左），也很少使用。 className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为 class 是 ECMAScript的保留字  所有 HTML元素都是由 HTMLElement 或者其更具体的子类型来表示的。 **getAttribute()、setAttribute()和 removeAttribute()**三个方法。 最前者的返回可能会有差异 1 返回的 style 特性值中包含的是 CSS文本，直接访问则是对象， 2 事件处理程序。当在元素上使用时，onclick 特性中包含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。 通常不使用getAttribute()\nsetAttribute() 通过这个方法设置的特性名会被统一转换为小写形式，即\u0026quot;ID\u0026quot;终会变成\u0026quot;id\u0026quot;\n根据 HTML5规范，自定义特性应该加上 data-前缀以便验证。\nElement 的attributes 属性中包含一个 NamedNodeMap，与 NodeList 类似，也是一个“动态”的集合。元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象拥有下列方法。\n getNamedItem(name)：返回 nodeName 属性等于 name 的节点； removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos)：返回位于数字 pos 位置处的节点。  attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称。节点的 nodeValue 就是特性的值。 removeNamedItem()返回表示被删除特性的 Attr 节点，removeAttribute()不返回 attributes属性一般用于遍历元素属性 返回属性的顺序不一定相同\n每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML中指定了相应特性，要么是通过 setAttribute()方法设置了该特性。\ndocument.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。返回一个 DOM元素的引用\n\u0026lt;ul id=\u0026#34;myList\u0026#34;\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt;  \u0026lt;/ul\u0026gt;  返回后会有7个元素，包括3个li元素和4个空白符（li之间） 可以通过nodeType的判断消除空白符\n10.1.4 Text类型  nodeType 的值为 3； nodeName 的值为\u0026quot;#text\u0026quot;； nodeValue 的值为节点所包含的文本； parentNode 是一个 Element； 不支持（没有）子节点。  操作文本的方法：\n appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 文本节点还有一个 length 属性，保存着节点中字符的数目。 每个可以包含内容的元素多只能有一个文本节点，而且必须确实有内容存在。  document.createTextNode()创建新文本节点\nnormalize() 浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行 DOM操作的结果出现。 splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。\n10.1.5 Comment类型  nodeType 的值为 8； nodeName 的值为\u0026quot;#comment\u0026quot;； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element； 不支持（没有）子节点。  其他有CDATASection类型，DocumentType类型 ，DocumentFragment类型 ，Attr类型\nDOM操作技术 （待续）\n","date":"2020-02-11T16:11:37+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B010/","title":"js高设笔记10"},{"content":"BOM BOM（浏览器对象模型）\n8.1 window 对象 BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。\n8.1.1 全局作用域 全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。\nvar age = 29; window.color = \u0026#34;red\u0026#34;; //在 IE \u0026lt; 9 时抛出错误，在其他所有浏览器中都返回 false delete window.age; //在 IE \u0026lt; 9 时抛出错误，在其他所有浏览器中都返回 true delete window.color; //returns true 使用 var 语句添加的 window 属性的[[Configurable]]特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除 通过查询 window 对象，可以知道某个可能未声明的变量是否存在。\n8.1.2 窗口关系及框架 页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。\nwindow.frames[0] window.frames[\u0026#34;name属性\u0026#34;] top.frames[0] top对象始终指向高（外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。 与 top 相对的另一个 window 对象是 parent。顾名思义，parent（父）对象始终指向当前框架的直接上层框架。\n除非高层窗口是通过 window.open()打开的（本章后面将会讨论），否则其 window 对象的 name 属性不会包含任何值。 self始终指向 window；实际上，self 和 window 对象可以互 换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来 这些对象都为window的属性，可通过window.xxx访问\n   对象名 指向     top 始终指向高（外）层的框架   parent 始终指向当前框架的直接上层框架   self 始终指向 window    在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生 类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。\n8.1.3 窗口位置 screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。 screenX 和 screenY 各浏览器间实现不同\n使用moveTo() 和 moveBy() 方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，moveTo()接收的是新位置的 x和 y坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数。 另外，这两个方法都不适用于框架，只能对外层的 window 对象使用。\n8.1.4 窗口大小 innerWidth、innerHeight、outerWidth 和 outerHeight outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从外层的 window 对象还是从某个框架访问） innerWidth 和innerHeight 则表示该容器中页面视图区的大小（减去边框宽度）。 不同浏览器代表不同。\ndocument.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息\n对于移动设备，window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。\n**resizeTo()和 resizeBy()**方法可以调整浏览器窗口的大小\n8.1.5 导航和打开窗口 window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。 \ropen参数\r 表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（如top=100，注意，整个特性字符串中不允许出现空格） 调用 close()方法还可以关闭新打开的窗口。 弹出窗口关闭之后，窗口的引用仍然还在，但仅能用类似alert的方法检测closed参数了\n新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。 虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口\n将 opener 属性设置为 null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。\n浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open()的调用封装在一个try-catch 块中\n8.1.6 间歇调用和超时调用 JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。 前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。 超时调用需要使用 window 对象的 **setTimeout()**方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。 第一个参数可以是一个包含 JavaScript代码的字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。（一般用匿名函数） 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个 参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 **clearTimeout()**方法并将相应的超时调用 ID作为参数传递给它。\n间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 setInterval() 取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。\nvar num = 0; var max = 10; //使用递归方法 function incrementNumber() { num++; //如果执行次数未达到 max 设定的值，则设置另一次超时调用  if (num \u0026lt; max) { setTimeout(incrementNumber, 500); } else { alert(\u0026#34;Done\u0026#34;); } } setTimeout(incrementNumber, 500); 一般认为，使用超时调用来模拟间歇调用的是一种佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，好不要使用间歇调用。\n8.1.7 系统对话框 alert()、confirm()和 prompt() 为了确定用户是单击了 OK还是 Cancel，可以检查 confirm()方法返回的布尔值：true 表示单击了 OK，false 表示单击了 Cancel或单击了右上角的 X按钮。\nprompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK和 Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。 prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。如果用户单击了OK按钮，则 prompt()返回文本输入域的值；如果用户单击了 Cancel或没有单击 OK而是通过其他方式关闭了对话框，则该方法返回 null。\nfind() 查找 和 print() 打印 方法\n8.2 location对象 location它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。是window对象的属性，也是document的属性。 属性 \rlocation属性\r\n8.2.1 查询字符串参数 location.search 返回从问号到 URL末尾的所有内容 可以新建函数获取?后面的参数\ndecodeURIComponent()解码URL\n8.2.2 位置操作 location 对象可以通过很多方式来改变浏览器的位置。使用assign()方法 改变window.location或者location.href会调用assgin()方法 每次修改 location 的属性（hash 除外），页面都会以新 URL重新加载。 要禁用生成记录行为，应使用replace()方法，不能回到前一个页面 reload()，作用是重新加载当前显示的页面。传入参数true，则强制从服务器重新加载数据，而不传入则可能从缓存中加载。\n8.3 navigator 对象 navigator对象 属性见书P200-201\n8.3.1 检测插件 plugins属性\n name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME类型数量。 因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。 plugins 集合有一个名叫 refresh()的方法，用于刷新 plugins 以反映最新安装的插件。  8.3.2 注册处理程序 registerContentHandler()和registerProtocolHandler() 这两个方法可以让一个站点指明它可以处理特定类型的信息。 前者接收参数：要处理的 MIME类型、可以处理该 MIME 类型的页面的 URL以及应用程序的名称。 后者接收参数：要处理的协议（例如，mailto 或 ftp）、处理该协议的页面的 URL和应用程序的名称。\nnavigator.registerContentHandler(\u0026#34;application/rss+xml\u0026#34;, \u0026#34;http://www.somereader.com?feed=%s\u0026#34;,\u0026#34;Some Reader\u0026#34;); //%s代表RSS源URL 8.4 screen 对象 用处不大 用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 书中P214\n8.5 history 对象 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置近。如果历史记录中不包含该字符串，那么这个方法什么也不做 还可以使用两个简写方法 back()和 forward()来代替 go()。 history 对象有一个 length 属性，保存着历史记录的数量。\n","date":"2020-02-10T13:24:43+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B08/","title":"js高设笔记8"},{"content":"7 函数表达式 7.1 递归 使用argument.callee 严格模式下，可使用命名函数表达式来达成相同的结果\nvar factorial = (function f(num){ if (num \u0026lt;= 1){ return 1; } else { return num * f(num-1); } }); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。\n7.2 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。\nfunction createComparisonFunction(propertyName) { return function(object1, object2){ var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 \u0026lt; value2){ return -1; } else if (value1 \u0026gt; value2){ return 1; } else { return 0; } }; } 在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。\n","date":"2020-02-10T12:17:39+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B07/","title":"js高设笔记7"},{"content":"6 面向对象的程序设计 （注意：js中的面向对象实现与C++中不同）\n6.1 理解对象 var person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; person.job = \u0026#34;Software Engineer\u0026#34;; person.sayName = function(){ alert(this.name); }; var person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, job: \u0026#34;Software Engineer\u0026#34;, sayName: function(){ alert(this.name); } }; 6.1.1 属性类型 数据属性 ECMA-262第 5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。 实现 JavaScript引擎用的，因此在 JavaScript中不能直接访问它们。 为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。\n [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。  要修改属性默认的特性，必须使用 ECMAScript 5的Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。\nvar person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { writable: false, value: \u0026#34;Nicholas\u0026#34; }); 这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。\n把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。\n访问器属性 访问器属性不包含数据值；它们包含一对 getter和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter函数并传入新值，这个函数负责决定如何处理数据。\n [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。  var book = { _year: 2004, edition: 1 }; Object.defineProperty(book, \u0026#34;year\u0026#34;, { get: function(){ return this._year; }, set: function(newValue){ if (newValue \u0026gt; 2004) { this._year = newValue; this.edition += newValue - 2004; } } }); book.year = 2005; alert(book.edition); //2 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。 只指定 getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。\n6.1.2 多个属性 var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue \u0026gt; 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); 6.1.3 读取属性的特性 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述 符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。\nvar descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;_year\u0026#34;); alert(descriptor.value); //2004 alert(descriptor.configurable); //false alert(typeof descriptor.get); //\u0026#34;undefined\u0026#34;  var descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;year\u0026#34;); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\u0026#34;function\u0026#34; 6.2 创建对象 6.2.1 工厂模式 function createPerson(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var person1 = createPerson(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); var person2 = createPerson(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); 6.2.2 构造函数模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ alert(this.name); }; } var person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); var person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); 构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 使用了函数就是对象的想法，将属性添加到this上。\n两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。\n若Person不使用new，则认为是在为window添加属性 可使用call将作用域限定为某个对象\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。不同实例上的同名函数是不相等的。\n6.2.3 原型模式 解决构造函数的方法不相等问题。 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。\nfunction Person(){} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function(){ alert(this.name); }; 在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。\n原型对象的理解：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。\n\rprototype1\r Person 的每个实例—— person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与构造函数没有直接的关系。 所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。 ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。\n每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。\n使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。\nin操作符 单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。\n\u0026#34;name\u0026#34; in person1; ECMAScript 5也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。 要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5的 Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。\n更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象:\nfunction Person(){ } Person.prototype = { name : \u0026#34;Nicholas\u0026#34;, age : 29, job: \u0026#34;Software Engineer\u0026#34;, sayName : function () { alert(this.name); } }; 有一个例外：constructor 属性不再指向 Person 了，指向Object 如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可用defineproperty重设回来。\nconstructor : Person, 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。 如果是重写整个原型对象，实例中的指针仅指向原来的原型，而不指向构造函数。 调用构造函数时会为实例添加一个指向初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与初原型之间的联系。 总结：先定义原型再创建实例，不然实例指向的是原prototype \rprototype2\r\n问题 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 共享，有时候需要分离的属性 因此不经常单独使用\n6.2.4 组合使用构造函数模式和原型模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\u0026#34;Shelby\u0026#34;, \u0026#34;Court\u0026#34;]; } Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } } 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，大限度地节省了内存。\n是目前在 ECMAScript中使用广泛、认同度高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。\n6.2.5 动态原型模式(理解？) 它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。\nfunction Person(name, age, job){ //属性  this.name = name; this.age = age; this.job = job; //方法  if (typeof this.sayName != \u0026#34;function\u0026#34;){ Person.prototype.sayName = function(){ alert(this.name); }; } } 6.2.6 寄生构造函数模式 寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。\nfunction Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } 除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。\n首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。 我们建议在可以使用其他模式的情况下，不要使用这种模式。\n6.2.7 稳妥构造函数模式 稳妥对象（durable objects）。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。\nfunction Person(name, age, job){ //创建要返回的对象  var o = new Object(); //可以在这里定义私有变量和函数  //添加方法  o.sayName = function(){ alert(name); }; //返回对象  return o; } 除了使用 sayName()方法之外，没有其他办法访问 name 的值。\n6.3 继承 继承分为接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript使用实现继承。 通过原型链实现\n6.3.1 原型链 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\nfunction SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function (){ return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); //true \rprototype_chain\r\ninstance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，后一步才会找到该方法。\n最上层的原型链继承自Object，因此也可以使用Object的方法。\n使用instanceof/isPrototypeof()对原型链上的对象进行比较都会返回true\n子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。\n即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链\n问题 1 SubType 的所有实例都会共享属性。 2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n6.3.2 借用构造函数 在子类型构造函数的内部调用超类型构造函数。通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数\nfunction SuperType(){ this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } function SubType(){ //继承了 SuperType  SuperType.call(this); } 两者没有关系 如果SuperType可以传递参数，则使用call()方法也可传递参数 问题：方法都在构造函数中定义，无法复用函数。\n6.3.3 组合继承 组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。\n过程：先定义supertype的属性，再定义subtype的私有属性，再定义原型链。 js中最常用的继承模式\n6.3.4 原型式继承 function object(o){ function F(){} F.prototype = o; return new F(); } 进行浅复制，复制后仍指向原来的对象（共享属性）\nECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。\n6.3.5 寄生式继承 function createAnother(original){ var clone = object(original); //通过调用函数创建一个新对象  clone.sayHi = function(){ //以某种方式来增强这个对象  alert(\u0026#34;hi\u0026#34;); }; return clone; //返回这个对象 } 6.3.6 寄生组合式继承 组合继承大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。\n寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。| 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。\nfunction inheritPrototype(subType, superType){ var prototype = object(superType.prototype); //创建对象  prototype.constructor = subType; //增强对象  subType.prototype = prototype; //指定对象 } 在定义完supertype和subtype之后调用此函数，则完成了继承。\n总结 [[xxx]]当作是属性的属性，则可理解defineProperty和defineProperties的写法，以及getOwnPropertyDescripter指向的东西 模式： [[Prototype]]实例所有，指向该实例的构造函数的原型对象 prototype为构造函数所有，指向该构造函数的原型对象 constructor实例所有，指向构造函数\n 工厂模式 createPerson() + return 构造函数模式 Person() + new 原型模式 Person()的对象名prototype含有的属性Person.prototype.xxx 上面两个组合 动态原型 寄生构造函数、稳妥构造函数  继承：\n 原型链。subType的prototype指向superType的实例，则逻辑：subType为superType的一个实例 -\u0026gt; subType拥有[[Prototype]]属性，且指向构造函数superType的原型对象superType.prototype -\u0026gt; 原型链构造完成，可以寻找到superType.prototype的属性 借用构造函数：在subType内使用call()或apply()构建superType属性的深复制。 上面两者组合 原型式继承 寄生式继承 寄生组合式继承  ","date":"2020-02-07T18:14:42+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/","title":"js高设笔记6"},{"content":"5 引用类型 引用类型是一种结构。\n5.1 Object类型 创造实例的两种方法： 1、new+构造函数 2、对象字面量\nvar person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; var person = { name : \u0026#34;Nicholas\u0026#34;, age : 29 }; var person = {}; //相当于new Object() 属性名可以使用字符串（包括字符串数字）。 使用对象字面量定义对象不会调用Object()构造函数\n访问方法：person[\u0026ldquo;name\u0026rdquo;]或person.name 除非必须通过方括号法表示，否则用点表示法\n5.2 Array 每一项可保存不同的数据类型\n//构造函数法 var colors = new Array(); var colors = new Array(20);// len=20 var colors = new Array(\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;); //字面量法 var colors = []; var colors = [\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;]; length属性 设定length，短了切除，长了用undefined填充。在超远的距离填充（如colors[99] = \u0026ldquo;xx\u0026rdquo;，那么2-98都为undefined。 套路：\ncolors[colors.length] = \u0026#34;xx\u0026#34;;//在最后一项添加 5.2.1 检测数组 instanceof（假定只有一个全局环境） **Array.isArray()**方法（不管有多少个环境）\n5.2.2 转换方法 toLocaleString(),toString(),valueOf() 调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf()返回的还是数组。\nvar person = { toLocaleString : function{ ... } toStirng : function{ ... } };//这样改变方法 **join()**方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串（不传入值或undefined就用逗号）。\n5.2.3 栈方法 LIFO:push() pop() push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 而pop()方法则从数组末尾移除后一项，减少数组的 length 值，然后返回移除的项。\n5.2.4 队列方法 FIFO:shift()和push():能够移除数组中的第一个项并返回该项，同时将数组长度减 1 unshift():在数组前端添加任意个项并返回新数组的长度。\n5.2.5 重排序方法 reverse() sort() 方法按升序排列数组项。 sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。 传入比较function判断排序。 如：\nfunction compare(value1, value2) { if (value1 \u0026lt; value2) { return -1; } else if (value1 \u0026gt; value2) { return 1; } else { return 0; } } values.sort(compare); 5.2.6 操作方法 concat() 方法可以基于当前数组中的所有项创建一个新数组。 这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，后返回新构建的数组。\nslice() 能够基于当前数组中的一或多个项创建一个新数组。 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。注意，slice()方法不会影响原始数组。 （可为负数）\nsplice()  删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。  插入：可以向指定位置插入任意数量的项，只需提供 3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。  替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）\n总结：splice(start,length,insert_values\u0026hellip;)\n5.2.7 位置方法 indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。 比较使用===\n5.2.8 迭代方法  every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。  filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。  forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。  map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。  some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。\n5.2.9 归并方法 reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个终返回的值。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。\n5.3 Date类型 var d = new Date();//括号中填入毫秒数 表示自 UTC（Coordinated Universal Time，国际协调时间）1970年 1月 1日午夜（零时）开始经过的毫秒数来保存日期。 parse():不固定具体格式，转化为该日期的毫秒数 UTC()：按照年、月、日、时、分、秒、毫秒顺序填入。其中月和时从0开始，转化为该日期的毫秒数。 toString()/toLocaleString()：转化为日期表示。 （目测toLocaleString()会考虑到时区的问题） now()：返回现在时间的毫秒数\n如同模仿 Date.parse()一样，Date 构造函数也会模仿 Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。\nDate 构造函数接收的参数仍然与 Date.UTC()相同。\nvalueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。 格式方法与组件方法见书P101-102\n5.4 RegExp类型 见另外的文档 RegExp\n5.5 Function类型 函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\nfunction sum (num1, num2) { return num1 + num2; } var sum = function(sum1, sum2){ return num1 + num2; }; var sum = new Function(\u0026#34;sum1\u0026#34;,\u0026#34;sum2\u0026#34;,\u0026#34;return num1 + num2\u0026#34;)//不推荐 不推荐的那种会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。\n5.5.1 没有重载 函数名为指针，如果定义了另外一个函数则会指向另外一个函数。\n5.5.2 函数声明与函数表达式 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。\n5.5.3 作为值的函数 因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。 函数的return可返回一个函数\n5.5.4 函数内部属性 arguments和this。 arguments的callee属性：该属性是一个指针，指向拥有这个 arguments 对象的函数。 如：\nfunction factorial(num){ if (num \u0026lt;=1) { return 1; } else { return num * arguments.callee(num-1) //不是factorial，消除了与这个名字的耦合  } } var trueFactorial = factorial; //可正常调用，factorial则不行 this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window）\nECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。\nECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。\n5.5.5 函数属性和方法 每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数\n在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。\napply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。\ncall() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。\n它们真正强大的地方是能够扩充函数 赖以运行的作用域。\nwindow.color = \u0026#34;red\u0026#34;; var o = { color: \u0026#34;blue\u0026#34; }; function sayColor(){ alert(this.color); } sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值。\n(待续)\n","date":"2020-02-07T18:13:27+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B05/","title":"js高设笔记5"},{"content":"正则表达式的表示方法 来自：regexlab\n1、直接写内容 直接匹配内容\n2、转义字符 1    字符 含义     \\n \\r 换行符   \\t 制表符   \\\\ \\的字符   \\$ $的字符   \\^ ^的字符   \\. .的字符    2    字符 含义     \\d 任意数字   \\w 任意数字、字母及下划线_   \\s 空白或制表符或换页符   . 任意字符（除换行符）    3、方括号 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。 如：[abc] (a,b,c中任意一个)、[^ f-k] (不是f-k的任意一个字母)、[A-F0-9] (A-F和0-9中任意一个)\n4、数量匹配 {n}重复n次 {m,n}重复至少m次至多n次 {m,}至少重复m次 ? 相当于 {0,1} + 相当于 {1,} * 相当于 {0,}\n5、位置匹配？ ^ 与字符串开始的地方匹配，不匹配任何字符（若匹配到的字符不是开始则错误） $ 与字符串结束的地方匹配，不匹配任何字符 \\b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符\n6、其他 | 左右两边表达式之间 \u0026ldquo;或\u0026rdquo; 关系，匹配左边或者右边 ( ) (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到\n7、高级技巧 贪婪与非贪婪 默认是贪婪（匹配得越多越好） 在数量符号后面加上?（如w+?）则为非贪婪模式，匹配越少越好\n引用 \\1、\\2等符号获取在( )中匹配的字符\n预搜索，不匹配；反向预搜索，不匹配 (?=xxxx)\n8、其他 \\xXX \\uXXXX 表示字符（编码相关？） \\S \\D \\W \\B 代表相反意义（非数字等）\n注意事项  表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。 需注意贪婪与非贪婪模式 或 \u0026ldquo;|\u0026rdquo; 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 \u0026ldquo;|\u0026rdquo; 两边的表达式因为交换位置而有所不同。  js里面的正则表达式形式： var exp = / pattern / flags;//字面量类型 var exp2 = new RegExp(\u0026#34;[bc]at\u0026#34;, \u0026#34;i\u0026#34;); //构造函数 模式（pattern）为表达式。 flags: g表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写 m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 传入构造函数的字符串需双重转义 如匹配\\：\n   字符串 字面量 匹配     \\\\\\\\|\\\\|\\     （嗯其实这里打的markdown已经是四重转义了）      实例的属性  global：布尔值，表示是否设置了 g 标志。 ignoreCase：布尔值，表示是否设置了 i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。 multiline：布尔值，表示是否设置了 m 标志。 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。  实例的方法 exec()：接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。\n返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。\n在数组中，第一项是与整个模式匹配 的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。\n对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，常与for函数一起使用用于找出所有匹配项。\ntest():它接受一个字符串参数。在模式与该参数匹配的情况下返回 true；否则，返回 false。\ntoLocaleString()和toString() 方法都会返回正则表达式的字面量。 valueOf()方法返回正则表达式本身。\nRegExp构造函数属性 原理（NFA） ","date":"2020-02-05T00:57:40+08:00","permalink":"https://mizarzh.github.io/p/2020/02/regexp%E7%9B%B8%E5%85%B3/","title":"Regexp相关"},{"content":"JSON组成 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。\n例子： \u0026ldquo;Hello world!\u0026rdquo; 简单值 {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;Nicholas\u0026rdquo;,\u0026ldquo;age\u0026rdquo;: 29} 对象 [25, \u0026ldquo;hi\u0026rdquo;, true] 数组\njs中解析与序列化 var book = { //JSON表达式 } var jsontext = JSON.stringify(book); var bookC = JSON.parse(book); JSON 对象的两个方法：stringify()和 parse() 将 JSON字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript对象（或数组、值）。\n过滤结果 stringify(book,[year,edition]); JSON.stringify(book, function(key, value){ switch(key){ //判定是哪个属性，不要就返回undifined  } } 第三个参数用于控制结果中的缩进和空白符 如果是一个数值，则为缩进数 如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON字符串中被用作缩进字符\n如果某些对象无法使用JSON对象转化，可以自己定义该对象的toJSON()方法\n序列化顺序： (1) 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。 (2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。 (3) 对第(2)步返回的每个值进行相应的序列化。 (4) 如果提供了第三个参数，执行相应的格式化。\nJSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。这个函数被称为还原函数（reviver）\n","date":"2020-02-05T00:56:57+08:00","permalink":"https://mizarzh.github.io/p/2020/02/json%E7%9B%B8%E5%85%B3/","title":"JSON相关"},{"content":"第四章 4.1  基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。\n 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。 引用类型值（Object？）\njs不允许直接访问内存\n4.1.1 属性 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。 不能给基本类型值添加属性。\n4.1.2 复制 基本类型值\u0026quot;=\u0026ldquo;将进行值的复制，两个值之间不相关 而引用类型值的\u0026rdquo;=\u0026ldquo;将指向同一个对象\n4.1.3 传递参数  ECMAScript 中所有函数的参数都是按值传递的。 把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 可以把 ECMAScript函数的参数想象成局部变量。\n my comprehension:不管什么值进入函数都会复制一遍，并在函数内部赋值到一个临时变量上。 基本类型值基本没问题，但引用类型值的引用也被复制了，当在内部改变临时变量的属性时，随着引用外部的对象也会随着改变。\n4.1.4 检测类型 typeof方法和instanceof方法\n4.2 执行环境及作用域  执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局变量与每个函数的执行环境 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。\n 4.2.1 延长作用域链 try-catch语句的catch块： with语句：不解释\n4.2.2 没有块级作用域  变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完add()之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。\n  当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。\n 4.3 垃圾收集 自动垃圾手机机制\n4.3.1 标记清除 变量进入环境时，将变量标记为“进入环境”。离开时标记为“离开环境”。\n4.3.2 引用清除 用得不多。跟踪记录每个值使用的次数。 问题：循环引用。 需手动切断链接。（设置引用为null）\n4.3.3 性能问题 注意性能相关问题。\n4.3.4 管理内存 不需要时手动解除引用。\n","date":"2020-02-05T00:35:24+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E7%AB%A0/","title":"js高级设计笔记（第四章）"},{"content":" NexT文档   https://theme-next.org/docs/ http://theme-next.iissnan.com/ 网上搜索很方便（hexo文档和blog很多）\n mc相关：   中文论坛 https://www.mcbbs.net/ mod https://www.mcmod.cn/class/category/1-1.html cusreforge https://curseforge.com HMCL https://hmcl.huangyuhui.net gamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wiki gamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki\n   ","date":"2020-01-30T13:20:56+08:00","permalink":"https://mizarzh.github.io/p/2020/01/%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/","title":"有用的网址"},{"content":"1.mc版本 mc（pc端）分为java版与基岩版（C++编写） java版可自行下载，基岩版必须购买\njava版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接）\n以下讨论只针对java版\n2.配置方法 启动游戏需配置三样东西：java环境，游戏本体，启动器\n 游戏运行于java环境，因此首先需下载JDK（java development kit）并安装 目前许多启动器可以直接下载游戏本体，因此不需要再专门下载游戏本体。游戏本体位于.minecraft文件夹内 启动器用于启动游戏，常见的有HMCL等  3、mod相关 安装mod需要下载forge（然鹅官网好像访问很慢） 安装后会出现mods文件夹，直接将mod的jar包拖入其中即可\n4、自建服务器 以ubuntu为例 首先需下载server.jar mc_server ubuntu需要使用wget获得服务器 再安装jdk：\nsudo apt install openjdk-11-jre-headless 安装完成后再在bash输入：\nsudo java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui 就可生成文件 使用文本编辑器在生成的eula.txt文件中修改为true，在server.properties文件中修改online-mode=false 制作启动脚本：\n#!/bin/sh  java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui; ","date":"2020-01-30T11:50:14+08:00","permalink":"https://mizarzh.github.io/p/2020/01/mc%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/","title":"mc相关配置解释"},{"content":"hexo相关 1. vscode使用markdown相关 preview：右上角点击preview即可 可装插件Markdown Preview Enhanced使得preview更好看\n2、hexo标签问题 设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法：\nhexo n page tags #或categories等 然后在source/tags目录中配置index.md\n--- title: 标签 date: type: \u0026#34;tags\u0026#34; //或者\u0026#34;categories\u0026#34; --- 然后hexo g即可\n3、hexo目录乱序 需要按顺序一级一级使用# 如##后应该跟###而不是####\n4、hexo插入图片 摸索出来的新方法：\n 手动在_post文件夹建立与md相同名字的文件夹（不含.md)，往里面放入图片 直接使用![](xxx/文件名)  后面这种网上常见方法在我这里不适用/会出bug 例如我使用了之后就会使得地址处多了一个/.io/，无法连接到正确图片上\n _config.yml里面的post_asset_folder设为true 安装插件  cnpm install hexo-asset-image --save 安装完成后后hexo n \u0026ldquo;xxx\u0026quot;就会生成xxx.md的同时生成一个同名文件夹，图片放在里面即可。 调用图片的命令为![](xxx/文件名)  5、hexo启用公式 使用kramed渲染\ncnpm install hexo-renderer-kramed --save 在_config.yml中将mathjax enable，并在每篇文章的head中添加mathjax: true 有时候遇到pandoc exited with code null的问题，可以直接将pandoc整个卸载：\nnpm remove hexo-renderer-pandoc --save git相关 1、git速度过慢 需设置hosts文件，隔一段时间需重新设置\n浏览器配置 使用firefox\n标签设置 about:config 收藏栏打开使用新标签 browser.tabs.loadBookmarksInTabs设为true 新标签在当前标签右侧打开 browser.tabs.insertAfterCurrent设为true\n拓展安装 tabliss： 主要看重其中的TODO（懒= =） Simple Tab Groups：\nTab Center Redux:\n使用的拓展 Dark Reader:\nIDM:\nuBlock Origin:\nVideo DownloadHelper:\nTo Google Translate:\n打开被禁用端口 config:about network.security.ports.banned.override添加字符串 xxxx,xxxx,xxxx格式\nssh传文件 本地-\u0026gt;远程\nscp local_file remote_username@remote_ip:remote_folder 远程-\u0026gt;本地\nscp remote_username@remote_ip:remote_folder local_folder ffmpeg 叠加图片 ./ffmpeg -r 一秒帧数 -start_number 起始数字 -i img_%04d.jpg（4位整数） output.mp4 剪片 -ss 00:00:00.000 开始时间 -t 00:00:10.000 持续时间 -to 00:00:10.000 结束时间\n旋转 顺时针旋转画面90度ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=1\u0026rdquo; out.mp4 逆时针旋转画面90度ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=2\u0026rdquo; out.mp4 顺时针旋转画面90度再水平翻转ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=3\u0026rdquo; out.mp4 逆时针旋转画面90度水平翻转ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=0\u0026rdquo; out.mp4 水平翻转视频画面ffmpeg -i test.mp4 -vf hflip out.mp4 垂直翻转视频画面ffmpeg -i test.mp4 -vf vflip out.mp4\n","date":"2020-01-28T11:38:56+08:00","permalink":"https://mizarzh.github.io/p/2020/01/%E6%9D%82%E9%A1%B9%E9%97%AE%E9%A2%98/","title":"杂项问题"},{"content":"0、准备：  node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： git config --global user.name \u0026#34;Firstname Lastname\u0026#34; git config --global user.email \u0026#34;your-email@youremail.com\u0026#34;  github新建repository的地址需命名为your-github-name.github.io  1、使用cnpm npm命令在国内较慢，需要安装cnpm(淘宝镜像)\nnpm install -g cnpm --registry=https://registry.npm.taobao.org 2、安装hexo cnpm install -g hexo-cli 3、新建文件夹 新建一个文件夹，里面将存储blog所需文件\nmkdir my_blog cd my_blog 4、初始化hexo hexo init 5、安装hexo部署至github的工具 cnpm install --save hexo-deployer-git （若出现ERROR Deployer not found: git错误，则是这个工具未安装）\n6、其他配置 其中文件_config.yml是配置文件 部署到github上需要配置deploy部分\ntype: \u0026#39;git\u0026#39; 添加两行：\nrepo: _path-to-github-blog_ branch: master 可在theme中更换主题\n本地临时服务器： hexo s s 代表 start 默认地址为localhost:4000\n新建文档： hexo n \u0026#34;name\u0026#34; n 代表 new 文档存放在/source/_post/中\n生成文档： hexo g g 代表 generate 部署文档到github上：\nhexo d d 代表 deploy 第一次配置可能需要输入github的账号密码 若是git bash内提示账号相关的错误，返回第零步进行账号的配置\n","date":"2020-01-27T22:46:41+08:00","permalink":"https://mizarzh.github.io/p/2020/01/hexo-win10%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8github%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/","title":"hexo win10配置方法，并使用github作为博客地址"}]