[{"content":"1、概述、构造函数 Date 对象基于 Unix Time Stamp，即从 1970 年 1 月 1 日（UTC）起经过的毫秒数。\n构造函数：\nnew Date(); // 返回实例化时刻的日期和时间。 new Date(value); // value 是 Unix 时间戳。 new Date(dateString); // 表示日期的字符串值。 new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]); // 具体日期的表示。 // year: 0到99会被映射至1900年至1999年，其它值代表实际年份。 // monthIndex: 从 0（1月）至 11（12月） // date: 从 1 开始 类似于这个构造函数，后面对于各种参数的构造也是 month 从 0 开始到 11 对应 1 月到 12 月。\n2、毫秒数 Date.now() 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数。\nDate.parse() 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。\n注意：由于浏览器差异和不一致，强烈建议不要使用Date.parse解析字符串。\nDate.UTC() 返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。\n语法：\nDate.UTC(year,month[,date[,hrs[,min[,sec[,ms]]]]]) 和 new Date() 中时间初始化的各格式相同。\nDate#valueOf() / Date#getTime() 返回从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。\nvalueOf 方法通常在 JavaScript 内部被调用，而不是在代码中显式调用。因此在外部尽量使用 getTime。\nDate#setTime() 从1970-1-1 00:00:00 UTC计时的毫秒数为来为 Date 对象设置时间。\n3、获取时间 一堆 get\n不带 UTC 的获取的就是本地时间：\nDate#getFullYear() Date#getMonth() // 同理，这里也是 0-11 Date#getDate() Date#getDay() // 要和 getDate 分清。这个 getDay 返回一个具体日期中一周的第几天，0 表示星期天。 Date#getHours() Date#getMinutes() Date#getSeconds() Date#getMilliseconds() 相对应的，带 UTC 的获取的就是世界时：\nDate#getUTCFullYear() Date#getUTCMonth() // 同理，这里也是 0-11 Date#getUTCDate() Date#getUTCDay() // 这个 getUTCDay 也是同理。 Date#getUTCHours() Date#getUTCMinutes() Date#getUTCSeconds() Date#getUTCMilliseconds() 4、设置时间 也有带 UTC 和不带 UTC 两种版本。\n不带 UTC 的设置的就是本地时间：\nDate#setFullYear(yearValue[, monthValue[, dayValue]]) Date#setMonth(monthValue[, dayValue]) Date#setDate(dayValue) Date#setHours(hoursValue[, minutesValue[, secondsValue[, msValue]]]) Date#setMinutes(minutesValue[, secondsValue[, msValue]]) Date#setSeconds(secondsValue[, msValue]) Date#setMilliseconds(msValue) 我们可以发现，在高等级的设置中也可以顺便设置后面的一些时间参数，调用的也是下一级的 set 函数（如 setFullYear 指定了 monthValue 就会调用 setMonth）\n带 UTC 的版本：\nDate#setUTCFullYear(yearValue[, monthValue[, dayValue]]) Date#setUTCMonth(monthValue[, dayValue]) Date#setUTCDate(dayValue) Date#setUTCHours(hoursValue[, minutesValue[, secondsValue[, msValue]]]) Date#setUTCMinutes(minutesValue[, secondsValue[, msValue]]) Date#setUTCSeconds(secondsValue[, msValue]) Date#setUTCMilliseconds(msValue) 5、输出 基本格式：to[Locale][Date/Time/UTC/ISO]String\nDate#toString() 总是返回一个美式英语日期格式的字符串。\nDate#toTimeString() 以美式英语和人类易读形式返回一个日期对象时间部分的字符串，该字符串以美式英语格式化。\nDate#toDateString() 以美式英语和人类易读的形式返回一个日期对象日期部分的字符串。\nDate#toLocaleString([locales [, options]]) 方法返回该日期对象的字符串，该字符串格式因不同语言而不同。新增的参数 locales 和 options 使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。\n带 Locale 的都会配上 locales 和 options 选项。\ndateObj.toLocaleString([locales [, options]]) locales 和 options 最后部分会解释。\nDate#toLocaleDateString([locales [, options]]) 返回该日期对象日期部分的字符串\nDate#toLocaleTimeString([locales [, options]]) 返回该日期对象时间部分的字符串，该字符串格式因不同语言而不同。\n语法：\ndateObj.toLocaleTimeString([locales [, options]]) Date#toUTCString() 把一个日期转换为一个字符串，使用UTC时区。返回值的格式可能随平台而变化。通常返回值是一个 RFC-1123 格式的时间戳，这是一个 RFC-822 时间戳的小幅更新版。\nDate#toISOString() 总是返回一个 ISO 格式的字符：YYYY-MM-DDTHH:mm:ss.sssZ。时区总是UTC（协调世界时），加一个后缀“Z”标识。\nDate#toJSON() 返回 Date 对象的字符串形式。\nDate#toSource() 返回表示源代码的字符串。\n注意：该特性是非标准的，请尽量不要在生产环境中使用它\n6、其他 Date#getTimezoneOffset() 返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。\n注意：如果本地时区后于协调世界时，则该差值为正值，如果先于协调世界时则为负值。如中国是 UTC+8，那么得到的数是 -480，除 60 后即为 -8。\nIntl.Locale 对象是为了更便捷地处理 Unicode 区域设置。Unicode 使用字符串作为区域识别标识。区域标识符由语言标识符和扩展标记组成。\n传入的参数为 locales 和 options。\nlocales：是一个 BCP 47 语言标记的字符串，或者是一个包括多个语言标记的数组。如果不提供，则使用默认运行时的 locale。\n最常见的格式：语言代码，脚本代码，和国家代码，全部由连字符分隔开。\n如：\n  \u0026quot;hi\u0026quot;：印地语 (primary language)。\n  \u0026quot;de-AT\u0026quot;：在奥地利使用的德语 (primary language with country code)。\n  \u0026quot;zh-Hans-CN\u0026quot;：在中国使用的简体中文 (primary language with script and country codes)。\n  还有很多其他的格式，这里就不列出来了。\noptions：是一个对象，其属性值在不同的构造函数和方法中会有所变化。‘\n对于这里使用的日期，Intl.Locale 的 DateTimeFormat 实例描述了这两个参数的值：\nlocales：language[-scripts][-region]-u-nu-* 和 language[-scripts][-region]-u-ca-*\nnu:编号系统. 可能的值包括: \u0026quot;arab\u0026quot;, \u0026quot;arabext\u0026quot;, \u0026quot;bali\u0026quot;, \u0026quot;beng\u0026quot;, \u0026quot;deva\u0026quot;, \u0026quot;fullwide\u0026quot;, \u0026quot;gujr\u0026quot;, \u0026quot;guru\u0026quot;, \u0026quot;hanidec\u0026quot;, \u0026quot;khmr\u0026quot;, \u0026quot;knda\u0026quot;, \u0026quot;laoo\u0026quot;, \u0026quot;latn\u0026quot;, \u0026quot;limb\u0026quot;, \u0026quot;mlym\u0026quot;, \u0026quot;mong\u0026quot;, \u0026quot;mymr\u0026quot;, \u0026quot;orya\u0026quot;, \u0026quot;tamldec\u0026quot;, \u0026quot;telu\u0026quot;, \u0026quot;thai\u0026quot;, \u0026quot;tibt\u0026quot;.\nca:日历. 可能的值包括: \u0026quot;buddhist\u0026quot;, \u0026quot;chinese\u0026quot;, \u0026quot;coptic\u0026quot;, \u0026quot;ethioaa\u0026quot;, \u0026quot;ethiopic\u0026quot;, \u0026quot;gregory\u0026quot;, \u0026quot;hebrew\u0026quot;, \u0026quot;indian\u0026quot;, \u0026quot;islamic\u0026quot;, \u0026quot;islamicc\u0026quot;, \u0026quot;iso8601\u0026quot;, \u0026quot;japanese\u0026quot;, \u0026quot;persian\u0026quot;, \u0026quot;roc\u0026quot;.\noptions :\nlocaleMatcher\n使用的local的匹配算法. 可能的值有\u0026quot;lookup\u0026quot;和\u0026quot;best fit\u0026quot;; 默认值是 \u0026quot;best fit\u0026quot;.\ntimeZone\n使用的时区. 这唯一的值实现必须被标准世界时间(UTC)所识别。默认值是运行时的默认时区. IANA time zone database 中的时区名称可能会被识别, 例如\u0026quot;Asia/Shanghai\u0026quot;, \u0026quot;Asia/Kolkata\u0026quot;, \u0026quot;America/New_York\u0026quot;.\nhour12\n是否使用12小时时间制(而不是24小时的时间). 可能的值是true 或 false; 默认值是根据locale来自动决定的\nformatMatcher format的匹配算法.可能的值有\u0026quot;basic\u0026quot;和\u0026quot;best fit\u0026quot;;默认值是\u0026quot;best fit\u0026quot;.\n日期时间插件被格式化输出时可以使用的属性集合描述。实现需要支持是以下子集中的其中一个\n weekday, year, month, day, hour, minute, second weekday, year, month, day year, month, day year, month month, day hour, minute, second hour, minute  关于这部分的内容详见 MDN/Intl 。\n","date":"2022-01-20T21:25:09+08:00","permalink":"https://mizarzh.github.io/p/2022/01/date%E6%96%B9%E6%B3%95/","title":"Date方法"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\n9 电子的自旋 对原子光谱进行更详尽的研究，我们会发现一些现象无法用我们过去的知识解释。因此我们需要补充相对论修正以及未考虑的磁效应。\n在相对论量子力学中式使用 Dirac 方程来描述电子的，它说明了电子自旋的存在。\n这一张使用的是 Pauli 理论，比相对论量子力学要简单得多。\nA 电子自旋的引入 1. 实验证据 a. 谱线的精细结构 每一条谱线实际上都包含频率非常靠近的若干组分。\nb. “反常”塞曼效应 当一个原子处在均匀磁场中时，它的每一条谱线都被分裂为若干条等距离的谱线，间隔正比于磁场，这就是塞曼效应。\n一个电子的轨道角动量 $\\bl L$ 对应一个磁矩：\n$$ \\bl M=\\frac{\\mu_B}{\\hbar}\\bl L $$\n其中 $\\mu_B=\\frac{q\\hbar}{2m_e}$ 称为玻尔磁子。\n但有些情况下却出现了反常的塞曼效应。最明显的反常性表现在原子序数 $Z$ 为奇数的原子，它们的能级分裂为偶数个塞曼次能级。由于 $(2l+1)$，这个数应该是奇数。\nc. 半整数角动量的存在 Stern-Gerlach 实验说明 $j$ 的半整数值时存在的。\n2. 量子描述：Pauli 理论的基本假定 假定电子“绕自身旋转”，赋予了电子一种固有的角动量，我们称之为自旋。我们承认这个自旋的角动量 $\\bl S$ 联系着一个磁矩 $\\bl M_S$：\n$$ \\bl M_S=2\\frac{\\mu_B}{\\hbar}\\bl S $$\n我们发现，自旋磁旋比是轨道磁旋比的两倍。\n设：\n(i) 自旋算符 $\\bl S$ 是一个角动量算符，符合角动量的关系式：\n$$ [S_x,S_y]=i\\hbar S_z $$\n(ii) 自旋算符在一个新空间自旋态空间 $\\mscr E_s$ 中起作用，因此：\n$$ \\begin{aligned} \u0026amp;S^2\\ket{s,m}=s(s+1)\\hbar^2\\ket{s,m}\\nl \u0026amp;S_z\\ket{s,m}=m\\hbar\\ket{s,m} \\end{aligned} $$\n(iii) 待研究的粒子的态空间 $\\mscr E$ 是空间 $\\mscr E_r,\\mscr E_s$ 的张量积：\n$$ \\mscr E=\\mscr E_r \\otimes \\mscr E_s $$\n(iv) 电子是自旋为 1/2 的粒子。\nB. 1/2 角动量的特殊性质 取 $S^2,S_z$ 的共同本征矢的正交归一集合 ${\\ket+,\\ket-}$ 作为基。\n$$ \\begin{array}{l} \\boldsymbol{S}^{2}|\\pm\\rangle=\\frac{3}{4} \\hbar^{2}|\\pm\\rangle \\nl S_{z}|\\pm\\rangle=\\pm \\frac{1}{2} \\hbar|\\pm\\rangle \\end{array} $$\n$$ \\begin{array}{l} \\langle+\\mid-\\rangle=0 \\nl \\langle+\\mid+\\rangle=\\langle-\\mid-\\rangle=1 \\end{array} $$\n$$ |+\\rangle\\langle+|+|-\\rangle\\langle-|=1 $$\n一般的自旋态：\n$$ \\ket\\chi=c_+\\ket++c_-\\ket- $$\n由角动量的普遍性质，我们可以知道 $S^2$ 的本征值为 $3\\hbar^2/4$。\n使用角动量的解法：\n$$ S_\\pm=S_x\\pm-S_y $$\n得到的关系式：\n$$ \\begin{array}{ll} S_{+}|+\\rangle=0 \u0026amp; S_{+}|-\\rangle=\\hbar|+\\rangle \\nl S_{-}|+\\rangle=\\hbar|-\\rangle \u0026amp; S_{-}|-\\rangle=0 \\end{array} $$\n最终解得：\n$$ (S)=\\frac{\\hbar}{2}\\sigma $$\n其中 $\\sigma$ 代表三个 Pauli 矩阵：\n$$ \\sigma_{x}=\\left(\\begin{array}{cc} 0 \u0026amp; 1 \\nl 1 \u0026amp; 0 \\end{array}\\right) \\quad \\sigma_{y}=\\left(\\begin{array}{cc} 0 \u0026amp; -\\mathrm{i} \\nl \\mathrm{i} \u0026amp; 0 \\end{array}\\right) \\quad \\sigma_{z}=\\left(\\begin{array}{cc} 1 \u0026amp; 0 \\nl 0 \u0026amp; -1 \\end{array}\\right) $$\n性质：\n$$ \\begin{array}{c} \\sigma_{x}^{2}=\\sigma_{y}^{2}=\\sigma_{z}^{2}=1 \\nl \\sigma_{x} \\sigma_{y}+\\sigma_{y} \\sigma_{x}=0 \\nl {\\left[\\sigma_{x}, \\sigma_{y}\\right]=2 \\mathrm{i} \\sigma_{z}} \\nl \\sigma_{x} \\sigma_{y}=\\mathrm{i} \\sigma_{z} \\end{array} $$\nC 对自旋 1/2 粒子的非相对论概述 暂时不写，因为考试不考，而且张量积不熟悉。\nComment 这一张从实验出发，导出了电子自旋为 1/2 的理论。\n","date":"2021-12-26T16:14:08+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-9-%E7%94%B5%E5%AD%90%E7%9A%84%E8%87%AA%E6%97%8B/","title":"[量子力学] 9 电子的自旋"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\nC 氢原子 1. 引言 一些参数：\n质子质量 $m_p=1.7\\times10^{-27} ~\\un{kg}$，电荷 $q=1.6\\times10^{-19} ~\\un{C}$s，电子质量 $m_e=9.1\\times10^{-30}~\\un{kg}$。\n势能表达式：\n$$ V(r)=-\\frac{q^2}{4\\pi\\ve_0}\\frac{1}{r}=-\\frac{e^2}{r} $$\n质心坐标系：\n$$ \\mscr H(r,p)=\\frac{p^2}{2\\mu}-\\frac{e^2}{r} $$\n由于 $m_p\\gg m_e$，因此：\n$$ \\mu=\\frac{m_em_p}{m_e+m_p}\\approx m_p $$\n体系的质心几乎与质子重合，因此直接以质子为质心。\n2. 玻尔模型 玻尔模型遵循以下方程\n$$ \\begin{aligned} \u0026amp;E=\\frac{1}{2}\\mu v^2-\\frac{e^2}{r}\\nl \u0026amp;\\frac{\\mu v^2}{r}=\\frac{e^2}{r^2}\\nl \u0026amp;\\mu v r = n\\hbar,n=1,2,\\cdots \\end{aligned} $$\n第一条是能量，第二条是力学方程，第三条是假设的量子化条件（离散能级）。\n解得：\n$$ \\begin{aligned} \u0026amp;E_n=-\\frac{1}{n^2}E_I\\nl \u0026amp; r_n=n^2 a_n\\nl \u0026amp; v_n=\\frac{1}{n}v_0 \\end{aligned} $$\n其中：\n$$ \\begin{aligned} \u0026amp;E_I=\\frac{\\mu e^4}{2\\hbar^2}\\nl \u0026amp; a_0=\\frac{\\hbar^2}{\\mu e^2}\\nl \u0026amp;v_0=\\frac{e^2}{\\hbar} \\end{aligned} $$\n电离能 $E_I=13.6 ~\\un{eV}$，玻尔半径 $a_0=0.052~\\un{nm}$\n3. 氢原子的量子力学理论 解方程：\n$$ [-\\frac{\\hbar^2}{2\\mu}\\triangle-\\frac{e^2}{r}]\\psi(r)=E\\psi(r) $$\n展开$\\psi_{k,l,m}(r)=\\frac{1}{r}u_{k,l}Y^m_l(\\theta,\\varphi)$，并得到径向方程：\n$$ \\left[-\\frac{\\hbar^{2}}{2 \\mu} \\frac{\\mathrm{d}^{2}}{\\mathrm{~d} r^{2}}+\\frac{l(l+1) \\hbar^{2}}{2 \\mu r^{2}}-\\frac{e^{2}}{r}\\right] u_{k, l}(r)=E_{k, l} u_{k, l}(r) $$\n以及附加条件 $u_{k,l}(0)=0$。\n有一个特性：对于 $E$ 的一个正值，经典运动在空间中是不受限制的。$E\u0026lt;0$ 时，经典运动是受限制的，局限在 $B,C$ 两点之间。\n\rimage-20211226151640973\r\n开始解方程了~\na. 变量的变换 引入无量纲的量：\n$$ \\rho=r/a_0,\\lambda_{k,l}=\\sqrt{-E_{k,l}/E_I} $$\n由此得到式子：\n$$ [\\frac{\\dd^2}{\\dd \\rho^2}-\\frac{l(l+1)}{\\rho^2}+\\frac{2}{\\rho}-\\lambda^2_{k,l}]u_{k,l}(\\rho)=0 $$\nb. 求解径向方程 I. 渐进行为 当 $\\rho\\ra\\infty$，$1/\\rho$ 的项可以忽略：\n$$ [\\frac{\\dd^2}{\\dd \\rho^2}-\\lambda^2_{k,l}]u_{k,l}(\\rho)=0 $$\n解为：$e^{\\pm\\rho\\lambda_{k,l}}$，且要舍去 $e^{+\\rho\\lambda_{k,l}}$ 的部分，因为无限远处是有界的。\n设一个系数：\n$$ u_{k,l}(\\rho)=e^{-\\rho\\lambda_{k,l}}y_{k,l}(\\rho) $$\n再代入原式进行求解：\n$$ \\left{\\frac{\\mathrm{d}^{2}}{\\mathrm{~d} \\rho^{2}}-2 \\lambda_{k, l} \\frac{\\mathrm{d}}{\\mathrm{d} \\rho}+\\left[\\frac{2}{\\rho}-\\frac{l(l+1)}{\\rho^{2}}\\right]\\right} y_{k, l}(\\rho)=0 $$\n附加条件：\n$$ y_{k,l}(0)=0 $$\nII. 寻找幂级数形式的解 $$ y_{k,l}(\\rho)=\\rho^s\\sum^\\infty_{q=0}c_q\\rho^q $$\n代入后求解递归项（其中，$s=l+1~或~s=-l$）：\n$$ c_q=-\\frac{2(k-q)}{q(q+2l+1)(k+l)}c_{q-1} $$\n全体系数：\n$$ c_q=(-1)^q(\\frac{2}{k+l})^q\\frac{(k-1)!}{(k-q-1)!}\\frac{(2l+1)!}{q!(q+2l+1)!}c_0 $$\n$c_0$ 由归一化条件决定。\n4. 结果的条论 a. 原子参量的数量级 将基态能量和玻尔半径写成下列形式：\n$$ \\begin{aligned} \u0026amp;E_I=\\frac{1}{2}\\alpha^2\\mu c^2\\nl \u0026amp;a_0=\\frac{1}{\\alpha}\\lambda_c \\end{aligned} $$\n其中 $\\alpha$ 称为精细结构常数，$\\lambda_c$ 为电子的康普顿波长。\nb. 能级 在氢原子情况下， $E_{k,l}$ 并不单独地依赖于 $k,l$，而是依赖于两者之和。令：\n$$ n=k+l $$\n之后便用 $n$ 代替 $k$ 来标记。$n$ 称为主量子数。\n由于 $k\\ge 1$，因此 $l$ 的取值为 $0,1,\\cdots,n-1$，而 $m$ 的取值为 $-l$ 到 $l$。\n简并度为：\n$$ g_n=\\sum^{n-1}_{l=0}(2l+1)=2\\frac{(n-1)n}{2}+n=n^2 $$\n光谱学符号：\n\rimage-20211226155943440\r\n再在前面加上 $n$ 所对应的数字，就组成了标记壳层的光谱学符号：\n\rimage-20211226155457513\r\nc. 波函数 角依赖性：由于 $Y^m_l(\\theta,\\varphi)$ 只通过 $e^{im\\varphi}$ 因子依赖于 $\\varphi$ 的，因此 $|Y^m_l(\\theta,\\varphi)|^2$ 与 $\\varphi$ 无关，因此我们只需要作出宣传曲面在 $Oz$ 平面上的截口就可以了。\n一些例子：\n\rimage-20211226160415471\r\nComment 这一节将上一节的结论应用到了氢原子上，并提出了很多相关的概念。\n","date":"2021-12-23T17:26:38+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-7-%E4%B8%AD%E5%BF%83%E5%8A%BF%E5%9C%BA%E7%9A%84%E7%B2%92%E5%AD%90%E6%B0%A2%E5%8E%9F%E5%AD%90-c-part/","title":"[量子力学] 7 中心势场的粒子；氢原子 C part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\nB 在有相互作用的双粒子体系中之心的运动和相对运动 1. 经典力学中的质心运动和相对运动 拉格朗日函数：\n$$ \\mscr L(r_1,\\dot{r}_1,r_2,\\dot{r}_2)=T-V=\\frac{1}{2}m_1\\dot{r}_1^2+\\frac{1}{2}m_2\\dot{r}_2^2-V(\\bl r_1-\\bl r_2) $$\n引入质心坐标和相对坐标：\n$$ \\bl r_G=\\frac{m_1\\bl r_1+m_2\\bl r_2}{m_1+m_2},\\bl r=\\bl r_1-\\bl r_2 $$\n反向导出表达式：\n$$ \\bl r_1=\\bl r_G+\\frac{m_2}{m_1+m_2}\\bl r,\\bl r_2=\\bl r_G-\\frac{m_1}{m_1+m_2}\\bl r $$\n于是：\n$$ \\mscr L(r_1,\\dot{r}_1,r_2,\\dot{r}_2)=\\frac{1}{2}M\\dot{r}_G^2+\\frac{1}{2}\\mu \\dot{r}^2-V(\\bl r) $$\n其中总质量和约化质量：\n$$ M=m_1+m_2,\\mu=\\frac{m_1m_2}{m_1+m_2} $$\n因此，我们可以得到总动量和相对动量：\n$$ \\bl p_G=M\\dot{\\bl r}_G=\\bl p_1+\\bl p_2,\\bl p = \\mu \\dot{\\bl r}=\\frac{m_2\\bl p_1-m_1\\bl p_2}{m_1+m_2} $$\n系统的 Hamilton 量为：\n$$ \\mscr H(r_G,p_G;r,p)=\\frac{p_G^2}{2M}+\\frac{p^2}{2\\mu} +V(\\bl r) $$\n2. 量子力学中变量的分离 a. 与质心及相对粒子相联系的观察算符 定义：\n$$ \\bl R_G=\\frac{m_1\\bl R_1+m_2\\bl R_2}{m_1+m_2},\\bl R=\\bl R_1-\\bl R_2 $$\n动量算符：\n$$ \\bl P_G=\\bl P_1+\\bl P_2,\\bl P =\\frac{m_2\\bl P_1-m_1\\bl P_2}{m_1+m_2} $$\n对易子不难计算：\n$$ [X_G,P_{Gx}]=i\\hbar,[X,P_x]=i\\hbar $$\n因此说明质心和粒子的方程也遵守该对易式。\nb. Hamilton 算符的本征值和本征函数 $$ H=\\frac{P_1^2}{2m_1}+\\frac{P_2^2}{2m_2}+V(R_1-R_2) $$\n变换成质心表达式：\n$$ H=\\frac{P_G^2}{2M}+\\frac{P^2}{2\\mu}+V(R) $$\n于是 Hamilton 算符就变成两项之和：\n$$ H=H_G+H_r,H_G=\\frac{P_G^2}{2M},H_r=\\frac{P^2}{2\\mu}+V(R) $$\n这两个算符是可对易的：\n$$ [H_G,H_r]=0 $$\n我们可以将方程式分成两条：\n$$ \\begin{aligned} \u0026amp;H_G\\ket{\\psi}=E_G\\ket{\\psi}\\nl \u0026amp;H_r\\ket\\psi=E_r\\ket\\psi \\end{aligned} $$\n最后将他们组合起来：\n$$ E=E_G+E_r $$\n张量积：\n$$ |\\psi\\rangle=\\left|\\chi_{G}\\right\\rangle \\otimes\\left|\\omega_{r}\\right\\rangle $$\n因此方程组变为：\n$$ \\begin{array}{c} \\left{\\begin{array}{l} H_{G}\\left|\\chi_{G}\\right\\rangle=E_{G}\\left|\\chi_{G}\\right\\rangle \\nl \\left|\\chi_{G}\\right\\rangle \\in \\mathscr{E}_{r_{G}} \\end{array}\\right. \\nl \\left{\\begin{array}{l} H_{r}\\left|\\omega_{r}\\right\\rangle=E_{r}\\left|\\omega_{r}\\right\\rangle \\nl \\left|\\omega_{r}\\right\\rangle \\in \\mathscr{E}_{r} \\end{array}\\right. \\end{array} $$\n使用 $r$ 表象：\n$$ \\begin{aligned} \u0026amp;-\\frac{\\hbar^{2}}{2 M} \\Delta_{G} \\chi_{G}\\left(\\boldsymbol{r}_{G}\\right)=E_{G} \\chi_{G}\\left(\\boldsymbol{r}_{G}\\right)\\nl \u0026amp;\\left[-\\frac{\\hbar^{2}}{2 \\mu} \\Delta+V(r)\\right] \\omega_{r}(\\boldsymbol{r})=E_{r} \\omega_{r}(\\boldsymbol{r}) \\end{aligned} $$\n第一条式子明显就是自由粒子（平面波）的解\n$$ X_G(r_G)=\\frac{1}{(2\\pi\\hbar)^{3/2}}e^{\\frac{i}{\\hbar}p_G\\cdot r_G} $$\n对应的能量：\n$$ E_G=\\frac{p_G^2}{2M} $$\n而第二项方程明显更重要，描述的是相对粒子体系在质心坐标系中的行为。\nComment 这一章将两个粒子的坐标系转换到质心坐标系，正如经典力学中做的那样，在量子力学中也做了一遍，以方便后面对氢原子的演算。\n","date":"2021-12-23T17:26:34+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-7-%E4%B8%AD%E5%BF%83%E5%8A%BF%E5%9C%BA%E7%9A%84%E7%B2%92%E5%AD%90%E6%B0%A2%E5%8E%9F%E5%AD%90-b-part/","title":"[量子力学] 7 中心势场的粒子；氢原子 B part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\nA 中心势场中粒子的定态 1. 问题梗概 a. 经典力学回顾 粒子总能量：\n$$ E=\\frac{1}{2}\\mu v^2+V(r)=\\frac{1}{2}\\mu v^2_r+\\frac{1}{2}\\mu v^2_\\perp+V(r) $$\n使用动量和角动量替换 $v_r,v_\\perp$ 项：\n$$ E=\\frac{p_r^2}{2\\mu}+\\frac{\\mscr L^2}{2\\mu r^2}+V(r) $$\n其中：\n$$ p_r=\\mu\\frac{\\dd r}{\\dd t},\\mscr L^2=p_\\theta^2+\\frac{1}{ \\sin^2\\theta}p_\\varphi^2 $$\n定义一个有效势（仅与 $r$ 相关）：\n$$ V_{\\un{eff}}(r)=V(r)+\\frac{\\mscr L^2}{2\\mu r^2} $$\nb. Hamilton 算符 $$ H=[-\\frac{\\hbar^2}{2\\mu}\\triangle+V(r)]\\varphi(\\bl r)=E\\varphi(\\bl r) $$\n在球坐标下：\n$$ \\triangle=\\frac{1}{r}\\frac{\\par^2}{\\par r^2}r+\\frac{1}{r^2}(\\frac{\\par^2}{\\par\\theta^2}+\\frac{1}{\\tan\\theta}\\frac{\\par}{\\par\\theta}+\\frac{1}{ sin^2\\theta}\\frac{\\par^2}{\\par\\varphi^2}) $$\n代入 $L^2$ 算符：\n$$ H=-\\frac{\\hbar^2}{2\\mu}\\frac{1}{r}\\frac{\\par^2}{\\par r^2}r+\\frac{1}{2\\mu r^2}L^2+V(r) $$\n求解的本征值方程：\n$$ [-\\frac{\\hbar^2}{2\\mu}\\frac{1}{r}\\frac{\\par^2}{\\par r^2}r+\\frac{1}{2\\mu r^2}L^2+V(r)]\\psi(r,\\theta,\\varphi)=E\\psi(r,\\theta,\\varphi) $$\n2. 变量的分离 a. 本征函数与角度的依赖关系 因为 $L$ 函数只作用于 $\\theta,\\varphi$ 变量，因此，一切作用于 $r$ 的算符都可以对易。在量子力学意义下，$L$ 的三个分量都是运动常量，即：\n$$ [H,L]=0 $$\n同样的， $H$ 和 $L^2$ 也可以对易。\n三个方程组：\n$$ \\begin{aligned} H\\psi(\\bl r)\u0026amp;=E\\psi(\\bl r)\\nl L^2\\psi(\\bl r)\u0026amp;=l(l+1)\\hbar^2\\psi(\\bl r)\\nl L_z\\psi(\\bl r)\u0026amp;=m\\hbar\\psi(\\bl r) \\end{aligned} $$\n根据之前的讨论，我们可以得出：\n$$ \\psi(\\bl r)=R(r)Y^m_l(\\theta,\\varphi) $$\nb. 径向方程 将上式代入本征值方程中：\n$$ [-\\frac{\\hbar^2}{2\\mu}\\frac{1}{r}\\frac{\\par^2}{\\par r^2}r+\\frac{l(l+1)\\hbar^2}{2\\mu r^2}+V(r)]R(r)=ER(r) $$\n通过一系列讨论，我们可以得到一些数与 $k,l$ 的相关性： $R(r)=R_{k,l}(r),E=E_{k,l}$。\n进行代换：\n$$ R_{k,l}=\\frac{1}{r}u_{k,l}(r) $$\n得到的本征方程：\n$$ [-\\frac{\\hbar^2}{2\\mu}\\frac{\\par^2}{\\par r^2}+\\frac{l(l+1)\\hbar^2}{2\\mu r^2}+V(r)]u_{k,l}(r)=E_{k,l}u_{k,l}(r) $$\nc. 径向方程的解在原点的行为 当 $r\\ra 0$ 时，设：\n$$ R_{k,l}(r)\\approx Cr^s $$\n代入方程中，并令主项的系数为 0，得到方程：\n$$ -s(s+1)+l(l+1)=0 $$\n解得：\n$$ s=l~ \\text{ or}~s=-(l+1) $$\n我们可以排除 $s=-(l+1)$ 的解，因为在 0 处不符合函数性质。\n因此：\n$$ u_{k,l}(0)=0 $$\n3. 中心势场中粒子的定态 a. 量子数 (i) 规定 $H$ 的本征函数同时又是 $L^2,L_z$ 的本征函数，因此：\n$$ \\psi_{k,l,m}(\\bl r)=R_{k,l}(r)Y^m_l(\\theta,\\varphi)=\\frac{1}{r}u_{k,l}Y^m_l(\\theta,\\varphi) $$\n(ii) 将 $H$ 的本征值方程代换为只含变量 $r$ 的微分方程。\n归一化：\n$$ \\int |\\psi_{k,l,m}|^2 r^2\\dd r\\dd\\Omega=1 $$\n分解：\n$$ \\int |\\psi_{k,l,m}|^2 r^2\\dd r\\dd\\Omega=\\int^\\infty_0 r^2\\dd r|R_{k,l}|^2\\int \\dd \\Omega |Y^m_l(\\theta,\\varphi)|^2 $$\n由于球谐函数已归一化，因此：\n$$ \\int^\\infty_0 r^2\\dd r|R_{k,l}|^2=\\int^\\infty_0\\dd r|u_{k,l}(r)|^2=1 $$\nb. 能级的简并度 将 $k,l$ 的值固定，$m$ 的值可以从 $-l$ 变化到 $l$，与此对应的 $(2l+1)$ 个函数都属于同一本征值 $E_{k,l}$ 的本征函数。这种简并总是存在的，称它为实质性简并。如果偶尔相同，那就叫偶然性兼并。\n从上面的讨论可以推知， $H,L^2,L_z$ 构成一个 ECOC。\n","date":"2021-12-23T17:26:11+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-7-%E4%B8%AD%E5%BF%83%E5%8A%BF%E5%9C%BA%E7%9A%84%E7%B2%92%E5%AD%90%E6%B0%A2%E5%8E%9F%E5%AD%90-a-part/","title":"[量子力学] 7 中心势场的粒子；氢原子 A part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\n1. $L^2$ 与 $L_z$ 的本征值及本征函数 a. $\\{\\ket{r}\\}$ 表象中的本征值方程 角动量 $L$ 的三个分量：\n$$ \\begin{aligned} L_{x} \u0026amp;=\\frac{\\hbar}{\\mathrm{i}}\\left(y \\frac{\\partial}{\\partial z}-z \\frac{\\partial}{\\partial y}\\right) \\nl L_{y} \u0026amp;=\\frac{\\hbar}{\\mathrm{i}}\\left(z \\frac{\\partial}{\\partial x}-x \\frac{\\partial}{\\partial z}\\right) \\nl L_{z} \u0026amp;=\\frac{\\hbar}{\\mathrm{i}}\\left(x \\frac{\\partial}{\\partial y}-y \\frac{\\partial}{\\partial x}\\right) \\end{aligned} $$\n使用球坐标更方便：\n$$ \\left\\{\\begin{array}{l} x=r \\sin \\theta \\cos \\varphi \\nl y=r \\sin \\theta \\sin \\varphi \\nl z=r \\cos \\theta \\end{array}\\right. $$\n体元：\n$$ \\dd^3 r = r^2\\sin \\theta \\dd r \\dd \\theta \\dd \\varphi=r^2 \\dd r \\dd \\Omega $$\n使用坐标变换的方法可以得到：\n$$ \\begin{aligned} \u0026amp;L_{x}=\\mathrm{i} \\hbar\\left(\\sin \\varphi \\frac{\\partial}{\\partial \\theta}+\\frac{\\cos \\varphi}{\\tan \\theta} \\frac{\\partial}{\\partial \\varphi}\\right) \\nl \u0026amp;L_{y}=\\mathrm{i} \\hbar\\left(-\\cos \\varphi \\frac{\\partial}{\\partial \\theta}+\\frac{\\sin \\varphi}{\\tan \\theta} \\frac{\\partial}{\\partial \\varphi}\\right) \\nl \u0026amp;L_{z}=\\frac{\\hbar}{\\mathrm{i}} \\frac{\\partial}{\\partial \\varphi} \\end{aligned} $$\n得到其他的算符：\n$$ \\begin{aligned} \u0026amp;L^{2}=-\\hbar^{2}\\left(\\frac{\\partial^{2}}{\\partial \\theta^{2}}+\\frac{1}{\\tan \\theta} \\frac{\\partial}{\\partial \\theta}+\\frac{1}{\\sin ^{2} \\theta} \\frac{\\partial^{2}}{\\partial \\varphi^{2}}\\right) \\nl \u0026amp;L_{+}=\\hbar \\mathrm{e}^{\\mathrm{i} \\varphi}\\left(\\frac{\\partial}{\\partial \\theta}+\\mathrm{i} \\cot \\theta \\frac{\\partial}{\\partial \\varphi}\\right) \\nl \u0026amp;L_{-}=\\hbar \\mathrm{e}^{-\\mathrm{i} \\varphi}\\left(-\\frac{\\partial}{\\partial \\theta}+\\mathrm{i} \\cot \\theta \\frac{\\partial}{\\partial \\varphi}\\right) \\end{aligned} $$\n最后得到两条式子：\n$$ \\begin{aligned} \u0026amp;-\\left\\{\\frac{\\partial^{2}}{\\partial \\theta^{2}}+\\frac{1}{\\tan \\theta} \\frac{\\partial}{\\partial \\theta}+\\frac{1}{\\sin ^{2} \\theta} \\frac{\\partial^{2}}{\\partial \\varphi^{2}}\\right\\} \\psi(r, \\theta, \\varphi)=l(l+1) \\psi(r, \\theta, \\varphi) \\nl \u0026amp;-\\mathrm{i} \\frac{\\partial}{\\partial \\varphi} \\psi(r, \\theta, \\varphi)=m \\psi(r, \\theta, \\varphi) \\end{aligned} $$\n由于 $r$ 并未出现在任何微分算符中，因此可以将其看作参变量，并只需考虑算符与 $\\theta,\\varphi$ 的依赖关系：\n$$ \\begin{aligned} \u0026amp;L^2Y^m_l(\\theta,\\varphi)=l(l+1)\\hbar^2 Y^m_l(\\theta,\\varphi) \\nl \u0026amp;L_zY^m_l(\\theta,\\varphi)=m\\hbar Y^m_l(\\theta,\\varphi) \\end{aligned} $$\n一旦解出 $Y^m_l(\\theta,\\varphi)$，那么我们就可以得到波函数的表达式：\n$$ \\psi_{l,m}(r,\\theta,\\varphi)=f(r)Y^m_l(\\theta,\\varphi) $$\n对于波函数的归一化：\n$$ \\int^{2\\pi}_0\\dd \\varphi\\int^\\pi_0\\sin\\theta |Y^m_l(\\theta,\\varphi)|^2\\dd \\theta = 1 $$\n以及 $r$：\n$$ \\int^\\infty_0 r^2|f(r)|^2\\dd r=1 $$\nb. $l$ 与 $m$ 的值 1、$l$ 和 $m$ 只能是整数 $$ \\frac{\\hbar}{i}\\frac{\\par}{\\par\\varphi}Y^m_l(\\theta,\\varphi)=m\\hbar Y^m_l(\\theta,\\varphi) $$\n这表明：\n$$ Y^m_l(\\theta,\\varphi)=F^m_l(\\theta)e^{im\\varphi} $$\n由于 $Y^m_l(\\theta,\\varphi=0)=Y^m_l(\\theta,\\varphi=2\\pi)$\n由此可以推知：\n$$ e^{2im\\pi=1} $$\n因此得到 $m$ 仅能是整数，就能从此推得 $l$ 也只能是整数。\n2、 $l$ 的全体整数值都会出现 我们将 $l$ 固定到一个整数值，我们知道：\n$$ L_+Y^l_l(\\theta,\\varphi)=0 $$\n展开后：\n$$ (\\frac{\\dd}{\\dd\\theta}-l\\cot \\theta)F^l_l(\\theta)=0 $$\n通解为：\n$$ F^l_l(\\theta)=c_l(\\sin\\theta)^l $$\n因此：\n$$ Y^l_l(\\theta,\\varphi)=c_l(\\sin\\theta)^le^{il\\varphi} $$\n然后经过 $L_-$ 的数次迭代作用，就能得到更低级的 $m$。因此我们可以算出这些函数，$Y^m_l(\\theta,\\varphi)$ 类型的本征函数被叫做球谐函数。\nc. 球谐函数的主要性质 1、递推关系 $$ L_\\pm Y^m_l(\\theta,\\varphi)=\\hbar \\sqrt{l(l+1)+m(m\\pm 1)}Y^{m\\pm1}_l(\\theta,\\varphi) $$\n2、正交归一化关系和封闭性关系式 正交归一化：\n$$ \\int^{2\\pi}_0\\dd \\varphi\\int^\\pi_0\\sin\\theta~ \\dd \\theta ~Y^{m'*}_{l'}(\\theta,\\varphi)Y^m_l(\\theta,\\varphi)=\\delta_{l\u0026rsquo;l}\\delta_{m\u0026rsquo;m} $$\n球谐函数展开：\n$$ f(\\theta,\\varphi)=\\sum^\\infty_{l=0}\\sum^{+l}_{m=-l}c_{l,m}Y^m_l(\\theta,\\varphi) $$\n系数：\n$$ c_{l, m}=\\int_{0}^{2 \\pi} \\mathrm{d} \\varphi \\int_{0}^{\\pi} \\sin \\theta \\mathrm{d} \\theta \\mathrm{Y}_{l}^{m *}(\\theta, \\varphi) f(\\theta, \\varphi) $$\n封闭性关系式：\n$$ \\begin{aligned} \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{+l} \\mathrm{Y}_{l}^{m}(\\theta, \\varphi) \\mathrm{Y}_{l}^{m *}\\left(\\theta^{\\prime}, \\varphi^{\\prime}\\right) \u0026amp;=\\delta\\left(\\cos \\theta-\\cos \\theta^{\\prime}\\right) \\delta\\left(\\varphi-\\varphi^{\\prime}\\right) \\nl \u0026amp;=\\frac{1}{\\sin \\theta} \\delta\\left(\\theta-\\theta^{\\prime}\\right) \\delta\\left(\\varphi-\\varphi^{\\prime}\\right) \\end{aligned} $$\n（因为 $Y^m_l(\\theta,\\varphi)$ 中的微分元是 $\\cos\\theta$）\n3、宇称与复数共轭 $$ Y^m_l(\\pi-\\theta,\\pi+\\varphi)=(-1)^lY^m_l(\\theta,\\varphi) $$\n还有以下关系：\n$$ [Y^m_l(\\theta,\\varphi)]^*=(-1)^m Y^{-m}_l(\\theta,\\varphi) $$\nd. 一个无自旋粒子的波函数空间中的标准基 我们可以推知关系式：\n$$ \\psi_{k,l,m}(r)=R_{k,l,m}(r)Y^m_l(\\theta,\\varphi) $$\n被 $L_{\\pm}$ 作用时：\n$$ \\begin{aligned} L_{\\pm} \\psi_{k, l, m}(\\boldsymbol{r}) \u0026amp;=R_{k, l, m}(r) L_{\\pm} \\mathrm{Y}_{l}^{m}(\\theta, \\varphi) \\nl \u0026amp;=\\hbar \\sqrt{l(l+1)-m(m \\pm 1)} R_{k, l, m}(r) \\mathrm{Y}_{l}^{m \\pm 1}(\\theta, \\varphi) \\end{aligned} $$\n因此，径向函数与 $m$ 无关，因此可以化成：\n$$ \\psi_{k,l,m}(r)=R_{k,l}(r)Y^m_l(\\theta,\\varphi) $$\n正交归一关系式：\n$$ \\begin{aligned} \\int \\mathrm{d}^{3} r \\psi_{k, l, m}^{*}(\\boldsymbol{r}) \\psi_{k^{\\prime}, l^{\\prime}, m^{\\prime}}(\\boldsymbol{r})=\u0026amp; \\int_{0}^{\\infty} r^{2} \\mathrm{~d} r R_{k, l}^{*}(r) R_{k^{\\prime}, l^{\\prime}}(r) \\nl \u0026amp; \\times \\int_{0}^{2 \\pi} \\mathrm{d} \\varphi \\int_{0}^{\\pi} \\sin \\theta \\mathrm{d} \\theta \\mathrm{Y}_{l}^{m *}(\\theta, \\varphi) \\mathrm{Y}_{l^{\\prime}}^{m^{\\prime}}(\\theta, \\varphi) \\nl =\u0026amp; \\delta_{k k^{\\prime}} \\delta_{l l^{\\prime}} \\delta_{m m^{\\prime}} \\end{aligned} $$\n由于球谐函数早已归一化，因此最后得到：\n$$ \\int_{0}^{\\infty} r^{2} \\mathrm{~d} r R_{k, l}^{*}(r) R_{k^{\\prime}, l}(r)=\\delta_{k k^{\\prime}} $$\n2. 物理上的考虑 a. 关于态 $\\ket{k,l,m}$ 的讨论 我们讨论一个无自旋粒子，它处于 $L^2$ 和 $L_z$ 的本征态 $\\ket{k,l,m}$。\n但是当我们测量其在 $Ox,Oy$ 轴上的分量时，因为不对易的关系，因此不能得出确切的预言。\n将式子反过来求解：\n$$ \\begin{aligned} \u0026amp;L_x=\\frac{1}{2}(L_++L_-)\\nl \u0026amp;L_y=\\frac{1}{2i}(L_+-L_-) \\end{aligned} $$\n因此可以推知（正交归一）：\n$$ \\bok{k,l,m}{L_x}{k,l,m}=\\bok{k,l,m}{L_y}{k,l,m}=0 $$\n此外：\n$$ \\begin{aligned} \u0026amp;\\bok{k,l,m}{L_x^2}{k,l,m}=\\frac{1}{4}\\bok{k,l,m}{L_+^2+L_-^2+L_+L_-+L_-L_+}{k,l,m}\\nl \u0026amp;\\bok{k,l,m}{L_y^2}{k,l,m}=\\frac{1}{4}\\bok{k,l,m}{L_+^2+L_-^2-L_+L_\u0026ndash;L_-L_+}{k,l,m} \\end{aligned} $$\n由于平方项对结果无贡献，另外：\n$$ L_+L_-+L_-L_+=2(L^2-L_z^2) $$\n因此：\n$$ \\begin{aligned} \\left\\langle k, l, m\\left|L_{x}^{2}\\right| k, l, m\\right\\rangle \u0026amp;=\\left\\langle k, l, m\\left|L_{y}^{2}\\right| k, l, m\\right\\rangle \\nl \u0026amp;=\\frac{1}{2}\\left\\langle k, l, m\\left|\\left(\\boldsymbol{L}^{2}-L_{z}^{2}\\right)\\right| k, l, m\\right\\rangle \\nl \u0026amp;=\\frac{\\hbar^{2}}{2}\\left[l(l+1)-m^{2}\\right] \\end{aligned} $$\n由这两个值，我们可以推出：\n$$ \\begin{aligned} \u0026amp;\\avg{L_x}=\\avg{L_y}=0\\nl \u0026amp;\\Delta L_x=\\Delta L_y=\\hbar\\sqrt{l(l+1)-m^{2}} \\end{aligned} $$\n我们得到的一个图像是经典角动量。它的模 $|OL|=\\hbar\\sqrt{l(l+1)}$，它在 $Oz$ 轴上的投影 $|OH|=m\\hbar$。\n\rimage-20211222232135435\r\nb. 关于测量 $L^2$ 与 $L_z$ 的物理语言的计算 使用 $\\bra{r}$ 表象\n1、普遍公式 引入标准基：\n$$ \\psi_{k,l,m}(r)=R_{k,l}(r)Y^m_l(\\theta,\\varphi) $$\n从而可以写出：\n$$ \\psi(r)=\\sum_k\\sum_l\\sum_m c_{k,l,m}R_{k,l}(r)Y^m_l(\\theta,\\varphi) $$\n系数的计算方法：\n$$ \\begin{aligned} c_{k, l, m} \u0026amp;=\\int \\mathrm{d}^{3} r \\psi_{k, l, m}^{*}(\\boldsymbol{r}) \\psi(\\boldsymbol{r}) \\nl \u0026amp;=\\int_{0}^{\\infty} r^{2} \\mathrm{~d} r R_{k, l}^{*}(r) \\int_{0}^{2 \\pi} \\mathrm{d} \\varphi \\int_{0}^{\\pi} \\sin \\theta \\mathrm{d} \\theta \\mathrm{Y}_{l}^{m *}(\\theta, \\varphi) \\psi(r, \\theta, \\varphi) \\end{aligned} $$\n概率：\n$$ \\mscr P_{L^2,L_z}(l,m)=\\sum_k|c_{k,l,m}|^2 $$\n如果只测量 $L^2$，则将 $L_z$ 的部分（即 $m=-l$ 到 $l$ 加起来）：\n$$ \\mscr P_{L^2}(l)=\\sum_k\\sum_{m=-l}^l|c_{k,l,m}|^2 $$\n对于 $L_z$ 同理：\n$$ \\mscr P_{L_z}(m)=\\sum_k\\sum_{k\\ge|m|}|c_{k,l,m}|^2 $$\n还有一些特殊情况：\n1、引入 $a_{l,m}(r)$ 说明 $L^2,L_z$ 只与 $\\theta,\\varphi$ 相关\n2、引入 $Y^m_l(\\theta,\\varphi)=Z^m_l(\\theta)\\frac{e^{im\\varphi}}{\\sqrt{2\\pi}}$ 的形式导出 $L_z$ 只与 $\\varphi$ 相关。\n3、以及他们与 $\\mscr P$、归一化关系式的各种关系式。\n4、一种特殊情况。\n就看书吧，全部记下来真的太繁琐了。\nComment 总算是把角动量这一张给啃完了。虽然还是有一些不太理解的地方，但大概的想法已经理解了。\nD part 主要的内容是关于角动量理论的具体解法。\n1、使用 $\\ket{r}$ 表象，解出了各算符的表达式。\n2、发现 $L^2,L_z$ 算符与 $r$ 无关，因此导出专门的一个函数球谐函数 $Y_l^m(\\theta,\\varphi)$，并探讨了它的性质，导出其正交归一和封闭性。\n3、增加 $R_{k,l}(\\theta,\\varphi)$ 项。\n4、与真实物理概率联系起来。并用经典物理进行类比。\n","date":"2021-12-16T23:38:39+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-6-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%AD%E8%A7%92%E5%8A%A8%E9%87%8F%E7%9A%84%E6%99%AE%E9%81%8D%E6%80%A7%E8%B4%A8-d-part/","title":"[量子力学] 6 量子力学中角动量的普遍性质 D part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} $$\n6 量子力学中角动量的普遍性质 A 引言：角动量的重要性 角动量守恒定理：\n$$ \\frac{\\dd}{\\dd t}\\mscr L=0 $$\n和经典体系的角动量 $\\scr L$ 相联系的是一个可观测量 $\\bl L$，它是 $L_x,L_y,L_z$ 的集合。这是和经典物理所对应的\n另一方面，第四章中的 Stern-Gerlach 实验显示了角动量的量子化。因此说明我们可能需要引入量子性的、没有任何经典类比的角动量（即内禀角动量）。\n从现在起，凡是经典类比的角动量都称为轨道角动量（用 $\\bl L$ 表示对应的可观察量），凡是内禀角动量都称为自旋角动量（用 $\\bl S$ 表示对应的可观察量）。构成的总角动量为 $\\bl J$。在这一章将研究一切角动量都具有的普遍量子性质。\nB 角动量所持有的对易关系式 1. 轨道角动量 经典角动量的一个分量：\n$$ \\mscr L_x=yp_x-zp_y $$\n由于 $Y,P_x$ 之类可以对易，因此顺序并不重要。因此可得到算符 $L_x$：\n$$ L_x=YP_z-ZP_y $$\n同理也可以写出 $L_y,L_z$，于是：\n$$ \\bl L=\\bl R\\times\\bl P $$\n易得对易关系：\n$$ \\begin{array}{l} {\\left[L_{x}, L_{y}\\right]=\\mathrm{i} \\hbar L_{z}} \\nl {\\left[L_{y}, L_{z}\\right]=\\mathrm{i} \\hbar L_{x}} \\nl {\\left[L_{z}, L_{x}\\right]=\\mathrm{i} \\hbar L_{y}} \\end{array} $$\n可以立即推广到 $N$ 个无自旋粒子的体系：\n$$ \\bl L=\\sum_{i=1}^N\\bl L_i $$\n2. 推广：角动量的定义 如果任意三个观察算符 $J_x,J_y,J_z$ 满足以下关系式：\n$$ \\begin{array}{l} {\\left[J_{x}, J_{y}\\right]=\\mathrm{i} \\hbar J_{z}} \\nl {\\left[J_{y}, J_{z}\\right]=\\mathrm{i} \\hbar J_{x}} \\nl {\\left[J_{z}, J_{x}\\right]=\\mathrm{i} \\hbar J_{y}} \\end{array} $$\n我们就称 $J_x,J_y,J_z$ 的集合为角动量 $\\bl J$，这是三维空间中旋转的几何性质导致的。\n引入角动量平方的算符 $\\bl J^2$：\n$$ \\bl J^2=J_x^2+J_y^2+J_z^2 $$\n由于 $J_x,J_y,J_z$ 都是 Hermite 算符，因此 $\\bl J^2$ 也是。可证明：\n$$ [\\bl J^2,\\bl J]=0 $$\n我们注意到，角动量的三个分量式不可能同时测量的（互相不对易），但是 $\\bl J^2$ 和 $\\bl J$ 的任意一个分量都是相容的。\n3. 问题的梗概 通过 $\\bl L^2$ 和 Hamilton 算符 $H$ 对易，导出四个运动常量 $\\bl L^2,L_x,L_y,L_z$，且四个算符彼此并不对易。为了找到与 $H$ 构成 ECOC 的算符，我们只能取 $\\bl L^2$ 与其他三个算符中的一个，例如 $L_z$。\nC 角动量的普遍理论 这一节我们要确定 $\\bl J^2$ 和 $J_z$ 的谱，然后寻求他们的共同本征矢。\n1. 定义与符号 a. 算符 $J_+,J_-$ 定义：\n$$ J_+=J_x+iJ_y,~J_-=J_x-iJ_y $$\n各种关系：\n1、对易关系：\n$$ \\begin{array}{l} {\\left[J_{z}, J_{+}\\right]=\\hbar J_{+}} \\nl {\\left[J_{z}, J_{-}\\right]=-\\hbar J_{-}} \\nl {\\left[J_{+}, J_{-}\\right]=2 \\hbar J_{z}} \\nl {\\left[\\boldsymbol{J}^{2}, J_{+}\\right]=\\left[\\boldsymbol{J}^{2}, J_{-}\\right]=\\left[\\boldsymbol{J}^{2}, J_{z}\\right]=0} \\end{array} $$\n2、相乘：\n$$ \\begin{aligned} J_{+} J_{-} \u0026amp;=\\left(J_{x}+\\mathrm{i} J_{y}\\right)\\left(J_{x}-\\mathrm{i} J_{y}\\right) \\nl \u0026amp;=J_{x}^{2}+J_{y}^{2}-\\mathrm{i}\\left[J_{x}, J_{y}\\right] \\nl \u0026amp;=J_{x}^{2}+J_{y}^{2}+\\hbar J_{z} \\nl \u0026amp;=\\bl J^2-J_z^2+\\hbar J_z\\nl J_{-} J_{+} \u0026amp;=\\left(J_{x}-\\mathrm{i} J_{y}\\right)\\left(J_{x}+\\mathrm{i} J_{y}\\right) \\nl \u0026amp;=J_{x}^{2}+J_{y}^{2}+\\mathrm{i}\\left[J_{x}, J_{y}\\right] \\nl \u0026amp;=J_{x}^{2}+J_{y}^{2}-\\hbar J_{z}\\nl \u0026amp;=\\bl J^2-J_z^2-\\hbar J_z \\end{aligned} $$\n反向导出：\n$$ J^{2}=\\frac{1}{2}\\left(J_{+} J_{-}+J_{-} J_{+}\\right)+J_{z}^{2} $$\nb. $\\bl J^2$ 与 $J_z$ 的本征值的符号 $$ \\bok{\\psi}{J^2}{\\psi}\\ge 0 $$\n意味着 $J^2$ 的所有本征值都是正数或零。\n取其本征值为：\n$$ j(j+1)\\hbar^2,j\\ge 0,\\text{ and let} ~\\lambda=j(j+1) $$\n容易知道 $\\lambda$ 的值唯一地确定了 $j$ 的值。\n至于 $J_z$ 的本征值，设其本征值为 $m\\hbar$。\nc. $\\bl J^2$ 与 $J_z$ 的本征值方程 由于 $J^2,J_z$ 并不构成一个 ECOC，因此必须引入第三个指标来区分这两个算符。\n方程组为：\n$$ \\begin{aligned} \u0026amp;J^2\\ket{k,j,m}=j(j+1)\\hbar^2\\ket{k,j,m}\\nl \u0026amp;J_z\\ket{k,j,m}=m\\hbar\\ket{k,j,m} \\end{aligned} $$\n2. $\\bl J^2$ 与 $J_z$ 的本征值 a. 引理 引理 I：如果满足这两条方程组，那么：\n$$ -j\\le m\\le j $$\n引理 II（矢量 $J_-\\ket{k,j,m}$ 的性质）\n如果满足这两条方程组，那么：\n(i) 如果 $m=-j$ ，则 $J_-\\ket{k,j,-j}=0$\n(ii) 如果 $m\u0026gt;-j$，则 $J_-\\ket{k,j,m}$ 是 $J^2$ 与 $J_z$ 的一个非零本征矢，属于本征值 $j(j+1)\\hbar^2$ 和 $(m-1)\\hbar$。\n引理 III （矢量 $J_+\\ket{k,j,m}$ 的性质）\n如果满足这两条方程组，那么：\n(i) 如果 $m=j$ ，则 $J+-\\ket{k,j,j}=0$\n(ii) 如果 $m\u0026lt;j$，则 $J_+\\ket{k,j,m}$ 是 $J^2$ 与 $J_z$ 的一个非零本征矢，属于本征值 $j(j+1)\\hbar^2$ 和 $(m+1)\\hbar$。\nb. 确定 $J^2$ 及 $J_z$ 的谱 假设 $\\ket{k,j,m}$ 满足这两条方程组，那么应有 $-j\\le m\\le j$，因此一定存在一个非负整数 $p$ 使得（就是将 $m-p$ 变成分数）：\n$$ -j\\le m-p \u0026lt; -j+1 $$\n考虑以下一系列矢量序列：\n$$ \\ket{k,j,m},J_-\\ket{k,j,m},\\cdots,(J_-)^p\\ket{k,j,m} $$\n这一串矢量中 $(J_-)^n$ 项属于本征值 $j(j+1)\\hbar^2$ 与 $(m-n)\\hbar$。\n$(J_-)^{n-1}\\ket{k,j,m}$ 对应的本征值是 $j(j+1)\\hbar^2$ 及 $(m-n+1)\\hbar$。\n显然 $m-n+1\\ge m-p+1$，再因为 $m-p\\ge -j$，因此：\n$$ m-n+1\\ge m-p+1\\ge -j+1 $$\n但对于 $(J_-)^p\\ket{j,k,m}$ ，必须严格大于 $-j\\hbar$：\n$$ m-p\u0026gt;-j $$\n但不能再使用这个算符，不然将会得到 0，因此：\n$$ m-p=-j $$\n由引理 III，可以推出另一个不等式：\n$$ m+q=j $$\n结合起来：\n$$ p+q=2j $$\n因此可以推知 $j$ 等于整数或半整数。$J_z$ 的本征值为：\n$$ -j\\hbar,(-j+1)\\hbar,\\cdots,(j-1)\\hbar,j\\hbar $$\n\rimage-20211220214614767\r\n3. 标准表象 $\\ket{k,j,m}$ a. 基右矢 假设这两条式子的本征值集合再 $\\scr E$ 空间中张成一个矢量子空间，记作 $\\mscr E(j,m)$，可以预见其维数 $g(j,m)\u0026gt;1$，这是因为一般说来 $J^2,J_z$ 并不构成 一个 ECOC。现在选择一个任意的正交归一基 $\\{\\ket{k,j,m};k=1,2,\\cdots,g(j,m)\\}$。\n那么，当 $-j\u0026lt;m\u0026lt;j$ 的情况下，在 $\\mscr E(j,m+1),\\mscr E(j,m-1)$ 空间中各构造一个正交归一基。\n首先，我们证明： $k_1\\ne k_2$，则 $J_+\\ket{k_1,j,m},J_+\\ket{k_2,j,m}$ 正交， $J_-$ 的两条式子也正交。\n$$ \\begin{aligned} \\left\\langle k_{2}, j, m\\left|J_{\\mp} J_{\\pm}\\right| k_{1}, j, m\\right\\rangle \u0026amp;=\\left\\langle k_{2}, j, m\\left|\\left(\\boldsymbol{J}^{2}-J_{z}^{2} \\mp \\hbar J_{z}\\right)\\right| k_{1}, j, m\\right\\rangle \\nl \u0026amp;=[j(j+1)-m(m \\pm 1)] \\hbar^{2}\\left\\langle k_{2}, j, m \\mid k_{1}, j, m\\right\\rangle \\end{aligned} $$\n由于 $\\mscr E(j,m)$ 是正交归一的，因此 $k_1\\ne k_2$ 时这个标量积为 0，当 $k_1=k_2$ 时，便得到 $J_{\\pm}\\ket{k,j,m}$ 的模平方 $[j(j+1)-m(m\\pm1)]\\hbar^2$。\n考虑下式：\n$$ |k, j, m+1\\rangle=\\frac{1}{\\hbar \\sqrt{j(j+1)-m(m+1)}} J_{+}|k, j, m\\rangle $$\n总之 balabala 就能构成 $\\mscr E(j,m+1)$ 空间中的一个基。\n同理，\n$$ |k, j, m-1\\rangle=\\frac{1}{\\hbar \\sqrt{j(j+1)-m(m-1)}} J_{-}|k, j, m\\rangle $$\n也是构成 $\\mscr E(j,m-1)$ 空间中的一个基。\n特别地，我们发现：\n$$ g(j,m+1)=g(j,m-1)=g(j,m)=g(j) $$\n这表明它们的维数与 $m$ 无关。\n接下来我们取标准基：\n\rimage-20211221210854423\r\n接下来，正交归一关系式和封闭性关系式：\n$$ \\begin{aligned} \u0026amp;\\left\\langle k, j, m \\mid k^{\\prime}, j^{\\prime}, m^{\\prime}\\right\\rangle=\\delta_{k k^{\\prime}} \\delta_{j j^{\\prime}} \\delta_{m m^{\\prime}} \\nl \u0026amp;\\sum_{j} \\sum_{m=-j}^{+j} \\sum_{k=1}^{g(j)}|k, j, m\\rangle\\langle k, j, m|=1 \\end{aligned} $$\nb. 子空间 $\\mscr E(k,j)$ 使用 $\\mscr E(j,m)$ 有不便之处。首先，维数 $g(j)$ 事先是不知道的。\n引入了另外的一些子空间，即子空间 $\\mscr E(k,j)$。即将 $\\ket{k,j,m}$ 另行组成一个集合，其中 $k,j$ 有指定值。\n有简单性质：\n1、不论研究的是什么物理体系，也不论 $k$ 的数值如何，子空间的维数都是 $(2j+1)$\n2、子空间 $\\mscr E(k,j)$ 在 $J$ 的作用下具有整体不变性。因为 $J_z, J_+,J_-$ 的作用都不会改变 $k,j$ 的数值。\nc. 表示角动量算符的矩阵 由于换了空间，因此结构得到了很大的简化：\n\rimage-20211222233711644\r\n每一个这样的有限阶子矩阵都不依赖于 $k$，也不依赖于待研究的体系，只依赖于 $j$。\n\rimage-20211221205309810\r\n依靠这些式子，我们可以得到矩阵中的每个值：\n$$ \\begin{aligned} \u0026amp;\\left\\langle k, j, m\\left|J_{z}\\right| k^{\\prime}, j^{\\prime}, m^{\\prime}\\right\\rangle=m \\hbar \\delta_{k k^{\\prime}} \\delta_{j j^{\\prime}} \\delta_{m m^{\\prime}} \\nl \u0026amp;\\left\\langle k, j, m\\left|J_{\\pm}\\right| k^{\\prime}, j^{\\prime}, m^{\\prime}\\right\\rangle=\\hbar \\sqrt{j(j+1)-m^{\\prime}\\left(m^{\\prime} \\pm 1\\right)} \\delta_{k k^{\\prime}} \\delta_{j j^{\\prime}} \\delta_{m, m^{\\prime} \\pm 1} \\end{aligned} $$\n下面是矩阵 $(J_u)^{(j)}$ 的一些例子：\n(i) $j=0$\n值为 0\n(ii) $j=1/2$\n基矢的顺序 $m=1/2,-1/2$\n$$ \\begin{array}{c} \\left(J_{z}\\right)^{(1 / 2)}=\\frac{\\hbar}{2}\\left(\\begin{array}{cc} 1 \u0026amp; 0 \\nl 0 \u0026amp; -1 \\end{array}\\right) \\nl \\left(J_{+}\\right)^{(1 / 2)}=\\hbar\\left(\\begin{array}{ll} 0 \u0026amp; 1 \\nl 0 \u0026amp; 0 \\end{array}\\right), \\quad\\left(J_{-}\\right)^{(1 / 2)}=\\hbar\\left(\\begin{array}{ll} 0 \u0026amp; 0 \\nl 1 \u0026amp; 0 \\end{array}\\right)\\nl \\left(J_{x}\\right)^{(1 / 2)}=\\frac{\\hbar}{2}\\left(\\begin{array}{ll} 0 \u0026amp; 1 \\nl 1 \u0026amp; 0 \\end{array}\\right), \\quad J_{y}^{(1 / 2)}=\\frac{\\hbar}{2}\\left(\\begin{array}{cc} 0 \u0026amp; -\\mathrm{i} \\nl \\mathrm{i} \u0026amp; 0 \\end{array}\\right) \\end{array} $$\n(iii) $j=1$\n基矢的顺序 $m=1,0,-1$\n$$ \\begin{array}{c} \\left(J_{z}\\right)^{(1)}=\\hbar\\left(\\begin{array}{ccc} 1 \u0026amp; 0 \u0026amp; 0 \\nl 0 \u0026amp; 0 \u0026amp; 0 \\nl 0 \u0026amp; 0 \u0026amp; -1 \\end{array}\\right) \\nl \\left(J_{+}\\right)^{(1)}=\\hbar\\left(\\begin{array}{ccc} 0 \u0026amp; \\sqrt{2} \u0026amp; 0 \\nl 0 \u0026amp; 0 \u0026amp; \\sqrt{2} \\nl 0 \u0026amp; 0 \u0026amp; 0 \\end{array}\\right), \\quad\\left(J_{-}\\right)^{(1)}=\\hbar\\left(\\begin{array}{ccc} 0 \u0026amp; 0 \u0026amp; 0 \\nl \\sqrt{2} \u0026amp; 0 \u0026amp; 0 \\nl 0 \u0026amp; \\sqrt{2} \u0026amp; 0 \\end{array}\\right) \\nl \\left(J_{x}\\right)^{(1)}=\\frac{\\hbar}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 \u0026amp; 1 \u0026amp; 0 \\nl 1 \u0026amp; 0 \u0026amp; 1 \\nl 0 \u0026amp; 1 \u0026amp; 0 \\end{array}\\right), \\quad\\left(J_{y}\\right)^{(1)}=\\frac{\\hbar}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 \u0026amp; -\\mathrm{i} \u0026amp; 0 \\nl \\mathrm{i} \u0026amp; 0 \u0026amp; -\\mathrm{i} \\nl 0 \u0026amp; \\mathrm{i} \u0026amp; 0 \\end{array}\\right) \\nl \\left(J^{2}\\right)^{(1)}=2 \\hbar^{2}\\left(\\begin{array}{ccc} 1 \u0026amp; 0 \u0026amp; 0 \\nl 0 \u0026amp; 1 \u0026amp; 0 \\nl 0 \u0026amp; 0 \u0026amp; 1 \\end{array}\\right) \\end{array} $$\n\rimage-20211222233645334\r\nComment 怪我前面没学懂，角动量这张关于空间的论述实在是太过于数学、也太难理解了 qwq。只能尽量讲讲现在的感受，以后有什么改进再修改吧。\n1、首先定义了角动量的算符，以及他们之间的关系。（或者是依据符合某些关系而定义了什么是角动量算符）\n2、角动量算符的 ECOC 以及他们的本征值。\n3、通过定义 $L_+,L_-$ 两个算符对角动量算符的性质进行探讨。\n4、开始研究角动量的结构，并定义出一系列标准基。\n","date":"2021-12-16T23:38:26+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-6-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%AD%E8%A7%92%E5%8A%A8%E9%87%8F%E7%9A%84%E6%99%AE%E9%81%8D%E6%80%A7%E8%B4%A8-abc-part/","title":"[量子力学] 6 量子力学中角动量的普遍性质 ABC part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} % 换行最后使用 \\nl 来避免 markdown 对 \\nl 的转义 \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def\\lam{\\lambda} \\def\\dbar{\\mathrm{đ}} $$\n7 近独立子系组成的系统 7.1 分布与系统的微观态 最可几分布 7.1.1 近独立子系 子系是组成系统的基本单元，它可以是气体中的分子，金属中的传导电子，热辐射场中的光子等 ；也可以代表粒子的某一个自由度 ；此外，在某些理论处理中，还可以把系统分成许多宏观大小的部分，把每一部分看成一个子系，等等。\n系统的总能量等于各个粒子的能量 $\\ve_i$ 之和： $$ E=\\sum^N_{i=1}\\ve_i $$ 则称这种系统为近独立子系（almost independent sub-system）组成的系统，有的书上用 “ 独立粒子系统 ” 或 “ 自由粒子系统 ”，意思实际上是一样的，想表达的都是假如粒子之间完全没有相互作用，粒子之间就不可能交换能量，系统就不可能达到平衡并保持平衡。\n7.1.2 粒子按能级的分布 $\\{a_\\lambda\\}$ 令粒子的能级为 $\\ve_1,\\ve_2,\\cdots,\\ve_\\lambda,\\cdots$，它们从低到高顺序排列。相应的，各个能级的简并度为 $g_1,g_2,\\cdots,g_\\lambda,\\cdots$（即每个能级上有多少种量子态），令 $a_1,a_2,\\cdots,a_\\lambda,\\cdots$ 代表这些能级上占据的粒子数，称为粒子按能级的微观分布，简记为 $\\{a_\\lambda\\}$。\n在一定的宏观状态下，允许出现的微观分布有许许多多 。现在考虑处于平衡态的孤立系，此时系统的总能量 $E$，体积 $V$，总粒子数 $N$ 都是固定的，此时应满足两个条件： $$ \\begin{aligned} \u0026amp;\\sum_\\lambda a_\\lambda=N \\nl \u0026amp;\\sum_\\lambda \\ve_\\lambda a_\\lambda=E \\end{aligned} $$\n7.1.3 分布 $\\{a_\\lambda\\}$ 对应的系统微观状态数 $W(\\{a_\\lambda\\})$ 分布与系统微观状态数是不同的概念。分布仅确定了每一个能级 $\\ve_i$ 上的粒子数 $a_i$，而系统微观状态要求确定处于每一个量子态上的粒子数（意思就是说，一个能级上可能有多个量子态），即在确定了能级 $\\ve_i$ 上的粒子数 $a_i$ 后，还需要确定量子态 $g_i$ 上粒子数的分布。\n一个特定的微观分布 $\\{a_\\lambda\\}$ 对应于许许多多系统的量子态。\n根据等几率原理，某一微观分布对应的系统微观态数越多，它出现的概率越大。令 $P(\\{a_\\lambda\\})$ 代表微观分布 $\\{a_\\lambda\\}$ 出现的概率，则： $$ P(\\{a_\\lambda\\})\\propto W(\\{a_\\lambda\\}) $$ $W(\\{a_\\lambda\\})$ 代表未归一化的相对几率，称为热力学几率。目前我们只需要知道 $W(\\{a_\\lambda\\})$ 是分布的函数就够了。\n7.1.4 最可几分布法 统计平均： $$ \\bar{a}_\\lambda=\\sum_{\\{a_\\lambda\\}}a_\\lambda P(\\{a_\\lambda\\}) $$ 最可几分布法是从一定宏观状态下所有可能出现的微观分布中，找出出现几率最大的那个分布。倘若最可几分布出现的几率，比起其他分布的几率占有压倒优势 ；那么，最可几分布应该就等于平均分布。可以证明，当系统的粒子数目很大时，最可几分布与平均分布相同。\n7.2 定域子系 麦克斯韦 - 玻尔兹曼分布 7.2.1 分布 $\\{a_\\lambda\\}$ 对应的系统量子态数 $W(\\{a_\\lambda\\})$ 对于全同的定域子系，粒子是可分辨的，我们可以给粒子加上标号：$1, 2, \\cdots,N$。\n系统量子态数为： $$ W(\\{a_\\lambda\\})=\\frac{N!}{\\prod \\limits_\\lambda a_\\lambda !}\\prod_\\lambda g_\\lambda^{a_\\lambda} $$ 解释：$g_\\lambda^{a_\\lambda}$ 代表的含义是 $a_\\lambda$ 个粒子在 $\\ve_\\lam$ 能级上的 $g_\\lam$ 个不同的粒子量子态中不同的占据方式。连乘 $\\prod \\limits_\\lam$ 代表不同能级上的量子态分布。\n各能级之间的粒子也可以交换，$N$ 个粒子的交换数是 $N!$，且应除去 $a_\\lam$ 各能级的交换数 $\\prod_\\limits\\lam a_\\lam$ 。\n7.2.2 最可几分布的推导 为了数学上的方便，把求 $W$ 的极大改为求 $\\ln W$ 的极大。两者完全等价。\n斯特林公式： $$ m!=m^me^{-m}\\sqrt{2\\pi m} $$ 取对数： $$ \\ln m!=m(\\ln m-1)+\\frac{1}{2}\\ln(2\\pi m) $$ 当 $m$ 很大时，$\\ln m \\ll m$，那么最后一项可以忽略，即： $$ \\ln m!=m(\\ln m-1) $$ 应用到 $\\ln W$，得： $$ \\begin{aligned} \\ln W(\\{a_\\lam\\})\u0026amp;=N(\\ln N-1)-\\sum_\\lam a_\\lam(\\ln a_\\lam-1)+\\sum_\\lam a_\\lam \\lg g_\\lam\\nl \u0026amp;=N\\ln N-\\sum_\\lam a_\\lam \\ln(\\frac{a_\\lam}{g_\\lam}) \\end{aligned} $$ 求最可几几率，就是在满足其他条件得情况下，使得 $\\delta \\ln W=0,\\delta^2 \\ln W\u0026lt;0$ 的分布。数学上是以 $a_1,a_2,\\cdots,a_\\lam,\\cdots$ 为变数的多元函数的极值。 $$ \\delta \\ln W(\\{a_\\lambda\\})=-\\sum_\\lam\\ln(\\frac{a_\\lam}{g_\\lam})\\delta a_\\lam=0 $$ 限制条件： $$ \\begin{aligned} \u0026amp;\\delta N=\\sum_\\lam\\delta a_\\lam=0\\nl \u0026amp;\\delta E=\\sum_\\lam\\ve_\\lam\\delta a_\\lam=0 \\end{aligned} $$ 应用求多元函数条件极值的拉格朗日未定乘子法。引入两个拉格朗日乘子 $\\alpha,\\beta$ $$ \\delta\\ln W-\\alpha\\delta N-\\beta\\delta E=-\\sum_\\lam (\\ln \\frac{a_\\lam}{g_\\lam}+\\alpha+\\beta\\ve_\\lam) \\delta a_\\lam=0 $$ 拉格朗日乘子法： $$ \\ln \\frac{a_\\lam}{g_\\lam}+\\alpha+\\beta\\ve_\\lam=0 $$ 用符号 $\\tilde{a}_\\lam$ 代表上面的分布（以区分微观分布 $a_\\lam$），改写为： $$ \\tilde{a}_\\lam=g_\\lam e^{-\\alpha-\\beta\\ve_\\lam} $$ 求二阶导： $$ \\delta^2\\ln W=-\\sum_\\lam\\frac{(\\delta a_\\lam)^2}{a_\\lam}\u0026lt;0 $$ 因此 $\\tilde{a}_\\lam$ 为最可几分布，称为麦克斯韦-玻尔兹曼分布，记为 MB 分布。\n7.2.3 $\\ln W(\\{a_\\lambda\\})$ 是尖锐成峰的极大 反正是一堆证明。这里用一张图说明一切吧：\n\rimage-20211212215559845\r\n因此，以后可以将 $\\bar{a}_\\lam=\\tilde{a}_\\lam$。\n7.2.4 麦克斯韦-玻尔兹曼分布中参数 $\\alpha,\\beta$ 的确定 确定方法： $$ \\begin{aligned} \u0026amp;N=\\sum_\\lam g_\\lam e^{-\\alpha-\\beta\\ve_\\lam}\\nl \u0026amp;E=\\sum_\\lam\\ve_\\lam g_\\lam e^{-\\alpha-\\beta\\ve_\\lam} \\end{aligned} $$ 引进函数 $Z$： $$ Z=\\sum_\\lam g_\\lam e^{-\\beta\\ve_\\lam} $$ 称为子系配分函数，是 $\\beta$ 及其他宏观参量的函数。\n由第一条式子得： $$ \\alpha=\\ln\\frac{Z}{N} $$ 消去 $\\alpha$，得： $$ E=-N\\frac{\\par}{\\par \\beta}\\ln Z $$\n7.3 二能级系统 讨论一个简单例子：二能级系统。\n这个系统只有两个能级，$\\ve_1=-\\ve,\\ve_2=\\ve$，且每个能级只有一个量子态，$g_1=g_2=1$，计算子系按能级的平均分布， 系统的内能与热容 。\n这种系统有一个例子是稀磁系统。\n子系配分函数： $$ Z=\\sum_\\lam g_\\lam e^{-\\beta\\ve_\\lam}=e^{\\beta \\ve}+e^{-\\beta\\ve} $$ 参数 $\\alpha$ 的确定： $$ e^{-\\alpha}=\\frac{N}{Z}=\\frac{N}{e^{\\beta \\ve}+e^{-\\beta\\ve}} $$ 平均分布： $$ \\begin{aligned} \u0026amp;\\bar{a}_{1}=1 \\cdot \\mathrm{e}^{-\\alpha-\\beta \\varepsilon_{1}}=N \\frac{\\mathrm{e}^{\\beta \\varepsilon}}{\\mathrm{e}^{\\beta \\varepsilon}}+\\mathrm{e}^{-\\beta \\varepsilon} \\nl \u0026amp;\\bar{a}_{2}=1 \\cdot \\mathrm{e}^{-\\alpha-\\beta \\varepsilon_{2}}=N \\frac{\\mathrm{e}^{-\\beta \\varepsilon}}{\\mathrm{e}^{\\beta \\varepsilon}}+\\mathrm{e}^{-\\beta \\varepsilon} \\end{aligned} $$ 式中 $\\beta=\\frac{1}{kT}$。显然，有限温度下 $\\bar a_1\u0026gt;\\bar a_2$。 $$ \\begin{array}{l} \\text { 当 } T \\rightarrow 0(\\beta \\rightarrow \\infty): \\bar{a}_{1}=N, \\bar{a}_{2}=0 ; \\nl \\text { 当 } T \\rightarrow \\infty(\\beta \\rightarrow 0): \\bar{a}_{1}=\\frac{N}{2}, \\bar{a}_{2}=\\frac{N}{2} \\end{array} $$ \rimage-20211213120251466\r\n根据麦克斯韦-玻尔兹曼分布的公式，得到粒子占据 $\\ve_\\lam$ 上每一个量子态的几率 $p_\\lam$ 为： $$ p_\\lam=\\frac{1}{Z}e^{-\\beta\\ve_\\lam} $$ 即： $$ p_\\lam\\propto e^{-\\beta e_\\lam}=e^{-\\ve_\\lam/kT} $$ $e^{-\\ve_\\lam/kT}$ 被称为玻尔兹曼因子。\n对于二能级系统， 高低二能级占据粒子数之比为： $$ \\frac{\\bar{a}_{2}}{\\bar{a}_{1}} \\sim \\mathrm{e}^{-\\Delta \\varepsilon / k T} $$\n其中 $\\Delta\\ve=\\ve_2-\\ve_1=2\\ve$\n温度极限： $$ \\begin{aligned} \u0026amp;\\frac{\\bar{a}_{2}}{\\bar{a}_{1}} \\sim 1 \u0026amp; (k T \\gg \\Delta \\varepsilon) \\nl \u0026amp;\\bar{a}_{2} \\sim 0 \u0026amp; (k T \\ll \\Delta \\varepsilon) \\end{aligned} $$ 内能： $$ \\begin{aligned} \\bar{E} \u0026amp;=\\sum_{\\lambda} \\varepsilon_{\\lambda} \\bar{a}_{\\lambda}=\\varepsilon_{1} \\bar{a}_{1}+\\varepsilon_{2} \\bar{a}_{2} \\nl \u0026amp;=-N \\varepsilon \\frac{\\mathrm{e}^{\\beta \\varepsilon}-\\mathrm{e}^{-\\beta \\varepsilon}}{\\mathrm{e}^{\\beta \\varepsilon}+\\mathrm{e}^{-\\beta \\varepsilon}}=-N \\varepsilon \\tanh \\left(\\frac{\\varepsilon}{k T}\\right) \\end{aligned} $$ 热容： $$ C=\\frac{\\partial \\bar{E}}{\\partial T}=N k\\left(\\frac{\\Delta \\varepsilon}{k T}\\right)^{2} \\frac{1}{\\left(\\mathrm{e}^{\\varepsilon / k T}+\\mathrm{e}^{-\\varepsilon / k T}\\right)^{2}} $$ 在 $T\\ra 0$ 的极限下： $$ C=N k\\left(\\frac{\\Delta \\varepsilon}{k T}\\right)^{2} \\mathrm{e}^{-\\Delta \\varepsilon / k T} \\rightarrow 0 $$\n7.4 定域子系热力学量的统计表达式 熵的统计解释 本节将从定域子系平衡态下的平均分布出发，导出各热力学量的统计表达式。\n热力学量分两类：一类是内能、外界作用力，有直接的微观量，直接利用 $\\bar{a}_\\lam$ 求统计平均就能得到。\n另一类如熵、热量，它们没有明显对应的微观量，可以通过与热力学公式类比的办法来建立。\n7.4.1 内能 内能是系统微观总能量的统计平均值。 $$ \\begin{aligned} U \u0026amp;=E=\\sum_{\\lambda} \\varepsilon_{\\lambda} \\bar{a}_{\\lambda}=\\sum_{\\lambda} \\varepsilon_{\\lambda} g_{\\lambda} \\mathrm{e}^{-\\alpha-\\beta \\varepsilon_{\\lambda}}=\\mathrm{e}^{-\\alpha} \\sum_{\\lambda} \\varepsilon_{\\lambda} g_{\\lambda} \\mathrm{e}^{-\\beta \\varepsilon_{\\lambda}} \\nl \u0026amp;=\\frac{N}{Z}\\left(-\\frac{\\partial}{\\partial \\beta} \\sum_{\\lambda} g_{\\lambda} \\mathrm{e}^{-\\beta \\varepsilon_{\\lambda}}\\right)=-N \\frac{\\partial}{\\partial \\beta} \\ln Z \\end{aligned} $$\n7.4.2 外界作用力 $$ \\dbar W=\\sum_\\lam \\bar{Y}_\\lam \\dd y_\\lam $$\n$y_\\lam$ 为广义坐标，外界作用力为 $\\bar{Y}_\\lam$。\n考虑微观过程中，外界对系统做的功 $\\sum_\\lam Y_\\lam \\dd y_\\lam$ 等于系统微观总能量的增加，即： $$ \\sum_\\lam Y_\\lam \\dd y_\\lam=\\sum_\\lam \\frac{\\par E}{\\par y_\\lam} \\dd y_\\lam $$ 即： $$ Y_\\lam=\\frac{\\par E}{\\par y_\\lam}=\\sum_\\lam \\frac{\\par \\ve_\\lam}{\\par y_\\lam} a_\\lam\\ (\\text{近独立子系组成的系统}) $$ 求平均值： $$ \\begin{aligned} \\bar{Y}_{\\lambda} \u0026amp;=\\sum_{\\lambda} \\frac{\\partial \\varepsilon_{\\lambda}}{\\partial y_{\\lambda}} \\bar{a}_{\\lambda}=\\sum_{\\lambda} \\frac{\\partial \\varepsilon_{\\lambda}}{\\partial y_{\\lambda}} g_{\\lambda} \\mathrm{e}^{-\\alpha-\\beta \\varepsilon_{\\lambda}} \\nl \u0026amp;=\\frac{N}{Z} \\sum_{\\lambda} \\frac{\\partial \\varepsilon_{\\lambda}}{\\partial y_{\\lambda}} g_{\\lambda} \\mathrm{e}^{-\\beta \\varepsilon_{\\lambda}}=\\frac{N}{Z}\\left(-\\frac{1}{\\beta} \\frac{\\partial}{\\partial y_{\\lambda}} \\sum_{\\lambda} g_{\\lambda} \\mathrm{e}^{-\\beta \\varepsilon_{\\lambda}}\\right) \\nl \u0026amp;=-\\frac{N}{\\beta} \\frac{\\partial}{\\partial y_{\\lambda}} \\ln Z \\end{aligned} $$\n7.4.3 热量的统计表达式 $$ \\dbar Q= \\dd \\bar{E}-\\sum_\\lam \\bar{Y}_\\lam \\dd y_\\lam $$\n代入 $\\bar{E}=\\sum_\\lam \\ve_\\lam \\bar{a}_\\lam$： $$ \\begin{aligned} \\mathrm{\\dbar} Q \u0026amp;=\\mathrm{d}\\left(\\sum_{\\lambda} \\varepsilon_{\\lambda} \\bar{a}_{\\lambda}\\right)-\\sum_{\\lambda} \\bar{Y}_{\\lambda} \\mathrm{d} y_{\\lambda} \\nl \u0026amp;=\\sum_{\\lambda} \\mathrm{d} \\varepsilon_{\\lambda} \\cdot \\bar{a}_{\\lambda}+\\sum_{\\lambda} \\varepsilon_{\\lambda} \\cdot \\mathrm{d} \\bar{a}_{\\lambda}-\\sum_{\\lambda} \\bar{Y}_{\\lambda} \\mathrm{d} y_{\\lambda} \\end{aligned} $$ 由于 $\\dd \\ve_\\lam=\\sum_\\lam\\frac{\\par \\ve_\\lam}{y_\\lam}\\dd y_\\lam$： $$ \\begin{aligned} \\sum_{\\lambda} \\mathrm{d} \\varepsilon_{\\lambda} \\cdot \\bar{a}_{\\lambda} \u0026amp;=\\sum_{\\lambda}\\left(\\sum_{\\lambda} \\frac{\\partial \\varepsilon_{\\lambda}}{\\partial y_{\\lambda}} \\mathrm{d} y_{\\lambda}\\right) \\bar{a}_{\\lambda} \\nl \u0026amp;=\\sum_{\\lambda}\\left(\\sum_{\\lambda} \\frac{\\partial \\varepsilon_{\\lambda}}{\\partial y_{\\lambda}} \\bar{a}_{\\lambda}\\right) \\mathrm{d} y_{\\lambda} \\nl \u0026amp;=\\sum_{\\lambda}^{\\prime} \\bar{Y}_{\\lambda} \\mathrm{d} y_{\\lambda} . \\end{aligned} $$ 因此： $$ \\mathrm{d} Q=\\sum_{\\lambda} \\varepsilon_{\\lambda} \\mathrm{d} \\bar{a}_{\\lambda} $$ 这意味着：凡是平均分布不发生改变的过程是绝热过程。即在绝热过程中，外参量的变化导致粒子能级的变化，但不改变平均分布。\n7.4.4 熵的统计分布 $$ \\dd S=\\frac{\\dbar Q}{T}=\\frac{1}{T}(\\dd \\bar{E}-\\sum_\\lam \\bar{Y}_\\lam \\dd y_\\lam) $$\n这条式子告诉我们，虽然 $\\dbar Q$ 不是全微分，但是乘 $\\frac{1}{T}$ 后就变成了全微分。即 $\\frac{1}{T}$ 是 $\\dbar Q$ 的积分因子。\n这意味着我们可以反向考虑，证明 $\\dbar Q$ 存在积分因子，就能引入熵的存在。 $$ \\begin{aligned} \\beta\\left(\\mathrm{d} \\bar{E}-\\sum_{\\lambda} \\bar{Y}_{\\lambda} \\mathrm{d} y_{\\lambda}\\right)=\u0026amp;-N \\beta \\mathrm{d}\\left(\\frac{\\partial}{\\partial \\beta} \\ln Z\\right)+N \\sum_{\\lambda} \\frac{\\partial}{\\partial y_{\\lambda}} \\ln Z \\cdot \\mathrm{d} y_{\\lambda} \\nl =\u0026amp;-N \\mathrm{~d}\\left(\\beta \\frac{\\partial}{\\partial \\beta} \\ln Z\\right)+N \\frac{\\partial}{\\partial \\beta} \\ln Z \\cdot \\mathrm{d} \\beta \\nl \u0026amp;+N \\sum_{\\lambda} \\frac{\\partial}{\\partial y_{\\lambda}} \\ln Z \\cdot \\mathrm{d} y_{\\lambda} \\nl =\u0026amp; N \\mathrm{~d}\\left(\\ln Z-\\beta \\frac{\\partial}{\\partial \\beta} \\ln Z\\right) \\end{aligned} $$ 右方是全微分，这就证明了 $\\beta$ 是微分式 $\\mathrm{d} \\bar{E}-\\sum_{\\lambda} \\bar{Y}_{\\lambda} \\mathrm{d} y_{\\lambda}$ 的积分因子。\n对比，我们可以发现： $$ \\beta=\\frac{1}{kT} $$ $k$ 是一个普适常数，经过实验可以测得：$k=1.38\\times10^{-23}~ \\un{J\\cdot K^{-1}}$，称为玻尔兹曼常数。\n代回 $\\dd S$ 式： $$ \\dd S=Nk \\mathrm{~d}\\left(\\ln Z-\\beta \\frac{\\partial}{\\partial \\beta} \\ln Z\\right) $$ 积分并取 $S_0=0$： $$ S=Nk(\\ln Z-\\beta\\frac{\\par}{\\par \\beta}\\ln Z) $$ 至此，已经得出了三个基本热力学函数，其他的热力学量也就一并确定了。\n7.4.5 玻尔兹曼关系 熵的统计解释 $$ \\ln W(\\{a_\\lam\\})=N\\ln N-\\sum_\\lam a_\\lam\\ln(\\frac{a_\\lam}{g_\\lam}) $$\n换成平均分布，上式也成立： $$ \\ln W(\\{\\bar a_\\lam\\})=N\\ln N-\\sum_\\lam \\bar a_\\lam\\ln(\\frac{\\bar a_\\lam}{g_\\lam}) $$ 代入平均分布的表达式： $$ \\ln W(\\{\\bar a_\\lam\\})=N\\ln N-\\sum_\\lam \\bar a_\\lam(-\\alpha-\\beta\\ve_\\lam)=N\\ln N+\\alpha N+\\beta \\bar{E} $$ 代入 $\\alpha,\\bar E$，得： $$ \\ln W(\\{\\bar a_\\lam\\})=N(\\ln Z-\\beta\\frac{\\par }{\\par \\beta}\\ln Z) $$ 与熵的公式比较，发现： $$ S=k\\ln W(\\{\\bar a_\\lam\\}) $$ 此式称为玻尔兹曼关系。\n玻尔兹曼关系把熵与热力学几率直接联系起来 ： 热力学几率越大，熵也越大 。由此可以给熵一个统计解释 ： 熵代表系统的混乱度 （ 或无序度 ）。热力学几率越大，即相应的微观状态数越多，代表系统越混乱。\nComment 这一部分涉及到了上一章提出的统计物理学的一个数学表述（近独立子系条件下）：\n1、引入粒子分布 $\\{a_\\lambda\\}$ 和系统微观状态数 $W(\\{a_\\lambda\\})$ 两个概念。代表了许许多多不同的分布。\n2、粒子分布的最可几分布，即某个粒子分布出现概率最高的分布。并证明了这个分布在粒子数很大的时候相当于平均分布，即这种分布在宏观上的表现。\n3、对最可几分布中的系数 $\\alpha,\\beta$ 的求解。\n4、使用统计物理学对热力学中的宏观量的求解。如内能、熵、温度等。\n5、对熵的解释（玻尔兹曼公式）。\n附录：一点数学 1 拉格朗日乘子法 是一种寻找多元函数在一定条件约束下的极值的方法。\n假设约束条件为 $g(\\vec{x})=0$，函数为 $f(\\vec{x})$。\n简单理解一下方法：首先画出约束条件 $g(\\vec{x})=0$ 的曲面，然后不断改变函数 $f(\\vec x)$ 的值，使得其与约束条件的曲面相切（即 $\\nabla f(\\vec x_0)+\\lambda\\nabla g(\\vec x_0)=0$，法线平行且交于同一点）,那么此点的值为极值。\n联立的方程式为： $$ \\left\\{\\begin{array}{l} \\nabla f(\\mathbf{x})=\\lambda \\nabla g(\\mathbf{x}) \\nl g(\\mathbf{x})=0 \\end{array}\\right. $$ 然后再求解即可。\n拉格朗日乘子法还有一个变形：\n令 $F=f-\\lambda g$，然后求解方程组： $$ \\begin{array}{l} \\nabla F= 0 \\nl \\frac{\\par F}{\\par \\lam} = 0 \\end{array} $$ 当然，也可以用于多种约束： $$ \\begin{array}{l} \\nabla f=\\lambda \\nabla g+\\mu \\nabla h \\nl g(\\mathbf{x})=0 \\nl h(\\mathbf{x})=0 \\end{array} $$\n2 积分因子 假设有一微分方程： $$ \\frac{\\dd y}{\\dd x}=f(x,y)=-\\frac{P(x,y)}{Q(x,y)}\\Ra P\\dd y+Q\\dd x=0 $$ 假设存在一个可微函数 $\\Phi(x,y)$，使得： $$ \\dd \\Phi=P\\dd y+Q\\dd x $$ 那么根据全微分： $$ \\frac{\\par \\Phi}{\\par x}=P,\\frac{\\par \\Phi}{\\par y}=Q $$ 那么 $\\Phi(x,y)=C$ 就是上述方程的通积分曲线。\n判定一个给定的微分方程是或不是恰当方程的充分条件： $$ \\frac{\\partial P}{\\partial y}=\\frac{\\partial^{2} \\Phi}{\\partial y \\partial x} = \\frac{\\partial^{2} \\Phi}{\\partial x \\partial y} = \\frac{\\partial Q}{\\partial x} $$ 构造 $\\Phi(x,y)$ 函数的方法： $$ \\Phi(x, y)=\\int_{x_{0}}^{x} P(x, y) \\mathrm{d} x+\\int_{y_{0}}^{y} Q\\left(x_{0}, y\\right) \\mathrm{d} y $$ 但如果有符合微分方程形式（即 $P\\dd y+Q\\dd x=0$）却判定不是恰当方程（$\\frac{\\partial P}{\\partial y}\\ne\\frac{\\partial Q}{\\partial x}$）时，就应该给微分方程乘上一个系数 $\\mu(x,y)$，使得： $$ \\frac{\\partial (\\mu P)}{\\partial y}=\\frac{\\partial (\\mu Q)}{\\partial x} $$ 这个系数就称为积分因子。\n积分因子有很多求法，例如初等变换法、直接求积法、束缚+复合函数形式的积分因子、分部求积分因子。\n","date":"2021-12-12T17:13:15+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-7-%E8%BF%91%E7%8B%AC%E7%AB%8B%E5%AD%90%E7%B3%BB%E7%BB%84%E6%88%90%E7%9A%84%E7%B3%BB%E7%BB%9F-i/","title":"[热统] 7 近独立子系组成的系统 I"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def\\dbar{\\mathrm{đ}} $$\n6 统计物理学的基本概念 6.1 统计物理学的研究对象、目的与方法 热力学是热现象的宏观理论。本章将会介绍热现象的微观理论——统计物理学。\n统计物理学考虑宏观物体是由大量微观粒子组成的， 从物体的微观组成与结构出发 ，其研究目的是从**系统的微观性质出发研究和计算宏观性质 **。\n热力学的基础是经验概括的三条基本定律，统计物理学的基础除了描述微观粒子运动的量子力学外， 还需要统计假设。 热力学与统计物理学的研究方法也不同 。 前者以三条基本定律为基础作演绎推论； 后者从物体的微观组成和结构出发，把宏观性质看成微观性质的统计平均， 采用统计平均的方法。\n这本书直接使用量子统计，把经典统计作为量子统计的极限来介绍。\n6.2 微观状态的经典描写与量子描写 下面先介绍以经典力学为基础的经典描写，再介绍以量子力学为基础的量子描写。 虽然微观粒子的运动遵 从量子力学，但作为极限，经典描写在一定条件下仍是正确的。\n6.2.1 微观状态的经典描写 微观状态 （ 或力学运动状态 ） 的经典描写以经典力学为基础 ，通常采用正则形式，即用广义坐标（$q_i$）与广义动量（$p_i$）来描写。\n一般地说，我们把组成宏观物体的基本单元称为子系，它可以是气体中的分子，固体中的原子，也可以是粒子的某一个自由度。\n如果子系有 $r$ 个自由度，那么其微观状态需要 $2r$ 个变量来描写。子系的能量表达式为：\n$$ \\ve=\\ve(q_1,q_2,\\cdots,q_r;p_1,p_2,\\cdots,p_r) $$\n将 $r$ 个坐标和 $r$ 个动量组成一个 $2r$ 维空间，称为子相空间（$\\mu$ 空间）。子系的一个力学运动状态对应于子相空间中的一个点，子系运动状态的微小范围用 $\\dd \\omega$ （子相体元）表示：\n$$ \\dd \\omega=\\dd q_1\\cdots\\dd q_r \\dd p_1\\cdots\\dd p_r $$\n整个系统的情况和子系微观状态的情况类似。若有 $N$ 个质点，每个质点有 3 个自由度，那么整个系统的总自由度为 $3N$， 需要用 $6N$ 个变量来描述。\n一般来说，若系统由 $N$ 个子系构成，每个子系的自由度为 $r$，整个系统的总自由度 $s=Nr$，则需要用 $2s$ 个广义坐标和广义动量描写力学运动状态。这 $2s$ 个变量构成的空间称为相空间（$\\Gamma$ 空间）。相元：\n$$ \\dd \\Omega=\\dd q_1\\cdots\\dd q_s \\dd p_1\\cdots\\dd p_s $$\n根据经典力学，微观状态可以连续变化，相应的力学量的取值也可以连续变化。 实际上微观粒子应遵从量子力学 ； 不过经典力学的描写在一定条件下作为量子力学的极限仍是适用的。\n6.2.2 微观状态的量子描写 目前仅需知道的量子力学知识点（当然量子力学一起学会更好）：\n1、微观状态是一些量子态，可以用一个或一组量子数标志 ，相应的微观力学量 （ 如能量、动量等 ） 的取值是不连续的，或者说是量子化的。\n如边长为 $L$ 的正方形容器中的自由粒子以及一维谐振子。\n2、\n全同粒子系统、全同性原理：\n所谓全同粒子是指它们的内禀性质（ 如质量、电荷、自旋等 ） 完全相同 。量子力学有一条基本规律，称为全同性原理。 它可以简单表述为：全同粒子的交换不引起新的系统的量子态 ，或者说全同粒子是不可分辨的。\n费米子与玻色子：\n粒子自旋为 $\\hbar$ 的整数倍的粒子（自旋为 $s\\hbar, s=1,2,\\cdots$ 的粒子）称为玻色子（boson），如光子 $s=1$， $\\pi$ 介子 $s=0$ 等。其波函数是交换对称的，遵从玻色-爱因斯坦分布（Bose-Einstein）。\n粒子自旋为 $\\hbar$ 的半整数倍的粒子（$s=1/2,3/2,\\cdots$）称为费米子（fermion），例如轻子、质子、中子（都是 $s=1/2$）。其波函数是交换反对称的，遵从费米-狄拉克（Fermi-Dirac）统计。\n对于复合粒子， 如果是由偶数个费米子或由玻色子构成的，则为玻色子。如氢原子$\\un H$，含 $\\un{p,e}$ 。 由奇数个费米子构成的则为费米子，如氘，含 $\\un{p,n,e}$。\n泡利不相容原理：\n全同费米子系统遵从一条重要的规律，称为泡利不相容原理： 不允许有两个全同的费米子处于同一个单粒子量子态。如在原子中不能存在相同的电子（？）\n3、 定域子系\n全同多粒子系统在某些特殊情况下， 全同性原理不起作用， 这时全同粒子仍然是可以分辨的（distinguishable）。\n这种特殊情况是指各个粒子的波函数分别局限在空间不同的范围内，彼此没有重叠。 在这种情况下，虽然不能从粒子的内禀性质去区分它们，但可以从粒子所处的不同位置对他们加以区分。 这种子系称为定域子系（localized sub-system）。\n4、子系的量子态与系统的量子态（全同多粒子系）\n（a）定域子系，粒子是可分辨的，因此有编号。每一子系量子态上占据的粒子数不受限制。\n（b）非定域玻色子，粒子不可分辨，因此没有编号。但每一子系量子态上占据的粒子数不受限制。\n（c）非定域费米子，粒子不可分辨及泡利原理。\n\rimage-20211212162852927\r\n6.3 宏观量的统计性质 统计规律性 6.3.1 宏观量的统计性质 统计物理学的基本观点是：宏观量是相应微观量的统计平均值。\n宏观观测有两个基本特点：一是空间尺度上是宏观小 （ 才有可能显示出宏观性质的空间变化 ）、 微观大 （ 仍包含足够大量的粒子 ）； 二是时间尺度上是宏观短 （ 才有可能显示宏观性质随时间的变化 ）、 微观长 （ 微观状态已经历足够多次变化 ）。\n6.3.2 统计规律性 由于热现象过程是不可逆的，因此不能存粹以力学为规律来解释统计物理学。\n宏观物体的性质和规律不可能纯粹以力学规律为基础来解释， 而有赖于新的规律，这就是统计规律，它可以表述为：在一定的宏观条件下，某一时刻系统以一定的几率处于某一微观运动状态。 宏观状态与微观状态之间的这种联系是几率性的，这是统计规律的特征。\n6.4 平衡态统计理论的基本假设：等几率原理 等几率原理是平衡态统计理论的基本假设。\n等几率原理的表述为：对于处于平衡态下的孤立系，系统各个可能的微观状态出现的几率相等。\n等几率原理目前还未证明成功，直到目前为止 ， 等几率原理仍然是一条基本假设 ， 是平衡态统计物理学唯一的基本假设。但其正确性已不容置疑。\nComment 这一章对统计物理学的一些基本原理作了概述和澄清。包括：\n1、统计物理学的研究对象\n2、微观状态的描写、量子统计的特性。\n3、宏观量与微观量的联系。\n4、等概率原理。\n","date":"2021-12-12T15:28:30+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-6-%E7%BB%9F%E8%AE%A1%E7%89%A9%E7%90%86%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"[热统] 6 统计物理学的基本概念"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def_{_} % 避免 下标符号 的转义。使用时应该先全部打好 下标符号，再用查找功能将其全部转换成 _ % 如果后面新增了内容用到了下标符号，则正则为： % 查找：([^])(_) 替换：$1\\$2 $$\n2 均匀系的平衡性质 2.1 麦克斯韦关系 2.1.1 麦克斯韦关系 勒让德变换 $$ \\dd U=T\\dd S-p\\dd V $$\n这就是热力学基本微分方程，它是热力学第一定律和热力学第二定律相结合对微小可逆过程的表达形式，集中概括了第一定律和第二定律对可逆过程的全部结果，是研究平衡性质的基础。\n导出全微分： $$ \\mathrm{d} U=\\left(\\frac{\\partial U}{\\partial S}\\right)_{V} \\mathrm{~d} S+\\left(\\frac{\\partial U}{\\partial V}\\right)_{S} \\mathrm{~d} V $$ 得到： $$ \\begin{aligned} \u0026amp;\\left(\\frac{\\partial U}{\\partial S}\\right)_{V}=T \\nl \u0026amp;\\left(\\frac{\\partial U}{\\partial V}\\right)_{S}=-p \\end{aligned} $$ 因 $T\u0026gt;0$，故 $(\\frac{\\partial U}{\\partial S})_V\u0026gt;0$，表示当体积不变时，内能与熵得变化倾向是相同的。\n有时把这两条式子称为麦克斯韦关系\n由于 $U$ 是态函数，因此对其两次微商的先后次序无关： $$ \\frac{\\partial^{2} U}{\\partial V \\partial S}=\\frac{\\partial^{2} U}{\\partial S \\partial V} $$ 因此： $$ \\left(\\frac{\\partial T}{\\partial V}\\right)_{S}=-\\left(\\frac{\\partial p}{\\partial S}\\right)_{V} $$ 这只是众多麦克斯韦关系式之一。\n勒让德变换： $$ x\\dd y=\\dd(xy)-y\\dd x $$ 如： $$ \\begin{aligned} \u0026amp;T\\dd S=\\dd(TS)-S\\dd T\\nl \u0026amp;\\Ra\\dd U=T\\dd S-p\\dd V=\\dd(TS)-S\\dd T-p\\dd V \\nl \u0026amp;\\Ra \\dd(U-TS)=\\dd F=-S\\dd T-p \\dd V \\end{aligned} $$ 因此得到关系式： $$ \\begin{aligned} \u0026amp;S=\\left(\\frac{\\partial F}{\\partial T}\\right)_{V} \\nl \u0026amp;p=-\\left(\\frac{\\partial F}{\\partial V}\\right)_{T} \\end{aligned} $$ $F$ 的麦克斯韦关系： $$ \\left(\\frac{\\partial S}{\\partial V}\\right)_{T}=\\left(\\frac{\\partial p}{\\partial T}\\right)_{V} $$ 总结表格：\n\rimage-20211210122326079\r\n当然也有其他的麦克斯韦关系，如 $\\dd S=\\frac{1}{T}\\dd U+\\frac{p}{T}\\dd V$，这是最重要的四个。\n2.1.2 简单应用 $(\\frac{\\par U}{\\par V})_T=?$ $$ \\dd U=T\\dd S-p\\dd V=T[(\\frac{\\par S}{\\par T})_V\\dd T+\\frac{\\par S}{\\par V})_T\\dd V] - p\\dd V $$ 因此： $$ (\\frac{\\par U}{\\par V})_T=T(\\frac{\\par S}{\\par V})_T-p=T(\\frac{\\par p}{\\par T})_V-p $$ 对于理想气体（$pV=NRT$）来说： $$ (\\frac{\\par p}{\\par T})_V=\\frac{p}{T} $$ 因此： $$ (\\frac{\\par U}{\\par V})_T=0 $$ 上式表明，理想气体的内能只是温度的函数，与体积无关。\n2.1.3 可测量量 可测量量有：\n1、状态变量（$p,V$ 等）。特殊的是 $T$，它是态函数，但可以直接测量，也常常作为状态变量。\n2、热容\n3、物态方程相联系的量。如如温度、体积、压强、电场、磁场等的变化。\n不可直接测量的量：\n1、基本热力学函数 $U,S$，辅助热力学函数 $H,F,G$ 等。\n2、以及它们的各种偏微分（刚好得到可测量量的偏微分除外）。\n2.2 气体的节流过程 焦耳-汤姆孙效应 2.3 绝热去磁降温的热力学理论 这两个是应用例子，暂时先不写\n2.4 热辐射的热力学理论 热力学定律不仅可以应用于实物组成的宏观系统 ， 还可以应用于热辐射场。\n从热力学观点来看，热辐射时一种特殊的 $p-V-T$ 系统。\n2.4.1 热辐射的内能密度是温度的普适函数 令 $u=U/V$ 代表热辐射单位体积的内能 ， 即内能密度。\n设有 A,B 两个空窖，窖内有热辐射。它们具有相同的温度 $T$，但它们的形状、大小和物质都不同。两个窖之间通过一根小导管联通，管道中放一个滤波片，只允许 $\\nu$ 到 $\\nu+\\dd\\nu$ 之间的辐射通过。\n\rimage-20211216163349502\r\n令 $u_A,u_B$ 代表 A,B 两窖内热辐射的内能密度，显然： $$ \\begin{aligned} \u0026amp;u_{A}=\\int_{0}^{\\infty} u_{A}(\\nu) \\mathrm{d} \\nu \\\n\u0026amp;u_{B}=\\int_{0}^{\\infty} u_{B}(\\nu) \\mathrm{d} \\nu \\end{aligned} $$ 使用热力学第二定律的开尔文表述反证得到（见书本）： $$ u_A(\\nu)=u_B(\\nu) $$ 结果证明内能密度与两窖的形状 、 大小以及窖壁物质均无关，就证明了 $u$ 是 $T$ 的普适函数。内能可表示为： $$ U=Vu(T) $$\n2.4.2 辐射压强与内能密度的关系 辐射压强与热辐射的内能密度之间存在下列关系: $$ p=\\frac{1}{3}u $$ 利用奇怪的辐射压证明（见书本）。\n2.4.3 热辐射的热力学函数 $$ \\dd U=T\\dd S-p\\dd V\\Ra \\left(\\frac{\\partial U}{\\partial V}\\right)_{T}=T\\left(\\frac{\\partial p}{\\partial T}\\right)_{V}-p $$\n对于热辐射，可以进行代换： $$ u=\\frac{1}{3}T\\frac{\\dd u}{\\dd T}-\\frac{u}{3}\\Ra \\frac{\\dd u}{u}=4\\frac{\\dd T}{T} $$ 积分： $$ u=aT^4\\Ra U=aT^4 V $$ 辐射压强： $$ p=\\frac{a}{3}T^4 $$ $p$ 和 $T$ 不独立，这是热辐射和 $p-V-T$ 系统不同的地方。\n熵： $$ \\dd S=\\frac{1}{T}(\\dd U+p\\dd V)=\\dd (\\frac{4}{3}aT^3V) $$ 积分得到（因 $V=0$ 时$S=0$ ，因此 $S_0=0$） $$ S=\\frac{4}{3}aT^3V $$ 热力学函数： $$ \\begin{array}{l} H \\equiv U+p V=\\frac{4}{3} a T^{4} V \\nl F \\equiv U-T S=-\\frac{1}{3} a T^{4} V \\nl G \\equiv U-T S+p V=F+p V=0 \\end{array} $$ $G=0$ 代表热辐射的化学势为零 ， 微观上代表热辐射的光子数不守恒。\n热容： $$ \\begin{aligned} \u0026amp;C_V=4aT^3V=3S \\nl \u0026amp;C_p=\\infty \\end{aligned} $$ 绝热过程方程： $$ VT^3=C $$\n2.5 气体的热力学函数 2.5.1 理想气体的热力学函数 物态方程： $$ pV=NRT $$ 内能： $$ U(T)=\\int C_V(T)\\dd T+U_0 $$ 熵： $$ \\dd S=\\frac{1}{T}\\dd U+\\frac{p}{T}\\dd V=C_V\\frac{\\dd T}{T}+NR\\frac{\\dd V}{V} $$ 积分： $$ S=\\int C_V\\frac{\\dd T}{T}+NR\\ln V+S_0 $$ 其他热力学方程： $$ H \\equiv U+p V=\\int C_{p} \\mathrm{~d} T+H_{0} \\quad\\left(H_{0}=U_{0}\\right) $$\n2.5.2 范德瓦耳斯气体的热力学函数 物态方程： $$ \\left(p+\\frac{a}{v^{2}}\\right)(v-b)=R T $$ 其他关系： $$ \\left(\\frac{\\partial c_{v}}{\\partial v}\\right)_{T}=T\\left(\\frac{\\partial^{2} p}{\\partial T^{2}}\\right)_{v}, \\text{where}~ (\\frac{\\par c_v}{\\par v})_T=0, c_v=c_v(T) $$ 内能与熵： $$ \\begin{aligned} \u0026amp;u(T, v)=\\int c_{v} \\mathrm{~d} T-\\frac{a}{v}+u_{0} \\nl \u0026amp;s(T, v)=\\int c_{v} \\frac{\\mathrm{d} T}{T}+R \\ln (v-b)+s_{0} \\end{aligned} $$\n2.6 基本热力学函数的确定 以 $p-V-T$ 系统为例： $$ \\begin{aligned} \u0026amp;p=p(T,V)\\nl \u0026amp;U=U(T,V)\\nl \u0026amp;S=S(T,V) \\end{aligned} $$ 选定 $(p,V)$ 作为独立变量。\n确定内能： $$ \\mathrm{d} U=\\left(\\frac{\\partial U}{\\partial T}\\right)_{V} \\mathrm{~d} T+\\left(\\frac{\\partial U}{\\partial V}\\right)_{T} \\mathrm{~d} V = C_{V} \\mathrm{~d} T+\\left[T\\left(\\frac{\\partial p}{\\partial T}\\right)_{V}-p\\right] \\mathrm{d} V $$ 积分，可得 $U$ 的值。\n求熵 $S$： $$ \\dd S=\\frac{1}{T}\\dd U+\\frac{p}{T}\\dd V=C_V\\frac{\\dd T}{T}+(\\frac{\\par p}{\\par T})_V\\dd V $$ 积分，可得 $S$ 的值。\n2.7 特性函数 在独立变量适当选择之下，只要一个热力学函数就可以确定均匀系的全部平衡性质。这个函数称为特性函数，它是表征均匀系的特性的，也有的书称为热力学势。\n注意，特性函数并不是什么新引入的态函数，而是适当选择独立变量之下的某一个热力学函数。\n一些例子：\n\rimage-20211212145037683\r\n证明其中之一： $(S,V)$ 为独立变量时，内能 $U(S,V)$ 能导出三个基本热力学函数，因此 $U(S,V)$ 是特性函数。\n基本微分方程： $$ \\dd U=T\\dd S-p\\dd V $$ 得： $$ T=(\\frac{\\par U}{\\par S})_V\\Ra T= T(S,V)\\Ra S=S(T,V) $$ 同理： $$ p=-(\\frac{\\par U}{\\par V})_S\\Ra p=p(S,V)\\Ra p =p(S(T,V),V)=p(T,V) $$ 最后： $$ U=U(S,V)=U(S(T,V),V)=U(T,V) $$ 我们从 $U=U(S,V)$ 出发，推导出了物态方程 $p=p(T,V)$，内能 $U=U(T,V)$ 和熵 $S=S(T,V)$。因此是特征函数。\n具体例子： $U=CS^{4/3}V^{-1/3}$ $$ \\begin{aligned} \u0026amp;T=(\\frac{\\par U}{\\par S})_V=\\frac{4C}{3}(\\frac{S}{V})^{1/3}\\nl \u0026amp;\\Ra S=(\\frac{3}{4C})^3T^3V \\nl \u0026amp;p=-(\\frac{\\par U}{\\par V})_S=\\frac{C}{3}(\\frac{S}{V})^{4/3}=\\frac{C}{3}(\\frac{3}{4C})^4 T^4\\nl \u0026amp;U=CS^{4/3}V^{-1/3}=C(\\frac{3}{4C})^4T^4 V\\nl \\end{aligned} $$\n2.8 可逆循环过程方法 研究平衡性质还有另一种方法，是热力学发展早期所采用的，可以称为可逆循环过程方法．它把热力学第一定律和第二定律应用到特别设计的可逆循环过程，对于该可逆循环过程，热力学第一定律与第二定律可表达为: $$ \\begin{aligned} \\oint \\mathrm{d} U=0 \\text { 或 }\u0026amp; \\oint \\mathrm{d} Q+\\oint \\mathrm{d} W=0 \\text {, } \\\n\\oint \\mathrm{d} S=0 \\text { 或 }\u0026amp; \\oint \\frac{\\mathrm{d} Q}{T}=0 . \\end{aligned} $$ 可逆循环过程方法的关键是设计一个可逆循环过程，通过计算，把待求的热力学量计算出来．设计可逆循环是关键，也是不大好掌握之处．而且不同的问题需要设计不同的循环过程，十分不方便。仅是提一下，有所了解。\nComment 这一张讲述了均匀系的一些应用，并引入了其他三个热力学函数。\n1、麦克斯韦关系，代表各种热力学量之间的关系\n2、焦耳-汤姆孙效应、绝热去磁降温的应用（待补充）\n3、热辐射的热力学理论（内能密度相等、$p=\\frac{1}{3}u$ 等性质）\n4、气体的热力学函数。将先前讲到的各种热力学函数应用到理想气体和范德瓦尔斯气体上。\n5、独立变量的重要性（确定热力学函数以及特征函数）。\n","date":"2021-12-10T12:11:00+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-2-%E5%9D%87%E5%8C%80%E7%B3%BB%E7%9A%84%E5%B9%B3%E8%A1%A1%E6%80%A7%E8%B4%A8-i/","title":"[热统] 2 均匀系的平衡性质 I"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\def_{} % 避免 下标符号 的转义。使用时应该先全部打好 下标符号，再用查找功能将其全部转换成 _ % 如果后面新增了内容用到了下标符号，则正则为： % 查找：([^\\])() 替换：$1\\$2 $$\nA 引言 1. 谐振子的重要性 谐振子的形式就是势能 $V(x)=\\frac{1}{2}kx^2$。\n反正就是在很多地方里面有用（\n2.经典力学的谐振子 $$ m\\frac{\\dd^2 x}{\\dd t^2}=-\\frac{\\dd V}{\\dd x}=-kx $$\n通解：\n$$ x=x_M\\cos(\\omega t-\\varphi) $$\n能量表达式：\n$$ E=T+V=\\frac{p^2}{2m}+\\frac{1}{2}m\\omega^2 x^2 $$\n\rimage-20211209203305798\r\n3.哈密顿算符一般性质 1、哈密顿算符的本征值都是正的。\n$$ V(x) \\ge V_m \\Ra E\u0026gt;V_m $$\n2、 $H$ 的本征函数具有确定的宇称。\n$$ V(-x) = V(x) $$\n3、能谱是离散的\nB Hamilton 算符的本征值 1.符号 a.算符 $\\widehat{X}, \\widehat{P}$ 观察算符 $X,P$ 是有量纲的。为了方便，定义没有量纲的两个可观测量：\n$$ \\begin{aligned} \\widehat{X}=\\sqrt{\\frac{m \\omega}{\\hbar}} X \\nl \\widehat{P}=\\frac{1}{\\sqrt{m \\hbar \\omega}} P \\end{aligned} $$\n这两个算符的正则对易关系：\n$$ [\\widehat{X}, \\widehat{P}]=i $$\nHamilton 算符的形式：\n$$ H=\\hbar \\omega \\widehat{H} $$\n其中：\n$$ \\widehat{H}=\\frac{1}{2}(\\widehat{X}^2 + \\widehat{P}^2) $$\n即将求解的本征值方程为：\n$$ \\widehat{H} \\ket{\\psi^i_\\nu}=\\ve\\ket{\\psi^i_\\nu} $$\nb.算符 $a,a^\\dagger$ 以及 $N$ 定义：\n$$ \\begin{aligned} a \u0026amp;=\\frac{1}{\\sqrt{2}}(\\widehat{X}+\\mathrm{i} \\widehat{P}) \\nl a^{\\dagger} \u0026amp;=\\frac{1}{\\sqrt{2}}(\\widehat{X}-\\mathrm{i} \\widehat{P}) \\end{aligned} $$\n易得：\n$$ \\begin{aligned} \\widehat{X}=\\frac{1}{\\sqrt{2}}\\left(a^{\\dagger}+a\\right) \\nl \\widehat{P}=\\frac{\\mathrm{i}}{\\sqrt{2}}\\left(a^{\\dagger}-a\\right) \\end{aligned} $$\n也就是说：\n$$ [a,a^\\dagger]=1 $$\n一些公式：\n$$ \\begin{aligned} \u0026amp; a^{\\dagger} a = \\frac{1}{2}\\left(\\widehat{X}^{2}+\\widehat{P}^{2}-1\\right) \\nl \u0026amp;\\widehat{H} = a^\\dagger a+\\frac{1}{2} = aa^\\dagger-\\frac{1}{2} \\nl \\end{aligned} $$\n引入算符 $N=a^\\dagger a$，它是一个 Hermite 算符。\n一些性质：\n$$ \\begin{aligned} \u0026amp;[N,a]=-a\\nl \u0026amp;[N,a^\\dagger] = a^\\dagger \\nl \u0026amp;\\widehat{H}=N + \\frac{1}{2} \\end{aligned} $$\n因此，算 $\\widehat{H}$ 的本征值方程可以换成 $N$ 的本征值方程：\n$$ \\widehat{N} \\ket{\\psi^i_\\nu}=\\nu\\ket{\\psi^i_\\nu} \\Ra H \\ket{\\psi^i_\\nu}=(\\ve+\\frac{1}{2})\\ket{\\psi^i_\\nu} $$\n2.谱的确定 a.引理 引理 I 算符 $N$ 的本征值 $\\nu$ 都是正数或零。\n证明：\n$$ ||a\\ket{\\psi^i_\\nu}||^2=\\bok{\\psi^i_\\nu}{a^\\dagger a}{\\psi^i_\\nu} \\ge 0 \\Ra \\nu \\ge 0 $$\n引理 II 设 $\\ket{\\psi^i_\\nu}$ 是 $N$ 的非零本征矢，属于本征值 $\\nu$\n若 $\\nu=0$，则 $\\ket{\\psi^i_{\\nu=0}}=0$\n若 $\\nu\u0026gt;0$，则 $\\ket{\\psi^i_{\\nu}}$ 是 $N$ 的非零本征矢，属于本征值 $\\nu -1$\n引理 III 设 $\\ket{\\psi^i_\\nu}$ 是 $N$ 的非零本征矢，属于本征值 $\\nu$\n$a^\\dagger\\ket{\\psi^i_\\nu}$ 永远不为零\n$a^\\dagger\\ket{\\psi^i_\\nu}$ 是 $N$ 的非零本征矢，属于本征值 $\\nu + 1$\nb. $N$ 的谱由非负整数构成 根据引理 I，$\\nu$ 都是正数或零。balalbala 反证法，不写了。\n由此可知，$H$ 的本征值应该为：\n$$ E_n=(n+\\frac{1}{2})\\hbar \\omega $$\n可以见到，谐振子的能量是量子化的，且能量最小值不为 0，为 $\\hbar \\omega/2$\nc.对算符 $a,a^\\dagger$ 的解释 $a$ 为湮没算符， $a^\\dagger$ 为产生算符。（升降算符？）\n3.本征值的简并度 a.基态能级是非简并的 对应的能级 $E_0=\\frac{1}{2}\\hbar \\omega$\n基态对应的情况：\n$$ a\\ket{\\psi_0^i}=0 $$\n将其展开：\n$$ \\frac{1}{\\sqrt{2}}[\\sqrt{\\frac{m\\omega}{\\hbar}}X+\\frac{1}{\\sqrt{m\\hbar \\omega}}P]\\ket{\\psi^i_0}=0 $$\n使用 ${\\ket{x}}$ 表象：\n$$ (\\frac{m\\omega}{\\hbar}x+\\frac{\\dd}{\\dd x})\\psi^i_0(x)=0 $$\n解得：\n$$ \\psi^i_0(x)=ce^{-\\frac{1}{2}\\frac{m\\omega}{\\hbar}x^2} $$\n这个解不存在多个线性无关特解的情况，因此说明右矢 $\\ket{\\psi_0}$ 只有一个，说明是非简并的。\nb.所有能级是非简并的 数学归纳法：\n假设能级 $E_n=(n+1/2)\\hbar \\omega$ 是非简并的，那么 $E_{n+1}=(n+1+1/2)\\hbar \\omega$ 也是非简并的。\n设：\n$$ N\\ket{\\psi_n}=n\\ket{\\psi_n} $$\n那么：\n$$ N\\ket{\\psi^i_{n+1}}=(n+1)\\ket{\\psi_{n+1}^i} $$\n然后（由于 $a\\ket{\\psi^i_{n+1}}$ 不为 0 且是 $N$ 的本征矢，假设中这个本征值也是非简并的）：\n$$ a\\ket{\\psi^i_{n+1}}=c^i\\ket{\\psi_n} $$\n两边再作用一个算符 $a^\\dagger$：\n$$ a^\\dagger a\\ket{\\psi^i_{n+1}}=c^ia^\\dagger \\ket{\\psi_n}\\Ra N\\ket{\\psi^i_{n+1}}=c^ia^\\dagger\\ket{\\psi_n} $$\n因此可得：\n$$ \\ket{\\psi^i_{n+1}}=\\frac{c^i}{n+1}a^\\dagger\\ket{\\psi_n} $$\n我们已知 $a^\\dagger \\ket{\\psi_n}$ 是 $N$ 的本征矢且本征值为 $n+1$，因此 $\\ket{\\psi^i_{n+1}}$ 是非简并的。\nComment 这两节讲述了量子力学中谐振子的一些性质。\n","date":"2021-12-09T20:05:12+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-5-%E4%B8%80%E7%BB%B4%E8%B0%90%E6%8C%AF%E5%AD%90-ab-part/","title":"[量子力学] 5 一维谐振子 AB part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\mscr{\\mathscr} \\newcommand{\\avg}[1]{ \\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{ \\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\rightarrow} \\def\\La{\\leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\nE 薛定谔方程的物理意义 1.叠加符与干涉效应 推导 假设 $\\ket{\\psi_1},\\ket{\\psi_2}$ 是两个正交归一的态。\n如果一个体系处于 $\\ket{\\psi_1}$ 态，假设测量某个可观测量 $A$ 所得的本征矢为 $\\ket{u_n}$ 那么测量这个体系得到本征值的概率：\n$$ \\mscr{P}_1(a_n)=|\\bk{u_n}{\\psi_1}|^2 $$\n同理，对于 $\\ket{\\psi_2}$ 态：\n$$ \\mscr{P}_2(a_n)=|\\bk{u_n}{\\psi_2}|^2 $$\n那么，对于一个归一化的态 $\\ket{\\psi}=\\lambda_1 \\ket{\\psi_1}+\\lambda_2 \\ket{\\psi_2}$，测量 $A$ 得到的概率应该如何计算？\n按照常理来说，应该是：\n$$ \\mscr{P}(a_n)\\ ?= |\\lambda_1|^2 \\mscr{P}_1(a_n)+|\\lambda_2|^2 \\mscr{P}_2(a_n) $$\n但是并不是这么计算的，正确的计算方法如下：\n由之前的等式可知，$\\mscr{P}(a_n)$ 是概率幅 $\\bk{u_n}{\\psi}$ 的平方，那么这个体系的概率幅是：\n$$ \\bk{u_n}{\\psi} = \\lambda_1 \\bk{u_n}{\\psi_1}+\\lambda_2 \\bk{u_n}{\\psi_2} $$\n那么：\n$$ \\mscr{P}(a_n)= |\\bk{u_n}{\\psi}|^2=|\\lambda_1|^2 \\mscr{P}_1(a_n)+|\\lambda_2|^2 \\mscr{P}_2(a_n)+2\\un{Re}[\\lambda_1 \\lambda_2^* \\bk{u_n}{\\psi_1}\\bk{u_n}{\\psi_2}^*] $$\n第二项是干涉效应。\n两个例子 1、偏振光\n光子的偏振态为两个态线性叠加：\n$$ \\mbf e=\\frac{1}{\\sqrt{2}}(\\bf e_x+\\bf e_y) $$\n一个检偏器，方向与 $\\bf e$ 垂直。\n如果认为光子会通过一半就是错误的，应该是一个都没有通过。如果是 $N/2$ 个光子处于 $\\bf e_x$ 态，$N/2$ 个光子处于 $\\bf e_y$ 态，就能有半数的光子通过这个检偏器。\n2、对中间态求和\n假设有三个观察算符 $A,B,C$，对某个体系先后进行测量。$A\\ra B$ 的过程中，对应的 $B$ 的本征矢会有多个值，形成了三个中间态，求概率。\n\rimage-20211209173725674\r\n我们可能会觉得，是概率的相加：\n$$ \\mscr{P}_a(c)\\ ?= \\sum_b \\mscr{P}_a(b,c) $$\n但是是错误的，我们要从概率幅的方向考虑。\n$a \\ra c$ 的概率幅可以写成：\n$$ \\bk{v_c}{u_a} = \\sum_b \\bk{v_c}{w_b}\\bk{w_b}{u_a} $$\n因此，概率为：\n$$ \\begin{aligned} \\mathscr{P} _a (c) =\u0026amp; \\left | \\sum_{b} \\left \\langle v_{c} \\mid w_{b} \\right \\rangle \\left \\langle w_{b} \\mid u_{a} \\right \\rangle \\right |^2 \\nl =\u0026amp; \\sum_{b} \\left | \\left \\langle v_{c} \\mid w_{b} \\right \\rangle \\right |^{2} \\left | \\left \\langle w_{b} \\mid u_{a} \\right \\rangle \\right |^{2} \\nl \u0026amp;+ \\sum_{b} \\sum_{b^{\\prime} \\neq b} \\left \\langle v_{c} \\mid w_{b} \\right \\rangle \\left \\langle w_{b} \\mid u_{a} \\right \\rangle \\left \\langle v_{c} \\mid w_{b^{\\prime}} \\right \\rangle^{*} \\left \\langle w_{b^{\\prime}} \\mid u_{a} \\right \\rangle^{*} \\nl =\u0026amp; \\sum_{b} \\mathscr{P}_{a} (b, c)+\\sum_{b} \\sum_{b^{\\prime} \\neq b} \\left \\langle v_{c} \\mid w_{b} \\right \\rangle \\left \\langle w_{b} \\mid u_{a} \\right \\rangle \\left \\langle v_{c} \\mid w_{b^{\\prime}} \\right \\rangle^{*} \\left \\langle w_{b^{\\prime}} \\mid u_{a} \\right \\rangle^{*} \\end{aligned} $$\n注意的是，要计算各条路径之间所有的干涉效应。\n总的来说，我们求概率是要概率幅求和，而不是概率求和。\n2.若干个态与同一测量结果相联系的情况 同一个结果可能对应着不同的态，此时要取概率的和。\n例子：简并态\n$$ \\begin{aligned} \u0026amp;\\mathscr{P} \\left (a_{n} \\right )=\\sum_{i=1}^{g_{n}} \\left | \\left \\langle u_{n}^{i} \\mid \\psi \\right \\rangle \\right |^{2} \\nl \u0026amp; \\left \\langle u_{n}^{i} \\mid \\psi \\right \\rangle=\\lambda_{1} \\left \\langle u_{n}^{i} \\mid \\psi_{1} \\right \\rangle+\\lambda_{2} \\left \\langle u_{n}^{i} \\mid \\psi_{2} \\right \\rangle \\end{aligned} $$\nComment 这里举了两种情况，详细的说明了量子力学中应该如何对概率进行处理。\n书中给我们的一句话就是：\n将对应于同一末态的诸概率幅相加，然后将对应于正交末态的诸概率相加\n","date":"2021-12-09T17:14:21+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-3-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%81%87%E5%AE%9A-e-part/","title":"[量子力学] 3 量子力学的假定 E part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def\\dbar{\\mathrm{đ}} $$\n1 热力学的基本概念与基本规律 1.11 熵增加原理 1.11.1 熵增加原理 熵增加原理是热力学第二定律数学表述的一个重要的推论。\n$$ \\Delta S\\ge \\int^2_1\\frac{\\dbar Q}{T} $$\n如果绝热， $\\dbar Q = 0$：\n$$ \\Delta S\\ge0 $$\n用文字表述：系统的熵在绝热过程中永不减少。在可逆绝热过程中不变；在不可逆绝热过程中增加。它的另一表述是：孤立系的熵永不减少。\n1.11.2 不可逆过程熵变的例子 1、理想气体的自由膨胀\n一个系统经历以下变化，试计算熵的该变量：\n\rimage-20211210000936427\r\n$$ \\Delta S=\\int^2_1\\frac{\\dbar Q}{T}=\\frac{Q}{T}=NR\\ln\\frac{V_2}{V_1}\u0026gt;0 $$\n2、涉及非平衡态的熵的改变\n发生如下的过程：\n\rimage-20211210001432802\r\n对于均匀棒，各点的温度为：\n$$ T(x)=T_1-\\frac{T_1-T_2}{L}x $$\n非平衡态暂时先不涉及吧……不然没时间了。\n1.12 最大功 1.12.1 初、终态给定的情形 热力学第一定律：\n$$ \\dd U=\\dbar Q+\\dbar W $$\n令 $\\dbar W'=-\\dbar W$ 代表系统对外界所做的微功，则：\n$$ \\dbar W'=\\dbar Q-\\dd U $$\n根据熵的性质：\n$$ \\dbar Q\\le T_e \\dd S $$\n其中$=$ 对应可逆过程，此时 $T_e$ 是热源/系统本身的温度；而 $\u0026lt;$ 对应不可逆过程，此时 $T_e$ 只代表热源的温度。代入上式：\n$$ \\dbar W'\\le T_e \\dd S-\\dd U $$\n$\\dd S,\\dd U$ 给定的条件下（亦即在初、终态给定的情况下），系统对外界做最大功：\n$$ \\dbar W'_{\\text{max}}=\\dbar W'_R=T\\dd S-\\dd U $$\n其中 $\\dbar W'_R$ 代表可逆系统对外做的微功，$T$ 代表系统的温度，而不可逆系统对外界做的微功必小于可逆系统的。\n1.12.2 初态一定但终态不同的情形 （感觉这一部分的介绍比 Callen 的书写得差，有机会再补上）\n普遍的定律：可逆过程输出的功为最大。这是熵增加原理的推论，称为最大功定理。\n例子：\n假设有两个有限大小、性质相同的物体 $A,B$，初始温度分别为 $T_1,T_2(T_1\u0026gt;T_2)$。这两个物体可以对外做功，试问什么情况下输出的功 $W'$ 最大，最大值为多少？\n有三种方式：\n（1）让物体直接接触并达到相同温度。期间发生了不可逆热传导，没有任何功输出。\n（2）让一个热机工作其中，从 $A$ 物体吸热，并向 $B$ 物体放热。热机可以是可逆的，也可以是不可逆的。\n（3）使用（1）（2）混合方法。\n很明显，建立平衡的各种不同的方式实际上可以有无穷多种，它们所相应的输出功的大小是不同的。\n考虑情况（2），设最终温度为 $T_f$，$Q_1,Q_2$ 分别为 $A$ 物体放出的热量、$B$ 物体吸收的能量，那么：\n$$ \\begin{aligned} \u0026amp;Q_1=C_V(T_1-T_f)\\nl \u0026amp;Q_2=C_V(T_f-T_2) \\nl \u0026amp;W'=Q_1-Q_2=C_V(T_1+T_2-2T_f) \\end{aligned} $$\n使用熵增加原理（使用熵增加原理自然能够导出最大功定理）：\n$$ \\Delta S=\\Delta S_1 +\\Delta S_2 +\\Delta S_{热机}=\\Delta S_1 +\\Delta S_2\\ge 0 $$\n具体计算：\n$$ \\begin{aligned} \u0026amp;\\Delta S_1 = \\int^{T_f}_{T_1}\\frac{C_V\\dd T}{T}=C_V\\ln\\frac{T_f}{T_1}\u0026lt;0\\nl \u0026amp;\\Delta S_2 = \\int^{T_f}_{T_2}\\frac{C_V\\dd T}{T}=C_V\\ln\\frac{T_f}{T_2}\u0026gt;0\\nl \u0026amp;\\Delta S=C_V\\ln\\frac{T_f^2}{T_1T_2}\\ge0 \\end{aligned} $$\n因此：\n$$ T_f\\ge\\sqrt{T_1T_2} $$\n带入对外做功的式子中：\n$$ W'\\le C_V(T_1+T_2-2\\sqrt{T_1T_2}) $$\n可以得出最大值。\n我们可以看到，如果使用（1）方法，得到的最终温度 $T_f=\\frac{1}{2}(T_1+T_2)$ 为最高温度，而可逆热机 $T_f=\\sqrt{T_1T_2}$ 为最低温度，但输出功最大。\n1.13 自由能与吉布斯函数 1.13.1 自由能 考虑这样的等温过程：\n1、热源维持恒定温度 $T$\n2、系统的初态与终态的温度 $T_1$ 和 $T_2$ 的热源的温度相同，即 $T_1=T_2=T$。对于可逆等温过程，系统的温度自始至终与热源的温度相同；对不可逆过程，对过程中间系统的温度并未作任何限制。\n对于等温情况：\n$$ T\\Delta S\\ge Q=\\Delta U-W\\Ra \\Delta U -T\\Delta S\\le W $$\n引入新的态函数 $F$，定义：\n$$ F=U-TS $$\n则上式可由 $F$ 表达为：\n$$ \\Delta F= \\Delta U -T\\Delta S\\le W $$\n对外界做功最大值 $W_{\\un{max}}'=-\\Delta F$\n若 $W=0$，则 $\\Delta F\\le 0$，代表了等温等容过程的准则：可逆不变，不可逆则自由能减小。\n性质：\n1、自由能是态函数。\n由于 $U,T,S$ 都是态函数，因此 $F$ 也是态函数。尽管我们是从讨论等温过程而引入自由能的，但 $F$ 作为态函数无需依赖等温过程。\n2、$F$ 是广延量\n3、等温过程对外做功满足：\n$$ W'\\le-\\Delta F $$\n4、等温等容过程有：\n$$ \\Delta F\\le 0 $$\n5、对于 $p-V-T$ 系统：\n$$ \\dd F=\\dd U-T\\dd S-S\\dd T=T\\dd S-p\\dd V-T\\dd S-S\\dd T=-S\\dd T-p\\dd V $$\n1.13.2 吉布斯函数 考虑这样的等温、等压过程：\n1、热源维持恒定温度 $T$。系统的初态与终态的温度 $T_1$ 和 $T_2$ 的热源的温度相同，即 $T_1=T_2=T$。可逆与不可逆系统的限制同 1.13.1。\n2、外界维持恒定的压强 $p$。系统的初态与终态的压强 $p_1$ 和 $p_2$ 的外界的压强相同，即 $p_1=p_2=p$。可逆与不可逆系统的限制同 1.13.1。\n等温自由能的性质：\n$$ \\Delta F\\le W $$\n等压过程中，膨胀功为：\n$$ W=W_1-p\\Delta V $$\n其中 $W_1$ 为非膨胀功。\n因此：\n$$ \\Delta F+p\\Delta V\\le W_1 $$\n引入新的态函数 $G$，定义：\n$$ G=U-TS+pV=F+pV $$\n$G$ 称为吉布斯函数。\n性质：\n（1）$G$ 是态函数\n（2）$G$ 是广延量\n（3）$W_1'\\le-\\Delta G$\n（4）$W_1'=0$ 的等温等压过程，$\\Delta G\\le 0$\n（5）$p-V-T$ 系统的热力学基本微分方程式：\n$$ \\dd G=-S\\dd T+V\\dd p $$\n1.13.3 一点说明 我们已经引入了三个基本的热力学函数，即：\n1、温度/物态方程（热平衡定律）\n2、内能（热力学第一定律）\n3、熵（热力学第二定律）\n又引入了三个辅助热力学函数\n1、焓 $H=U+pV$，用于定压过程中的热容计算，$C_p=(\\frac{\\par H}{\\par T})_p$。\n2、自由能 $F=U-TS$，用于等温过程中。\n3、吉布斯函数 $G=U-TS-pV$，用于等温等压过程中。\nComment 这一部分讲述了：\n1、熵的一种重要的性质：熵增加原理（系统的熵在绝热过程中永不减少。在可逆绝热过程中不变；在不可逆绝热过程中增加。）\n2、最大功原理，就是熵增加原理的一个应用。\n3、两个辅助热力学函数。\n总算是把第一章给学习完了……这一张主要的内容就是通过提出这第零、一、二热力学定律来讲述热力学系统的性质。\n","date":"2021-12-08T16:53:15+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-1-%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%BE%8B-iv/","title":"[热统] 1 热力学的基本概念与基本规律 IV"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def\\dbar{\\mathrm{đ}} $$\n1 热力学的基本概念与基本规律 1.8 卡诺循环 卡诺循环由四个过程构成：\nI. 等温膨胀。维持高温 $T_1$ 不变，$V_1\\ra V_2$ II. 绝热膨胀。 III. 等温压缩。维持低温 $T_2$ 不变。$V_3 \\ra V_4$ IV. 绝热压缩回态 I。\n\rimage-20211208171306066\r\n对此循环应用热力学第一定律：\n$$ \\oint \\dd =\\oint \\dbar Q+\\oint \\dbar W\\Ra -\\oint\\dbar W=\\oint \\dbar Q $$\n令：\n$$ W'=-\\oint\\dbar W $$\n即 $W'$ 是气体对外做功的值。因此：\n$$ W'=\\oint \\dbar Q=Q_1+Q_2 $$\n其中 $Q_1,Q_2$ 分别代表步骤 I 和步骤 III 从外界吸收的能量。\n热机效率 $\\eta$ 定义（对外做功与吸收外界热量的比值）：\n$$ \\eta = \\frac{W'}{Q_1} = \\frac{Q_1-|Q_2|}{Q_1} = 1-\\frac{|Q_2|}{Q_1} $$\n通过另外两个绝热过程的推导：\n$$ Q_1=NRT_1\\ln\\frac{V_2}{V_1}, Q_2=-NRT_2\\ln\\frac{V_3}{V_4} $$\n我们可以得到 $\\eta$ 的表达式（即使在 $\\gamma=\\gamma(T)$ 的条件下也成立）：\n$$ \\eta = 1-\\frac{T_2}{T_1} $$\n热机的反向即为卡诺制冷机。令循环反向进行，则外界对气体做了功 $W$。通过这个循环依靠外界作功把热量从低温传到高温去，所以是一个致冷机。\n制冷系数 $\\ve$ 定义：\n$$ \\ve = \\frac{Q_2}{W} = \\frac{T_2}{T_1-T_2} $$\n1.9 热力学第二定律 1.9.1 热力学第二定律解决的问题 热力学第一定律给过程加了一条限制，即能量必须守恒。但有些热过程仍然不能发生，如低温物体不会自动向高温物体输送热量。这是一个方向性的问题，需要热力学第二定律来解答。\n1.9.2 热力学第二定律的两种经典表述 开尔文表述：不可能从单一热源吸热使之完全变为有用的功而不产生其他影响．\n揭示的一个特殊性质：在不产生其他影响的情况下，功可以完全转化为热，而热却不能完全转化为功．\n克劳修斯表述：不可能把热从低温物体传到高温物体而不产生其他影响．\n如果说热力学第一定律强调了“热”与“功”作为能量转化不同的形式的等价性；那么，热力学第二定律则揭示了“热功相互转化”的不等价性．\n还有另一种表述：第二类永动机是无法制成的。\n1.9.3 两种表述的等价性 1、开尔文 -\u0026gt; 克劳修斯\n假设克劳修斯表述不成立，设想一卡诺热机工作于 $T_1,T_2,T_1\u0026gt;T_2$ 两个热源之间，从 $T_1$ 热源吸收 $Q_1$ 热量，在 $T_2$ 热源放出 $Q_2$ 热量，对外做功 $W=Q_1-Q_2$。\n如果克劳修斯表述不成立，那么应该存在一种方法将 $Q_2$ 从低温热源 $T_2$ 传递到高温热源 $T_1$ 处。\n此时，高温热源吸收热量 $Q_2-Q_1$，但系统对外做功 $Q_1-Q_2$，违反开尔文表述。\n2、克劳修斯 -\u0026gt; 开尔文\n假设开尔文表述不成立，假设一热机从单一高温热源 $T_1$ 吸热 $Q_1$ 并完全转换为功 $W=Q_1$。\n使用这个功推动卡诺制冷机从低温热源 $T_2$ 吸收 $Q_2$ 的热量并传给高温热源 $Q_1+Q_2$ 的热量。\n结果是：热量 $Q_2$ 从低温热源传给了高温热源而没有产生其他影响，违反克劳修斯表述。\n\rimage-20211208173254361\r\n1.9.4 热现象过程的不可逆性 对于可逆过程来说，正反是没有意义的，它可以进行反演。\n但不可逆过程不同，它具有方向性。自然界一切实际发生的热现象过程都是不可逆过程。\n不可逆过程的两个基本性质：\n1、一切不可逆过程都是相互联系的。\n通过热机，任何一个特殊的不可逆过程，都可以想办法与其他的不可逆过程联系起来．也就是说，一切不可逆过程都是相互联系的．由此，只要肯定任何一个特殊过程的不可逆性，也就肯定了一切其他过程的不可逆性．\n2、不可逆过程可以由一个态函数判断运动方向的标准。\n既然不可逆过程的后果无论用任何办法都不能完全恢复 原状而不引起其他变化，这就表明不可逆过程的初态与终态一定存在某种特殊关系，有可能找到一个态函数，为不可逆过程的方向提供判断的标准．这个态函数就是熵\n1.9.5 研究可逆过程的意义 1、可以近似进行求解\n2、可以研究平衡态\n1.10 热力学第二定律的数学表述 熵 1.10.1 卡诺定理 卡诺定理：所有工作于两个一定温度之间的热机，以可逆机的效率为最大。\n设有两个热机 $A,B$ 工作与两个相同的热源之间，分别从 $\\theta_1$ 高温热源吸收 $Q_1,Q_1'$ 热量，向 $\\theta_2$ 的低温热源放出 $Q_2,Q_2'$ 的热量，对外做功 $W,W'$。两个热机的效率分别为：\n$$ \\eta_A=\\frac{W}{Q_1},\\eta_B=\\frac{W'}{Q'} $$\n设 $A$ 为可逆机，卡诺定理可以表示为：\n$$ \\eta_A\\ge\\eta_B $$\n使用反证法证明。假设 $\\eta_A\u0026lt;\\eta_B$，则 $\\frac{W}{Q_1}\u0026lt;\\frac{W'}{Q'}$，令 $Q_1=Q'$，则 $W\u0026lt;W'$，那么让 $B$ 机多出来的功 $W'-W$ 推动 $A$ 机工作。\n根据热力学第一定律：\n$$ W'=Q_1'-Q_2',W=Q_1-Q_2 $$\n则：\n$$ W'-W=Q_2-Q_2' $$\n那么这额外多做的功就令 $A$ 机恢复原状，导致两个热机都恢复原状，因此违背了热力学第二定律。\n因此：\n$$ \\begin{aligned} \u0026amp;\\eta_A=\\eta_B, \\ A,B 均为可逆机\\nl \u0026amp;\\eta_A\u0026gt;\\eta_B, \\ A为可逆机，B为不可逆机\\nl \\end{aligned} $$\n1.10.2 热力学温标 开尔文温标：\n$$ \\frac{Q_2}{Q_1}=\\frac{T_2}{T_1} $$\n效率：\n$$ \\eta=1-\\frac{Q_2}{Q_1}=1-\\frac{T_2}{T_1} $$\n1.10.3 克劳修斯不等式 根据卡诺定理：\n$$ \\eta=1-\\frac{Q_2}{Q_1}\\le1-\\frac{T_2}{T_1}\\Ra\\frac{Q_2}{Q_1}\\ge\\frac{T_2}{T_1}\\Ra\\frac{Q_1}{T_1}-\\frac{Q_2}{T_2}\\le0 $$\n现在约定 $Q$ 代表吸收的热量（因为卡诺热机有一次吸热过程和一次放热过程，把他们同时定义成吸热过程，那么就只有一个符号是相反的），因此：\n$$ \\frac{Q_1}{T_1}+\\frac{Q_2}{T_2}\\le0 $$\n其中 $Q_1,Q_2$ 分别是工质从 $T_1,T_2$ 热源吸收的热量。\n推广到 $n$ 个热源吸热的过程。\n$$ \\sum^n_{i=1}\\frac{Q_i}{T_i}\\le 0 $$\n\rimage-20211209224928983\r\n现在考虑 $n\\ra\\infty$ 极限情况：\n$$ \\oint \\frac{\\dbar Q}{T} \\le 0 $$\n1.10.4 第二定律对可逆过程的数学表述 熵 如果是可逆过程，那么：\n$$ \\oint \\frac{\\dbar Q_R}{T} = 0 $$\n$\\dbar Q_R$ 代表系统在微小的可逆过程中从热源所吸收的微热量。\n在系统平衡态的 $k$ 维状态空间中，选择一个封闭的环，在上面选取两个点 $P_0, P$，被分成两个过程 $C_1,C_2$。\n\rimage-20211209225328150\r\n$$ \\int_{C_1\\ \\left( P_{0}\\right)}^{(P)} \\frac{\\mathrm{\\dbar} Q_{\\mathrm{R}}}{T}+\\int_{C_2\\ (\\left.P\\right)}^{\\left(P_{0}\\right)} \\frac{\\mathrm{\\dbar} Q_{\\mathrm{R}}}{T}=0 $$\n可改写成：\n$$ \\int_{C_1\\ \\left( P_{0}\\right)}^{(P)} \\frac{\\mathrm{\\dbar} Q_{\\mathrm{R}}}{T}=\\int_{C_2\\ (\\left.P_0\\right)}^{\\left(P\\right)} \\frac{\\mathrm{\\dbar} Q_{\\mathrm{R}}}{T} $$\n发现路径积分与经过什么路径无关，因此可以定义出一个新的态函数熵 $S$：\n$$ S-S_0=\\int_{\\left( P_{0}\\right)}^{(P)} \\frac{\\mathrm{\\dbar} Q_{\\mathrm{R}}}{T} $$\n熵的单位是 $\\mathrm{J/K}$。\n1.10.5 第二定律对不可逆过程的数学表述 1、初、终态为平衡态的不可逆过程\n\rimage-20211209233725106\r\n左侧 $I$ 过程的积分是可逆过程，那么显然：\n$$ \\int_{\\left(P_{0}\\right)}^{(P)} \\frac{\\mathrm{d} Q_{\\mathrm{R}}}{T}\u0026gt;\\int_{\\left(P_{0}\\right)}^{(P)} \\frac{\\mathrm{d} Q_{1}}{T} $$\n由于 $P,P_0$ 都是平衡态，则：\n$$ S-S_0\u0026gt;\\int_{\\left(P_{0}\\right)}^{(P)} \\frac{\\mathrm{d} Q_{1}}{T} $$\n2、初、终态是非平衡态的不可逆过程\n将初、终态分成 $N$ 个小块，分别求得各部分的式子。由于熵是广延量，因此：\n$$ S=\\sum_{i=1}^NS^i $$\n得证\n1.10.6 熵的性质小结 1、熵是系统的态函数\n2、熵是广延亮，具有可加性\n3、$\\dbar Q=T\\dd S$\n4、热力学基本微分方程：\n$$ \\dd U=\\dbar Q+\\dbar W $$\n展开做功的式子：\n$$ \\dd U=T\\dd S+\\sum_l Y_l \\dd y_l $$\nComment 主要讲述了热力学第二定律相关的概念，包括：\n1.8：由卡诺循环的问题导入系统是否可逆的问题。\n1.9：热力学第二定律的本尊。讲了两个判断热力学进行方向的表述。\n1.10：热力学第二定律的数学表述。 将文字转换成数学语言，定义出态函数（熵）。\n","date":"2021-12-08T16:46:15+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-1-%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%BE%8B-iii/","title":"[热统] 1 热力学的基本概念与基本规律 III"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} \\def\\e{\\epsilon} \\def\\ve{\\varepsilon} \\newcommand{\\mscr}[1]{\\mathscr{#1}} \\def\\dbar{\\mathrm{đ}} $$\n1 热力学的基本概念与基本规律 1.4 功 传统热力学的一个基本任务就是研究能量转化的数值关系。系统从外界获取能量有两种基本形式，即做功与吸热。\n1.4.1 准静态过程的功 过程就是系统状态随时间的变化。会有两种情况：准静态过程及非静态过程。\n准静态过程的定义是：一个过程，在它进行中的每一步系统都处于平衡态，这样的过程称为准静态过程。\n准静态过程有一个性质：在无摩擦阻力时，当过程反向进行时，系统与外界在过程的每一步的状态都是原来正向进行时的状态的重演。\n可逆过程：一个过程，每一步都可在相反的方向进行而不在外界引起其他变化。\n做功的一些表达式：\n1、流体体积的变化\n当流体的体积变化 $\\dd V$ 时，外界对系统所作的微功为：\n$$ \\dbar W=-p\\dd V $$\n因为功是与过程相关的量，并不是完全的全微分，因此使用 $\\dbar$ 以区分 $\\dd$ 符号。\n2、表面膜面积变化过程\n$\\sigma$ 为液体膜的表面张力，$A$ 为膜的表面积。当表面积增加 $\\dd A$ 时，外界对系统所作的微功为：\n$$ \\dbar W=\\sigma \\dd A $$\n3、细弹性丝长度变化过程\n$\\scr F$ 为丝的张力，$L$ 为丝的长度：\n$$ \\dbar W=\\mscr{F} \\dd L $$\n4、电场中电介质的极化过程\n$$ \\dbar W = V \\ve_0 \\vec{\\mscr{E}}\\cdot \\dd \\vec{\\mscr{E}} + V\\vec{\\mscr{E}} \\cdot \\dd\\vec{\\mscr{P}} =V\\dd (\\frac{1}{2} \\ve_0 \\mscr{E} ^2+V\\vec{\\mscr{E}}\\cdot \\dd \\vec{\\mscr{P}}) $$\n5、磁场中磁介质的磁化过程\n$$ \\dbar W = V \\mu_0 \\vec{\\mscr{H}}\\cdot \\dd \\vec{\\mscr{H}} + V\\mu_0\\dd \\vec{\\mscr{H}} \\cdot\\vec{\\mscr{M}} =V\\dd (\\frac{1}{2} \\mu_0 \\mscr{H} ^2+\\mu_0 V\\vec{\\mscr{H}}\\cdot \\dd \\vec{\\mscr{M}}) $$\n有多种多样的准静态过程的功的表达式，我们可以将其抽象化：\n$$ \\dbar W=Y_1\\dd y_1+Y_2\\dd y_2+\\cdots + Y_r\\dd y_r=\\sum^r_{l=1}Y_l\\dd y_l $$\n1.4.2 特殊非静态过程的功 特殊情况下求功会比较简单：\n1、等容过程\n$$ W=0 $$\n2、等压过程\n$$ W=-p\\Delta V $$\n1.5 热力学第一定律 热力学第一定律是能量守恒定律在宏观热现象过程中的表现形式，而能量守恒定律是宏观和微观都成立的。热力学第一定律的另一表述是：永动机不可能制成。\n接下来定义内能：\n内能是系统平衡态的一个态函数。若一个过程，外界没有传热给系统，这类过程称为绝热过程。\n当系统由某初态（态 1）经过各种不同的绝热过程到终态（态 2）时，外界对系统所作的绝热功都相等.也就是说，对初、终态为平衡态的系统，外界对系统所作的绝热功（$W_a$）只与初态与终态有关，而与中间过程无关：\n$$ U_2-U_1=W_a $$\n推广至非绝热过程：\n$$ U_2-U_1=Q+W $$\n这就是热力学第一定律的数学表述，即系统内能的增加等于 系统从外界吸收的热量与外界对系统所作的功之和。\n微分：\n$$ \\dd U=\\dbar Q+\\dbar W $$\n由于内能 $U$ 是态函数，因此使用了符号 $\\dd$。\n内能是广延量，如果两个系统合并在一起，它们合并后系统的能量不单纯是 $U_1+U_2$，还需要增加两个系统的相互作用能 $U_{12}$ 才算完善。\n处于非平衡态时，需要考虑内部的小块的运动情况：\n$$ \\dd U+\\dd E_k=\\dbar Q+\\dbar W $$\n其中 $E_k=\\frac{1}{2}Mv^2$ 是小块的动能。\n1.6 热容 焓 热容定义：\n$$ C_y=\\frac{\\dbar Q_y}{\\dd T} $$\n其中 $\\dbar Q_y$ 是物体在温度升高 $\\dd T$ 时所吸收的微热量。下标 $y$ 指吸热过程中某一状态变量不变。\n对于 $p-V-T$ （包括气体、液体及各向同性固体）系统：\n1、定容热容\n$$ \\dbar Q_V=\\dd U \\Ra C_V=(\\frac{\\par U}{\\par T})_V $$\n2、定压热容\n$$ \\dbar Q_p=\\dd U-\\dbar W=\\dd U+p\\dd V \\Ra C_p=(\\frac{\\par U}{\\par T})_p + p(\\frac{\\par V}{\\par T})_p $$\n$C_p$ 和 $C_V$ 都是态函数。\n自此，引入一个新的态函数 $H=U+pV$，称为系统的焓。则定压热容可以简写为：\n$$ C_p = (\\frac{\\par H}{\\par T})_p \\qquad \\dbar Q_p=\\dd H $$\n虽然焓是从讨论等压过程引入的，但焓作为系统的态函数，并不依赖于等压过程。焓的一个重要性质是：在等压过程中物体从外界吸收的热量等于物体焓的增加值。\n热容是广延量，比热容（单位质量的热容）是强度量。\n当然还有其他状态变量的热容，如弹性丝的 $C_L, C_{\\mscr{F}}$ 等。\n状态变量以及与物态方程有关的量是实验可以直接测量的物理量，现在还要补充一类可直接测量的物 理量，就是各种热容。\n1.7 理想气体的性质 1.7.1 内能与焓 实验发现，温度不太低、压强趋于零的极限下的气体，即理想气体的内能只是 $T$ 的函数，与体积无关\n理想气体的物态方程与内能为：\n$$ \\begin{eqnarray} pV=NRT \\nl U=U(T) \\end{eqnarray} $$\n目前这两条式子是独立的。\n理想气体的焓为：\n$$ H=U+pV=U(T)+NRT=H(T) $$\n即理想气体的焓也只是温度的函数。\n理想气体中的热容：\n$$ \\begin{aligned} \u0026amp;C_{V} =\\left(\\frac{\\partial U}{\\partial T}\\right)_{V}=\\frac{\\mathrm{d} U}{\\mathrm{~d} T}=C_{V}(T) \\\n\u0026amp;C_{p} =\\left(\\frac{\\partial H}{\\partial T}\\right)_{p}=\\frac{\\mathrm{d} H}{\\mathrm{~d} T}=C_{p}(T) \\end{aligned} $$\n即两种热容都只是 $T$ 的函数。易得：\n$$ C_p-C_V=NR $$\n定义两种热容之比为 $\\gamma$：\n$$ \\gamma = \\frac{C_p}{C_V} = \\gamma(T) $$\n性质：$C_p\u0026gt;C_V$，因此 $\\gamma \u0026gt; 1$。\n两种热容的另一个表达式：\n$$ C_V=\\frac{NR}{\\gamma-1},C_p=\\gamma\\frac{NR}{\\gamma-1} $$\n通过对两个热容的积分，可以反推得到热容和焓：\n$$ \\begin{eqnarray} \u0026amp;U(T)=\\int C_{V}(T) \\mathrm{d} T+U_{0} \\nl \u0026amp;H(T)=\\int C_{p}(T) \\mathrm{d} T+H_{0} \\end{eqnarray} $$\n1.7.2 准静态绝热过程的过程方程 过程方程是指准静态过程中独立状态变量之间所满足的函数关系。以 $p-V-T$ 系统为例，准静态过程的过程方程的形式为 $p=p(V)$。\n绝热过程：\n$$ \\begin{eqnarray} \u0026amp;\\dbar Q= \\dd U+p\\dd V = 0 \\Ra V\\dd p + \\gamma p \\dd V =0 \u0026amp;\\Ra \\frac{\\dd p}{p} + \\gamma \\frac{\\dd V}{V}=0 \\Ra pV^\\gamma = C \\end{eqnarray} $$\n反复利用理想气体状态方程，可得：\n$$ \\begin{eqnarray} TV^{\\gamma-1}=C' \\nl \\frac{p^{\\gamma-1}}{T^\\gamma} = C'' \\end{eqnarray} $$\n$\\gamma$ 可以用其他方式测量，如声速法。\n声速的定义为：\n$$ a=\\sqrt{\\frac{\\dd p}{\\dd \\rho}} $$\n合理近似，可以把声波传播时压强随密度的变化看成是准静态绝热过程。因此：\n$$ a^2=(\\frac{\\par p}{\\par \\rho})_s=-v^2(\\frac{\\par p}{\\par v})_s $$\n其中 $v=\\frac{1}{\\rho}$ 代表气体单位质量的体积，称为比容。代入绝热过程的微分方程中，可得：\n$$ (\\frac{\\par p}{\\par v})_s=-\\gamma\\frac{p}{v} $$\n则：\n$$ a^2=\\gamma pv=\\frac{\\gamma p}{\\rho} $$\nComment 这一节主要讲述了围绕热力学第一定律相关的内容，包括：\n1.4：功，准静态过程下的做功，除 $p,V$ 以外其他状态变量的做功表达式。\n1.5：热力学第一定律本尊（宏观上的能量守恒）。引入了内能的概念，并写出了热力学第一定律的数学表达式。\n1.6：一些运算中非常重要的量（等容热容、等压热容、焓）的定义及运算。\n1.7：在理想气体中运用这些重要量的关系；一个重要过程绝热过程的过程方程。\n","date":"2021-12-08T12:27:39+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-1-%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%BE%8B-ii/","title":"[热统] 1 热力学的基本概念与基本规律 II"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\n1 热力学的基本概念与基本规律 1.1 热力学的研究目的 （传统）热力学 形成于 19 世纪中期（热力学第一定律与热力学第二定律的建立）至 20 世纪初（热力学第三定律）。具体地说，传统热力学研究的 问题可以归纳为三个方面：\n（1）热现象过程中能量转化的数量关系。如计算功、热量、热功转化的效率等。这些也是热力学形成初期最为关注的问题。\n（2）判断不可逆过程进行的方向。例如，在一定条件下，相变或化学反应向什么方向进行？或者换一种方式问：要使过程朝着期望的方向进行，应该满足什么条件？\n（3）物质的平衡性质。这部分内容很丰富。热力学的基础是它的三条基本定律，它们是大量经验的总结，因此，热力学理论是非常普遍和可靠的，适用于一切宏观物体（即由大量微观粒子组成的物体），并被推广应用于大到宇宙小到原子核（但这两种推广都要小心）。\n通常用于处理理想化的准静态过程，处理它的时候基本不考虑时间变量，因此使用 thermodynamics 一词不太对（动力学应该与时间相关）。\n热力学是宏观理论，因此没有经典和量子之分。\n非平衡态热力学（线性理论） 所谓“线性理论”是指引起偏离平衡态的各种热力学力（如温度梯度、电势梯度、密度梯度等）比较小，由这些“力”所产生的各种热力学流（如热流、电流、物质流 等）与“力”之间遵从线性关系。这时的非平衡态离平衡态不远，称为近平衡的非平衡态。线性非平衡态热力学已经发展成为成熟的理论，它在物理、化学、流体力学等诸多领域中得到了广泛的应用。\n非平衡态热力学（非线性理论） 当引起偏离平衡态的各种热力学力足够强时，系统被驱动到 远离平衡的非平衡态，这时热力学“流”与“力”之间不再遵从线性关系，而变为复杂的非线性关系。有许多的理论尝试去解决这个问题。\n1.2 平衡态及其描写 1.2.1 热力学系统 热力学系统是指热力学所研究的对象，不止于气体，还包括液体、液体表面膜、弹性丝、磁体、超导体、电池等等。但有一点限制是热力学系统必须是宏观物体，亦即由大量微观粒子所组成的。\n系统有了，也会有外界的定义：是指可以对系统发生影响的那部分外部环境。\n一些术语的概述：\n1、绝热壁与导热壁：绝热壁不允许它两边的物体发生任何形式的热交换，反之称为导热壁。\n2、刚性壁：刚性壁不允许物体发生位移和形变。因此，外界对物体不可能作机械功。\n3、热接触：由刚性、导热壁分开的两个物体，彼此只允许发生传热，而不允许发生力的或电磁的相互作用以及物质交换，这时称为两边的物体彼此处于热接触。\n4、孤立系：如果系统由绝热且刚性的壁与环境分隔开，那么，系统将不会受到外界的任何影响，即不可能发生任何能量与物质交换，这样的系统称为孤立系。孤立系在热力学与统计物理学的基本 原理的表述中具有特殊的地位。\n5、闭系与开系：系统与外界不能发生物质交换的称为闭系；反之称为开系。闭系允许系统与外界有能量交换（通过做功与传热）。开系是粒子数可变的系统。\n1.2.2 平衡态 定义：在没有外界影响的条件下，物体各部分的性质长时间内不发生任何变化的状态。\n平衡态只是宏观性质不随时间变化，从微观上看分子仍在不停地运动着，必然存在涨落，故称为动态平衡。\n经验表明，在一定的条件下，初始不处于平衡态的系统，经过一段时间，必将趋近于平衡态，这个时间称为弛豫时间。一定的条件指的是孤立系或不变的外界条件。\n大热源、热库（heat reservoir）：它足够地大，与物体发生有限数量的热量交换对热库的影响可以忽略。\n1.2.3 平衡态的描写 热力学把物体看成连续介质，不管它的微观结构，因此对于平衡态，只需要用少数几个宏观变量就可以完全描写，这些宏观变量称为状态变量，这种描写是宏观描写。\n如：气体的压强 $p$ 和体积 $V$，液体表面的张力 $\\sigma$ 与表面积 $A$，弹性丝的张力 $\\scr F$ 和长度 $L$。电场的电场强度、极化强度，磁场的磁场强度和磁化强度，多分子组成系统中的摩尔数等。这些状态变量都是可以直接测量的。\n均匀系与非均匀系：如果一个物体的各部分的性质完全相同，称为均匀系，也称为单相系。如果各部分的性质不同，则称为非均匀系，或复相系，其中每一个均匀部分称为一个相。\n对于均匀系，有两种变量：\n1、广延量，它与系统的总质量成正比，如摩尔数、体积、内能与熵等\n2、强度量，代表物质的内在性质，与总质量无关，如压强、温度、密度、内能密度、熵密度等。\n广延量具有可加性，强度量不可加，并具有局域的性质。\n如果系统处于非平衡态，就可以将系统分成多个小块（每一个小块宏观上足够小，以反映宏观性质随空间的变化；微观上要足够大，这样局部宏观量作为微观量的统计平均值才有意义），然后对他们进行研究。\n1.3 温度 物态方程 1.3.1 热平衡定律 温度 温度是表征物体冷热程度的物理量，温度的概念以及用温度计测量温度的原理都以热平衡定律为基础：\n热平衡定律（热力学第零定律）：若物体 $A$ 分别与物体 $B$ 和 $C$ 处于热平衡，那么，如果让 $B$ 与 $C$ 热接触，它们一定也处于热平衡。\n热平衡定律是经验的总结，它表明，互为热平衡的物体必定存在一个属于物体本身内在性质的物理量，这个量定义为温度。温度的最基本性质是：一切互为热平衡的物体的温度相等。\n温度使用的单位是 $\\rm K$。\n1.3.2 物态方程 物态方程 温度与独立状态变量之间的函数关系称为物态方程。\n例如，气体状态变量 $p,V$，物态方程为：\n$$ T=f(p,V) $$\n由于温度是可以直接测量的物理量，它也可以作为状态变量：\n$$ p=p(T,V) $$\nor\n$$ V=V(T,p) $$\nor\n$$ g(p,V,T)=0 $$\n普遍的说，令 $(x_1,x_2,\\cdots,x_n)$ 描写系统平衡态的独立状态变量，那么物态方程可写为：\n$$ T=f(x_1,x_2,\\cdots,x_n) \\quad \\text{or} \\quad g(x_1,x_2,\\cdots,x_n,T)=0 $$\n物态方程相关的物理量 1、膨胀系数 $\\alpha$\n$$ \\alpha=\\frac{1}{V}(\\frac{\\par V}{\\par T})_p $$\n代表在压强不变的条件下体积随温度的相对变化率。右下角的 $p$ 表示在求微商时把 $V$ 作为 $T$ 和 $p$ 的函数而保持 $p$ 不变。\n由于热力学系统有多个独立状态变量，因此，在求微商时必须把保持什么变量不变写清楚。特别 是，在计算中常常需要作变量变换，只有写清楚才不会出错。\n2、压强系数 $\\beta$\n$$ \\beta=\\frac{1}{p}(\\frac{\\par p}{\\par T})_V $$\n代表在体积不变的条件下压强随温度的相对变化率。\n3、等温压缩系数（压缩系数） $\\kappa_T$\n$$ \\kappa_T=-\\frac{1}{V}(\\frac{\\par V}{\\par p})_T $$\n代表在温度不变的条件下体积随压强的相对变化率。\n这三个系数之间的关系为：\n$$ \\alpha = \\kappa_T\\beta p $$\n由以下的微商导出：\n$$ (\\frac{\\partial V}{\\partial T})_p (\\frac{\\partial T}{\\partial p})_V (\\frac{\\partial p}{\\partial V})_T = -1 $$\n如果知道了物态方程，那么这三个系数就能通过定义式求出。若知道其中两个系数，第三个也能通过关系式导出。\n例子 1、理想气体\n理想气体是实际气体在压强趋于零时的极限，它可以作为实际气体在温度不太低，且密度足够稀薄时的近似。\n物态方程为：\n$$ pV=NRT $$\n$N$ 为气体的摩尔数， $T$ 为温度， $R=8.3145 \\rm J/(mol\\cdot K)$ 为摩尔气体常数。\n2、范德瓦耳斯气体\n范德瓦耳斯（van der Waals）气体是对实际气体的近似，它考虑了分子之间的相互作用所引起的修正，比理想气体进了一步。\n物态方程：\n$$ (p+\\frac{N^2 a}{V^2})(V-Nb)=NRT $$\n其中 $\\frac{N^2 a}{V^2}$ 代表分子之间的吸引力所引起的修正，而 $Nb$ 是分子之间的排斥力所引起的修正。\n3、昂尼斯方程\n昂尼斯（Onnes）根据实际气体在压强趋于零的极限下趋于理想气体这一性质，提出以下列按压强的级数展开形式作为实际气体的物态方程：\n$$ pV=NRT(1+A_2p+A_3p^2+\\cdots) $$\n$A_2,A_3,\\cdots$ 都是温度的函数，分别称为第二、第三、……位力系数。\n另一种按体积的负幂次展开的形式：\n$$ pV=NRT(1+\\frac{B_2}{V}+\\frac{B_3}{V^2}+\\cdots) $$\n$B_2,B_3,\\cdots$ 都是温度的函数，分别称为第二、第三、……位力系数。\n4、流体与各向同性固体\n由于液体和各向同性固体的 $\\alpha$ 和 $\\kappa_T$ 都比较小，可以把它们当成常数。\n物态方程：\n$$ V=V_0(1+\\alpha(T-T_0)-\\kappa_T(p-p_0)) $$\n5、顺磁固体\n独立状态变量可选 $(T,V,\\scr H)$，体积变化很小，可忽略不计，因此仅剩 $(T,\\scr H)$。\n遵从居里定律：\n$$ \\mathscr{M} = \\frac{C}{T} \\mathscr{H} $$\n1.3.3 几个常用的物理量的单位 压强 $\\rm 1\\ Pa = 1\\ N/m^2$\nCGS 单位制。力的单位是达因（$\\rm dyne$），压强的单位是 $\\rm dyne/cm^2$，称为微巴（$\\rm \\mu bar$）。 $\\rm 1\\ dyne/cm^2 = 1\\ \\mu bar, 1\\ bar = 10^6\\ dyne/cm^2 = 10^5\\ Pa$\n标准大气压 $\\rm 1\\ atm = 101325\\ Pa = 1.01325\\ bar$\nComment 第一节对热力学作了综述，解释了何为热力学以及热力学的用处。\n第二节对热力学中重要的状态——平衡态作了介绍，并对一些概念作了澄清（绝热壁 etc）。引入了两种独立变量的类型：广延量与强度量。\n第三节引入了温度的性质及热力学第零定律，并解释了什么是物态方程（温度与独立状态变量之间的函数关系）。最后列出了一些物态方程的例子（理想气体方程 etc）。\n","date":"2021-12-08T10:28:42+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E7%83%AD%E7%BB%9F-1-%E7%83%AD%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%BE%8B-i/","title":"[热统] 1 热力学的基本概念与基本规律 I"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\nD 薛定谔方程的物理意义 1.Schrödinger 方程的普遍性质 a. 确定性 $$ i\\hbar\\frac{\\dd}{\\dd t}\\ket{\\psi(t)}=H(t)\\ket{\\psi(t)} $$\n是关于 $t$ 的一次微分方程，给出了初态 $\\ket{\\psi(t_0)}$ 就能决定后续任意时刻的态。不确定性仅存在于测量某个物理量的时候。\nb.叠加原理 Schrödinger 方程是齐次线性的，因此解是可以叠加的。这意味着 $\\ket{\\psi(t_0)}$ 和 $\\ket{\\psi(t)}$ 之间的关系是线性的。\nc.概率守恒 i.\n$$ \\frac{\\dd}{\\dd t}\\bk{\\psi(t)}{\\psi(t)}=0 $$\n以及归一化\nii.概率的局域守恒，概率密度和概率流\n$$ \\rho(\\bl r, t) = |\\psi(\\bl r, t)|^2 $$\n表示概率密度。设概率流为 $\\bl J(\\bl r,t)$，那么：\n$$ \\frac{\\par}{\\par t}\\rho(\\bl r)+\\div \\bl J(\\bl r,t) = 0 $$\n易证明：\n$$ \\bl{J}(\\bl r,t) = \\frac{\\hbar}{2mi}[\\psi^* \\nabla \\psi-\\psi \\nabla \\psi^*]=\\frac{1}{m} \\mathrm{Re} [\\psi^* (\\frac{\\hbar}{i}) \\nabla\\psi] $$\nd.量子力学与经典的联系 平均值的演变：\n$$ \\avg{A}(t)=\\bok{\\psi(t)}{A}{\\psi(t)} $$\n演变公式：\n对 $\\bok{\\psi(t)}{A}{\\psi(t)}$ 求导：\n$$ \\begin{aligned} \\frac{\\mathrm{d}}{\\mathrm{d} t}\\langle\\psi(t)|A(t)| \\psi(t)\\rangle=\u0026amp;\\left[\\frac{\\mathrm{d}}{\\mathrm{d} t}\\langle\\psi(t)|\\right] A(t)|\\psi(t)\\rangle+\\langle\\psi(t)| A(t)\\left[\\frac{\\mathrm{d}}{\\mathrm{d} t}|\\psi(t)\\rangle\\right] \\nl \u0026amp;+\\left\\langle\\psi(t)\\left|\\frac{\\partial A}{\\partial t}\\right| \\psi(t)\\right\\rangle \\nl =\u0026amp; \\frac{1}{\\mathrm{i} \\hbar}\\langle\\psi(t)|[A(t) H(t)-H(t) A(t)]| \\psi(t)\\rangle \\nl \u0026amp;+\\left\\langle\\psi(t)\\left|\\frac{\\partial A}{\\partial t}\\right| \\psi(t)\\right\\rangle \\nl \\Ra\u0026amp; \\frac{\\mathrm{d}}{\\mathrm{d} t}\\langle A\\rangle=\\frac{1}{\\mathrm{i} \\hbar}\\langle[A, H(t)]\\rangle+\\left\\langle\\frac{\\partial A}{\\partial t}\\right\\rangle \\end{aligned} $$\n应用至 $R, P$ 上（Ehrenfest 定理）：\n$$ \\begin{aligned} \\frac{\\mathrm{d}}{\\mathrm{d} t}\\langle\\boldsymbol{R}\\rangle \u0026amp;=\\frac{1}{m}\\langle\\boldsymbol{P}\\rangle \\nl \\frac{\\mathrm{d}}{\\mathrm{d} t}\\langle\\boldsymbol{P}\\rangle \u0026amp;=-\\langle\\nabla V(\\boldsymbol{R})\\rangle \\end{aligned} $$\n2.保守体系 a.Schrödinger 方程的解 b.定态 不含时 $t$ 的体系称为保守体系，它的解称为定态解：\n$$ |\\psi(t)\\rangle=\\sum_{n} \\sum_{\\tau} c_{n, \\tau}\\left(t_{0}\\right) \\mathrm{e}^{-\\mathrm{i} E_{n}\\left(t-t_{0}\\right) / \\hbar}\\left|\\varphi_{n, \\tau}\\right\\rangle $$\nc.运动常量 运动常量是一个可观测量 $A$，它不显著依赖于时间，并且与 $H$ 对易：\n$$ \\begin{array}{l} \\frac{\\partial A}{\\partial t}=0 \\nl {[A, H]=0} \\end{array} $$\n运动常量的性质：\ni. $\\avg A$ 不随时间而变\nii. 能找到一个共同的本征值集合：\n$$ \\begin{aligned} \u0026amp;H\\left|\\varphi_{n, p, \\tau}\\right\\rangle=E_{n}\\left|\\varphi_{n, p, \\tau}\\right\\rangle \\nl \u0026amp;A\\left|\\varphi_{n, p, \\tau}\\right\\rangle=a_{p}\\left|\\varphi_{n, p, \\tau}\\right\\rangle \\end{aligned} $$\n当 $A$ 为运动常量时，物理体系便有一些定态，在任何时刻 $t$，这些态都保持为 $A$ 的属于同一本征值 $a_p$ 的本征态。这些本征值被称为好量子数。\niii. 得到本征值 $a_p$ 的概率是不随时间而变的\nd.体系的波尔频率；选择定则 待完成\nComment 这一节主要讲述了：\n1、Schrödinger 方程的演变确定性、可叠加性的性质，以及其在定态情况下的解。\n2、如何使用 Schrödinger 方程推出平均数的公式及经典力学的联系公式。\n3、如何使用 Schrödinger 方程推出概率流公式。\n4、运动常量的性质。\n5、波尔频率。\n","date":"2021-12-07T20:32:22+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-3-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%81%87%E5%AE%9A-d-part/","title":"[量子力学] 3 量子力学的假定 D part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\avg}[1]{\\left \\langle #1 \\right \\rangle} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\nC 关于可观测量及其测量的假定的物理解释 1.量子化规则与波函数的概率解释是一致的 $$ \\mathrm{d} \\mathscr{P}(p)=|\\langle p \\mid \\psi\\rangle|^{2} \\mathrm{~d} p=|\\bar{\\psi}(p)|^{2} \\mathrm{~d} p $$\n2.某些物理量的量子化 不是说所有物理量都是量子化的，有一些观察算符的谱是连续的。\n3.测量的机制 重点：要注意仪器会与体系有相互作用。\n4.可观测量在指定态中的平均值 $$ \\avg{A}_\\psi = \\bok{\\psi}{A}{\\psi} $$\n通常会在一个确定的表象中做计算，如：\n$$ \\avg{x}_\\psi=\\int\\dd^3\\psi^*(\\bl r)x\\psi(\\bl r) $$\n5.方均根偏差 $\\avg{A}$ 指出了体系处于 $\\ket\\psi$ 态时可观测量 $A$ 的大小的数量级，但不能告诉我们各种结果的离散程度。描述这个参数的值是方差：\n$$ \\Delta A=\\sqrt{\\avg{(A-\\avg{A})^2}}=\\sqrt{\\avg{A^2}-\\avg{A}^2} $$\n应用到 $R$ 和 $P$ 上，就得到不确定性关系。\n6.可观测量的相容性 如果 $A,B$ 对易，存在一个 $A,B$ 的共同本征右矢：\n$$ \\begin{eqnarray} \u0026amp;A\\ket{a_n,b_n,i}=a_n\\ket{a_n,b_n,i} \\nl \u0026amp;B\\ket{a_n,b_n,i}=b_p\\ket{a_n,b_n,i} \\end{eqnarray} $$\n如果 $A$ 测量一定得到 $a_n$，对 $B$ 测量一定得到 $b_p$，可以同时完全确定的可观测量叫做相容的可观测量。\n反之，若不可对易，一般说来，一个态矢量不可能成为这两个观察算符的本征矢，那么就称这两个可观察量是不可相容的。\n假设有两个相容量 $A,B$，测量 $A$ 的信息会因测量 $B$ 后得到补充，以及它们的测量顺序是无关紧要的。\n反之，若有两个不可相容量，不相容的两个可观测量是不能同时测量的，且第二次测量会失去第一次测量得到的信息。\nComment 本节讲述了一些与观测算符相关的基本假设。包括：\n1、观测算符作用的概率解释及本征值量子化。\n2、测量的机制问题\n3、观测算符的平均值/方差及其意义\n4、可观测量的相容性（测量信息损失问题）。解释了科普中的红蓝甜咸棒棒糖。\n","date":"2021-12-07T16:53:22+08:00","permalink":"https://mizarzh.github.io/p/2021/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-3-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%81%87%E5%AE%9A-c-part/","title":"[量子力学] 3 量子力学的假定 C part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\n假定的陈述 A 引言 讲了一下上一章所涉及到的数学是如何与现实的量子力学结合起来的。\nB 假定的陈述 1. 体系的态的描述 第一个假定：在确定时刻 $t_0$ ，一个物理体系的态由态空间 $\\scr E$ 中一个特定的右矢 $\\ket{\\psi(t_0)}$ 来确定。\n态空间 $\\scr E$ 是一个矢量空间，因此直接就蕴含了叠加原理。\n2. 物理量的描述 第二个假定：每一个可以测量的物理量 $\\scr A$ 都可以用在 $\\scr E$ 空间中起作用的一个算符 $A$ 来描述；这个算符是一个观察算符。\n与经典物理相比：态用矢量来表示，物理量用算符来表示。\n3. 物理量的测量 第三个假定：每次测量物理量 $\\scr A$，可能得到的结果只能是对应的观察算符 $A$ 的本征值之一。\n如果 $A$ 是厄米算符，那么测量 $\\scr A$ 所得的结果是实数；如果 $A$ 的谱是离散的，那么得到的 $\\scr A$ 可能得到的结果就是量子化的。\n谱分解原理 离散谱 第四个假定（非简并的离散谱的情况）：若体系已经处于归一化的态 $\\ket{\\psi}$ 中，则测量物理量 $\\scr A$ 得到的结果为对应观察算符 $A$ 的非简并本征值 $a_n$ 的概率 $\\mathscr P(a_n)$ 是：\n$$ \\mathscr P(a_n)=|\\bk{u_n}{\\psi}|^2 $$\n式中 $\\ket{u_n}$ 是 $A$ 的已归一化的本征矢，属于本征值 $a_n$。\n第四个假定（离散谱的情况）：\n$$ \\mathscr P(a_n)=\\sum^{g_n}_{i=1}|\\bk{u_n^i}{\\psi}|^2 $$\n式中 $g_n$ 是 $a_n$ 的简并度。\n遇到求仅和 $n$ 有关的量时，简并的态通常会有一个求和运算（排除掉 $i$ 的影响）：\n$$ \\begin{eqnarray} \\left|\\psi_{n}\\right\\rangle=\\sum_{i=1}^{g_{n}} c_{n}^{i}\\left|u_{n}^{i}\\right\\rangle \\nl P_{n}=\\sum_{i=1}^{g_{n}}\\left|u_{n}^{i}\\right\\rangle\\left\\langle u_{n}^{i}\\right| \\nl \\ket{\\psi_n}=P_n\\ket{\\psi} \\qquad \\nl \\left\\langle\\psi_{n} \\mid \\psi_{n}\\right\\rangle=\\sum_{i=1}^{g_{n}}\\left|c_{n}^{i}\\right|^{2} \\end{eqnarray} $$\n意识到：\n$$ \\mathscr P(a_n)=\\bk{\\psi_n}{\\psi_n}=\\bok{\\psi}{P^\\dagger_nP_n}{\\psi}=\\bok{\\psi}{P_n^2}{\\psi}=\\bok{\\psi}{P_n}{\\psi} $$\n连续谱 第四个假定（非简并连续谱）：测量处于归一化的态 $\\ket\\psi$ 的体系的物理量 $\\scr A$ 时，得到介于 $\\alpha$ 和 $\\alpha+\\dd\\alpha$ 之间的结果的概率 $\\dd \\mathscr P(\\alpha)$ 是：\n$$ \\dd\\mathscr{\\alpha}=|\\bk{v_\\alpha}{\\psi}|^2\\dd\\alpha $$\n其中 $\\ket{v_\\alpha}$ 是与 $\\scr A$ 相联系的观察算符 $A$ 的本征矢，属于本征值 $\\alpha$。\n重要后果 $\\ket{\\psi'}=e^{i\\theta}\\ket{\\psi}$ 时，归一化：$\\bk{\\psi'}{\\psi'}=\\bk{\\psi}\\psi$，分量：$|\\bk{u^i_n}{\\psi'}|^2=|\\bk{u^i_n}{\\psi}|^2$，因此加上了这个因子后也表示同一个物理状态。总的相位因子对于物理预言没有影响，但展开式中各系数的相对相位则是有影响的。\n波包的收缩 刚测量后，态的变化：\n$$ |\\psi\\rangle \\stackrel{\\left(a_{n}\\right)}{\\longrightarrow} \\frac{P_{n}|\\psi\\rangle}{\\sqrt{\\left\\langle\\psi\\left|P_{n}\\right| \\psi\\right\\rangle}} $$\n第五个假定：如果对处于 $\\ket\\psi$ 态的体系测量物理量 $\\scr A$ 得到的结果是 $a_n$， 则刚测量之后体系的态是 $\\ket\\psi$ 在属于 $a_n$ 的本征子空间上的归一化投影 $\\frac{P_{n}|\\psi\\rangle}{\\sqrt{\\left\\langle\\psi\\left|P_{n}\\right| \\psi\\right\\rangle}}$。\n翻译：测量后 $\\ket\\psi$ 态坍缩到 $\\ket\\psi$ 在 $a_n$ 本征值、 $\\scr E_n$ 空间的投影上，这个值是 $\\frac{P_{n}|\\psi\\rangle}{\\sqrt{\\left\\langle\\psi\\left|P_{n}\\right| \\psi\\right\\rangle}}$。\n4. 体系随时间的演变 第六个假定：态矢量 $\\ket{\\psi(t)}$ 随时间的演变遵从薛定谔方程：\n$$ i\\hbar\\frac{\\dd}{\\dd t}\\ket{\\psi(t)}=H(t)\\ket{\\psi(t)} $$\n式中 $H(t)$ 是与体系的总能量相联系的观察算符。\n$H$ 称作哈密顿算符。\n5. 量子化规则 这里讲述的是量子力学中定义的物理量 $\\scr A$ 和量子力学中的算符 $A$ 是如何对应的。\n位置 $\\bl r(x,y,z)$ 对应 $R(X,Y,Z)$，动量 $\\bl p(x,y,z)$ 对应 $P(P_x,P_y,P_z)$。粒子的任何一个物理量都可以由 $\\bl r, \\bl p$ 的函数 $\\mathscr A(\\bl r,\\bl p, t)$ 表示。那么将其中变量都换成 $R,P$ 即可。\n$$ A(t) = \\mathscr A(R,P,t) $$\n但是其中的内积 $\\bl r\\cdot \\bl p$ 可交换，但算符不可交换，通常的做法是将内积换成 $\\frac{1}{2}(R\\cdot P+P\\cdot R)$ 即可（对称化规则）。\n存在一些量子的物理量，不存在经典物理两，将由观察算符直接定义。\n重要例子：\n$$ \\mathscr H(\\bl r,\\bl p)=\\frac{\\bl p^2}{2m}+V(\\bl r) \\Ra H=\\frac{P^2}{2m}+V(R) $$\n$$ \\begin{eqnarray} \\mathscr H(\\bl r,\\bl p)=\\frac{1}{2m}[\\bl p-q\\bl A(\\bl r,t)]^2+qU(\\bl r,t) \\nl \\Ra H(t)=\\frac{1}{2m}[\\bl P-q\\bl A(\\bl R,t)]^2+qV(\\bl R,t)\\qquad V=qU \\end{eqnarray} $$\nComment 这一节讲述了量子力学的六个假设：\n 一个物理体系的态由一个矢量确定 可测量的物理量由一个观察算符来描述 每次测量物理量只能是对应观察算符的本征值之一 简并离散（etc）本征值的概率为 $|\\bk{u_n}{\\psi}|^2$ 测量后，本征态坍缩到相应本征值的投影$\\frac{P_{n}|\\psi\\rangle}{\\sqrt{\\left\\langle\\psi\\left|P_{n}\\right| \\psi\\right\\rangle}}$ 态随时间变化遵从薛定谔方程  ","date":"2021-11-30T19:50:27+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-3-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%81%87%E5%AE%9A-b-part/","title":"[量子力学] 3 量子力学的假定 B part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} \\def\\Ra{\\Rightarrow} \\def\\La{\\Leftarrow} \\def\\ra{\\rightarrow} \\def\\la{\\leftarrow} $$\nE 表象和观察算符的两个重要例子 一个重要的对应关系：\n$$ \\bk{\\varphi}{\\psi}=\\int\\dd^3 r\\varphi^*(\\mbf r)\\psi(\\mbf r) $$\n将内积与原来的 $r$ 表象对应上，有了可操作性。\n1、${\\ket r}$ 表象和 ${\\ket p}$ 表象 $$ \\begin{eqnarray} \u0026amp;\\xi_{r_0}(\\mbf r) = \\delta(\\mbf{r-r_0}) \\Ra \\ket{r_0} \\nl \u0026amp;v_{p_0}(\\mbf r) = (2\\pi\\hbar)^{-3/2}e^{i\\mbf{p_0\\cdot r}/\\hbar} \\Ra \\ket{p_0} \\end{eqnarray} $$\n经过一系列的推导：\n$$ \\bk{r}{\\psi}=\\psi(\\bl r), \\bk{p}{\\psi}=\\bar\\psi(\\bl p) $$\n正交归一关系式和封闭性关系式：\n$$ \\begin{eqnarray} \\left\\langle\\boldsymbol{r} \\mid \\boldsymbol{r}^{\\prime}\\right\\rangle=\\delta\\left(\\boldsymbol{r}-\\boldsymbol{r}^{\\prime}\\right) (a) \u0026amp;\\qquad \\left\\langle\\boldsymbol{p} \\mid \\boldsymbol{p}^{\\prime}\\right\\rangle=\\delta\\left(\\boldsymbol{p}-\\boldsymbol{p}^{\\prime}\\right) (b) \\nl \\int \\mathrm{d}^{3} r|\\boldsymbol{r}\\rangle\\langle\\boldsymbol{r}|=\\mathbb{1} (b) \u0026amp; \\qquad\\int \\mathrm{d}^{3} p|\\boldsymbol{p}\\rangle\\langle\\boldsymbol{p}|=1 (d) \\end{eqnarray} $$\n可以注意到这是连续的。\n另一种内积得表达式：\n$$ \\bk{\\varphi}{\\psi}=\\int\\dd^3\\bk{\\varphi}{p}\\bk{p}{\\varphi}=\\int\\dd^3\\bar\\varphi^*(\\bl p)\\bar\\psi(\\bl p) $$\n从${\\ket r}$表象变换到${\\ket p}$表象：\n$$ \\bk{r}{p}=\\bk{p}{r}^*=(2 \\pi \\hbar)^{-3 / 2} \\mathrm{e}^{\\frac{i}{\\hbar} \\boldsymbol{p} \\cdot \\boldsymbol{r}} $$\n2、算符 $R$ 和算符 $P$ a.定义 定义在 ${\\ket {r}}$ 表象中波函数乘 $x$ 对应回 $\\scr E$ 空间的操作算符为 $X$：\n$$ \\begin{eqnarray} \u0026amp;\\langle\\boldsymbol{r}|X| \\psi\\rangle=x\\langle\\boldsymbol{r} \\mid \\psi\\rangle \\nl \u0026amp;\\langle\\boldsymbol{r}|Y| \\psi\\rangle=y\\langle\\boldsymbol{r} \\mid \\psi\\rangle \\nl \u0026amp;\\langle\\boldsymbol{r}|Z| \\psi\\rangle=z\\langle\\boldsymbol{r} \\mid \\psi\\rangle \\end{eqnarray} $$\n可以把 $X,Y,Z$ 看成是算符 $R$ 的三个分量。\n矩阵元计算：\n$$ \\bok{\\varphi}{X}{\\psi}=\\int\\dd^3\\bk{\\varphi}{r}\\bok{r}{X}{\\psi}=\\int\\dd^3\\varphi^*(\\bl r)x\\psi(\\bl r) $$\n对于 $P_x,P_y,P_z$ 也如此：\n$$ \\begin{eqnarray} \\left\\langle\\boldsymbol{p}\\left|P_{x}\\right| \\psi\\right\\rangle=p_{x}\\langle\\boldsymbol{p} \\mid \\psi\\rangle \\nl \\left\\langle\\boldsymbol{p}\\left|P_{y}\\right| \\psi\\right\\rangle=p_{y}\\langle\\boldsymbol{p} \\mid \\psi\\rangle \\nl \\left\\langle\\boldsymbol{p}\\left|P_{z}\\right| \\psi\\right\\rangle=p_{z}\\langle\\boldsymbol{p} \\mid \\psi\\rangle \\end{eqnarray} $$\n因为我们常用的表象是 ${\\ket {r}}$，因此我们接下来研究 $P$ 算符如何作用在 ${\\ket {r}}$ 表象中：\n$$ \\begin{aligned} \\left\\langle\\boldsymbol{r}\\left|P_{x}\\right| \\psi\\right\\rangle \u0026amp;=\\int \\mathrm{d}^{3} p\\langle\\boldsymbol{r} \\mid \\boldsymbol{p}\\rangle\\left\\langle\\boldsymbol{p}\\left|P_{x}\\right| \\psi\\right\\rangle \\\n\u0026amp;=(2 \\pi \\hbar)^{-3 / 2} \\int \\mathrm{d}^{3} p \\mathrm{e}^{\\frac{\\mathrm{i}}{\\hbar} \\boldsymbol{p} \\cdot \\boldsymbol{r}} p_{x} \\bar{\\psi}(\\boldsymbol{p}) \\nl \u0026amp;= \\frac{\\hbar}{i}\\frac{\\par}{\\par x}\\psi(\\bl r)\\qquad \\text{(傅里叶逆变换)} \\end{aligned} $$\n因此：\n$$ P=\\frac{\\hbar}{i}\\nabla\\qquad\\text{(在r表象中)} $$\n可以计算它们的对易子：\n$$ \\begin{aligned} \\left\\langle\\boldsymbol{r}\\left|\\left[X, P_{x}\\right]\\right| \\psi\\right\\rangle \u0026amp;=\\left\\langle\\boldsymbol{r}\\left|\\left(X P_{x}-P_{x} X\\right)\\right| \\psi\\right\\rangle \\\n\u0026amp;=x\\left\\langle\\boldsymbol{r}\\left|P_{x}\\right| \\psi\\right\\rangle-\\frac{\\hbar}{\\mathrm{i}} \\frac{\\partial}{\\partial x}\\langle\\boldsymbol{r}|X| \\psi\\rangle \\\n\u0026amp;=\\frac{\\hbar}{\\mathrm{i}} x \\frac{\\partial}{\\partial x}\\langle\\boldsymbol{r} \\mid \\psi\\rangle-\\frac{\\hbar}{\\mathrm{i}} \\frac{\\partial}{\\partial x} x\\langle\\boldsymbol{r} \\mid \\psi\\rangle \\\n\u0026amp;=\\mathrm{i} \\hbar\\langle\\boldsymbol{r} \\mid \\psi\\rangle \\end{aligned} $$\n因此可以得到（正则对易关系式）：\n$$ \\begin{align} \u0026amp;[X,P_x]=i\\hbar\\nl \u0026amp;\\text{总结：}\\nl \u0026amp;{\\left[R_{i}, R_{j}\\right]=0} \\nl \u0026amp;{\\left[P_{i}, P_{j}\\right]=0} \\nl \u0026amp;{\\left[R_{i}, P_{j}\\right]=\\mathrm{i} \\hbar \\delta_{i j}} \\end{align} $$\nb. $R$ 和 $P$ 都是 Hermite 算符 根据 Hermite 算符的性质：\n$$ \\bok{\\varphi}{A}{\\psi}=\\bok{\\varphi}{A}{\\varphi}^* $$\n推导：\n$X$ ：\n$$ \\begin{align} \\langle\\varphi|X| \\psi\\rangle \u0026amp;=\\int \\mathrm{d}^{3} r \\varphi^{}(\\boldsymbol{r}) x \\psi(\\boldsymbol{r}) \\nl \u0026amp;=\\left[\\int \\mathrm{d}^{3} r \\psi^{}(\\boldsymbol{r}) x \\varphi(\\boldsymbol{r})\\right]^{} \\nl \u0026amp;=\\langle\\psi|X| \\varphi\\rangle^{} \\end{align} $$\n$P_x$：\n$$ \\begin{aligned} \\left\\langle\\varphi\\left|P_{x}\\right| \\psi\\right\\rangle \u0026amp;=\\frac{\\hbar}{\\mathrm{i}} \\int \\mathrm{d} y \\mathrm{~d} z \\int_{-\\infty}^{+\\infty} \\mathrm{d} x \\varphi^{*}(\\boldsymbol{r}) \\frac{\\partial}{\\partial x} \\psi(\\boldsymbol{r}) \\\n\u0026amp;=\\frac{\\hbar}{\\mathrm{i}} \\int \\mathrm{d} y \\mathrm{~d} z\\left{\\left[\\varphi^{*}(\\boldsymbol{r}) \\psi(\\boldsymbol{r})\\right]_{x=-\\infty}^{x=+\\infty}-\\int_{-\\infty}^{+\\infty} \\mathrm{d} x \\psi(\\boldsymbol{r}) \\frac{\\partial}{\\partial x} \\varphi^{*}(\\boldsymbol{r})\\right}\\nl \u0026amp;=-\\frac{\\hbar}{\\mathrm{i}} \\int \\mathrm{d}^{3} r \\psi(\\boldsymbol{r}) \\frac{\\partial}{\\partial x} \\varphi^{*}(\\boldsymbol{r}) \\\n\u0026amp;=\\left[\\frac{\\hbar}{\\mathrm{i}} \\int \\mathrm{d}^{3} r \\psi^{*}(\\boldsymbol{r}) \\frac{\\partial}{\\partial x} \\varphi(\\boldsymbol{r})\\right]^{*} \\\n\u0026amp;=\\left\\langle\\psi\\left|P_{x}\\right| \\varphi\\right\\rangle^{*} \\end{aligned} $$\nc. 本征矢 $$ \\begin{array}{l} X|\\boldsymbol{r}\\rangle=x|\\boldsymbol{r}\\rangle \\nl Y|\\boldsymbol{r}\\rangle=y|\\boldsymbol{r}\\rangle \\nl Z|\\boldsymbol{r}\\rangle=z|\\boldsymbol{r}\\rangle \\nl P_{x}|\\boldsymbol{p}\\rangle=p_{x}|\\boldsymbol{p}\\rangle \\nl P_{y}|\\boldsymbol{p}\\rangle=p_{y}|\\boldsymbol{p}\\rangle \\nl P_{z}|\\boldsymbol{p}\\rangle=p_{z}|\\boldsymbol{p}\\rangle \\end{array} $$\nd. 它们都是观察算符 有封闭性关系式可知。\nComment 这一节讲述了两个重要的表象。后续的许多推导都是在 ${\\ket{r}}$ 表象中进行的，因此学好这一个表象/算符是十分必要的。\n","date":"2021-11-28T00:18:05+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-2-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7-e-part/","title":"[量子力学] 2 量子力学的数学工具 E part"},{"content":"问题描述 为了查看远程服务器的图片，通常需要使用 scp 命令将图片传到本地查看，然后就要切换标签、输入特别长的路径 etc 一系列麻烦的东西，因此如果能直接输入查看图片的命令就能自动弹出图片就更好了。\n原理\u0026amp;解决方案 通过命令行查看图片的原理是通过 Linux 系统内置的 X11 forwarding 功能传输图片，而平常无法做到的问题是 windows 和 mac 不存在这个东西。解决方法就是在 windows 和 mac 上安装有 X11 forwarding 功能的辅助软件即可。\n解决方法：\n1、确定服务器 Linux 是否开启了 X11 forwarding 功能。\nsudo vi /etc/ssh/sshd_config # X11Forwarding Yes 其中的这一行改成这样子 sudo service sshd restart 2、客户端系统，windows 安装 Xming ，mac 安装 XQuartz， Linux 像上面一样打开即可。\n以 windows 为例：\n安装后打开 XLaunch，配置如下：\n\r第一页配置\r\n\r第三页配置\r\n（记得勾上 No Access Control）\n并确保其在右下角后台运行。\n3、ssh 连接时开启 X11 连接。\nssh -Y xxx@xxx.xxx 接下来使用任何带 GUI 功能都会弹出一个窗口了。\n4、测试：使用\nsudo apt install x11-apps xclock xeyes ... 如果不出问题，输入测试样例之后就能弹出图形化窗口。\nX11介绍 X X 就是 X WIndows System，是为 Linux 系统提供 GUI 功能（Linux 内核是没有 GUI 的）。\nX11 X11 就是第十一个版本。这个版本在1987年就已经是第11版了。\nX Client \u0026amp; Server X11 协议的客户端和服务端。Client 主要是告知 Server 要绘制什么。Server 的功能主要是管理主机的硬件设备。\npython 的问题 当然，找到这么一个解决方案，那当然是要试试 python 画图啦，但是却有错误（python 未配置 tkinter）。\n原因是需要设置 matplotlib 的画图环境：\n合法的画图环境：\nValueError: '' is not a valid value for backend; supported values are ['GTK3Agg', 'GTK3Cairo', 'MacOSX', 'nbAgg', 'Qt4Agg', 'Qt4Cairo', 'Qt5Agg', 'Qt5Cairo', 'TkAgg', 'TkCairo', 'WebAgg', 'WX', 'WXAgg', 'WXCairo', 'agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template'] 若要使用 tkinter，需要输入以下命令：\nsudo apt-get install python3-tk 测试代码：\nimport matplotlib import matplotlib.pyplot as plt matplotlib.use(\u0026#39;tkinker\u0026#39;) plt.plot([1,2,3]) plt.show() 测试结果：\n\r测试结果\r\nfeh命令 在 Linux 中查看图片的命令有很多，如 eog, display, gimp 等等。这里使用 feh 是因为其有一定的图片编辑能力且轻量级。\n安装及测试：\nsudo apt install feh feh somePicture ","date":"2021-11-27T20:24:46+08:00","permalink":"https://mizarzh.github.io/p/2021/11/terminal%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E5%9B%BE%E7%89%87/","title":"Terminal查看远程图片"},{"content":"1 一些概念 crate：是一个二进制项或者库。一个 crate 会将一个作用域内的相关功能分组到一起，能很方便的在多个项目间共享。\n包 Package：是提供一系列功能的一个或者多个 crate。一个包会含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。一个包中至多 只能 包含一个库 crate(library crate)；包中可以包含任意多个二进制 crate(binary crate)；包中至少包含一个 crate，无论是库的还是二进制的。\n库 crate 和二进制 crate：库 crate 是编译过程中的上游，一般来说是被别人使用的。二进制 crate 则是自己要使用的程序代码。库 crate 一般不包含 Cargo.lock 文件。\n2 新建 package 及文件结构 新建 package:\ncargo new my-project 生成了 src 文件夹， src/main.rs 文件， Cargo.toml 配置文件及进行了 git 初始化。\nsrc/main.rs 就是一个与包同名的二进制 crate 的 crate 根。如果含有 src/lib.rs， 则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。crate 根文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目。\n一个只包含 src/main.rs 的包，意味着它只含有一个名为 my-project 的二进制 crate。如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。\n通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。\nlib 也可以写成文件结构的方式。\n完整的 package 的结构，可以看到还含有例子、测试和性能测试的模块：\n. ├── Cargo.lock ├── Cargo.toml ├── src/ │ ├── lib.rs │ ├── main.rs │ └── bin/ │ ├── named-executable.rs │ ├── another-executable.rs │ └── multi-file-executable/ │ ├── main.rs │ └── some_module.rs ├── benches/ │ ├── large-input.rs │ └── multi-file-bench/ │ ├── main.rs │ └── bench_module.rs ├── examples/ │ ├── simple.rs │ └── multi-file-example/ │ ├── main.rs │ └── ex_module.rs └── tests/ ├── some-integration-tests.rs └── multi-file-test/ ├── main.rs └── test_module.rs  3 关键词；私有性 模块的关键词是 mod：\n// src/lib.rs mod mod1{mod small_mod1{fn func_1(){}fn func_2(){}}mod small_mod2{fn func_3(){}}}建立的结构：\ncrate └── mod1 ├── small_mod1 │ ├── func_1 │ └── func_2 └── small_mod2 └── func_3 默认的属性是私有(private)的，加上 pub 关键字就能使得其被其他模块引用：\n// src/lib.rs mod mod1{pubmod small_mod1{pubfn func_1(){}// 最底层的也要加上pub fn func_2(){}// 这个函数就无法被外部访问 }pubmod small_mod2{pubfn func_3(){}}}4 路径 要在其他模块中引用库，则需要使用路径指定它所在的地方。用的路径有两种：\n 绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。 相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。  绝对路径和相对路径都后跟一个或多个由双冒号（::）分割的标识符。\n// src/lib.rs mod mod1{pubfn func_1(){}}pubfn run(){crate::mod1::func_1()// 绝对路径 mod1::func_1()// 相对路径 }super 关键字的使用：\n// src/lib.rs fn serve_order(){}mod back_of_house{fn fix_incorrect_order(){cook_order();super::serve_order();// 这里的super即指向本模块的上一级（即crate） }fn cook_order(){}}5 use 关键字；as 关键字 use 的作用是将指定模块下的东西引入到本作用域中（可以理解为缩写，python 中的 import）。\n可以使用相对路径和绝对路径。\n// src/lib mod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}usefront_of_house::hosting;pubfn eat_at_restaurant(){hosting::add_to_waitlist();hosting::add_to_waitlist();hosting::add_to_waitlist();}不允许引入相同名称的类型到同一作用域中。但可以使用 as 关键字修改引入的名称。还有嵌套语句的使用：\nusestd::fmt::Result;usestd::io::ResultasIoResult;usestd::{cmp::Ordering,io};usestd::io::{self,Write};// 如果想要引入 std::io 自己，就加上 self usestd::collections::*;// 避免使用 重导出技巧：\nmod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}pubusecrate::front_of_house::hosting;使用外部的包：\n在 Cargo.toml 中添加：\n[dependencies] rand = \u0026#34;0.5.5\u0026#34; 然后就引入了 rand 包，接下来可以使用 use 使用其内部的类型了。\n6 lib 的文件分割 假设创建一个新文件： src/math.rs\n// src/math.rs pubfn add(x: i32,y: i32)-\u0026gt; i32 {x+y}直接在 main.rs 文件中使用 use math::add 语句是行不通的，因为 rust 默认以 lib.rs 文件为库的入口。若想使用这个模库，需要在主文件中添加：\nmod math;// 相当于将 math 导入到了 main.rs 中 usemath::add;// 导入 add 到此作用域 fn main(){letresult=add(1,2);println!(\u0026#34;1 + 2 = {}\u0026#34;,result);}Rust 会在与模块同名的文件中查找模块的代码。\n如果想要以一个文件夹为单位创建一个库，那么文件夹内部文件 mod.rs 就是描述以文件夹名为模块名的文件。\n例如 math.rs 和 math/mod.rs，如果 math.rs 和 math/mod.rs 中的内容完全一致，那么这两个模块没有什么区别，除了 math/mod.rs 中可以定义更加复杂的结构。\n文件结构：\nsrc/ main.rs math/ mod.rs add.rs sub.rs // mod.rs mod add;mod sub;// 只有这两条语句是不够的。这两条语句只将 add 和 sub 引入了 math 模块，但对外是不公开的。 // 如果写成 pub mod add，那么将会将整个 add 模块导出（即外部调用为 add::add），这与我们的初衷（隐藏 add 和 sub）不符合。 // 因此还需要重导出需要的函数： pubuseadd::add;pubusesub::sub;// add.rs pubfn add(x: i32,y: i32)-\u0026gt; i32 {x+y}// sub.rs pubfn sub(x: i32,y: i32)-\u0026gt; i32 {x-y}总之，lib 文件的可能结构是这样的：\n总模块文件：lib.rs，rust 会默认使用这个文件。\n普通的模块文件： xxx.rs ，由于 rust 不默认导入这些模块，因此需要使用加入 mod xxx; 语句。\n文件夹模块文件： xxx/mod.rs ，相比上一项的好处是 xxx/ 下能定义更多的私有方法。\n","date":"2021-11-25T15:14:33+08:00","permalink":"https://mizarzh.github.io/p/2021/11/rust%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/","title":"Rust模块系统"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} $$\nD 本征值方程；观察算符 1、算符的本征值和本征矢 a.定义 如果：\n$$ A\\ket\\psi=\\lambda\\ket\\psi $$\n称为$A$的本征值方程。$\\lambda$称为本征值，本征值的集合称为谱。本征值相对应的$\\ket\\psi$称为本征矢。\n如果$\\ket\\psi$是$A$属于本征值$\\lambda$的本征矢，那么$\\alpha\\ket\\psi$也是属于相同本征值的本征矢。为了消除这种不确定性，我们要将本征矢归一化：$\\bk{\\psi}{\\psi}=1$。\n如果本征值$\\lambda$只对应一个本征矢，那么这个本征值就是非简并的。如果对应多个本征矢，则是简并的，线性无关的本征矢的数目叫做该本征值的简并度（可以是无限的）。如果：\n$$ A\\ket{\\psi^i}=\\lambda\\ket{\\psi^i} $$\n那么具有以下形式的右矢：\n$$ \\ket{\\psi}=\\sum_{i=1}^g c_i\\ket{\\psi^i} $$\n也符合这个本征式。\nb. 求算符的本征值和本征矢 和线性代数的本征值求法相同：\n$$ |\\mathscr{A}-\\lambda I|=0 $$\nc. 求本征矢 线性代数！\n2、观察算符 a. Hermite 算符的本征值和本征矢的性质 Hermite 算符的定义：$A^\\dagger=A$\n性质：\n(i) Hermite 算符的本征值是实数\n(ii) Hermite 算符的两个不同本征值的本征矢互相正交\nb. 观察算符的定义 如果$\\scr E$是有限多维空间，则可以用一个 Hermite 算符的全体本征矢构成一个基。但遇到无限维就有问题了，因此需要引入一个观察算符的概念。\n设有一个 Hermite 算符 $A$。假设其本征值构成一个离散谱 ${a_n}$，$a_n$ 对应的简并度为 $g_n$ ，再设 $\\ket{\\psi^i_n}\\ (i=1,2,\\dots,g_n)$ 表示从 $a_n$ 本征子空间 $\\mathscr{E}_n$ 中选出 $g_n$ 个线性无关的矢量：\n$$ A\\ket{\\psi^i_n}=a_n\\ket{\\psi^i_n} $$\n对于另外的本征子空间，原本征子空间的每一个矢量都是与之正交的。而每个本征子空间的内部都可以选择一系列的矢量使得它们正交归一。因此得到了算符 $A$ 的本征矢的正交归一：\n$$ \\bk{\\psi^i_n}{\\psi^{i'}{n'}}=\\delta{nn'}\\delta_{ii'} $$\n再加上如果这个正交归一系可以在态空间中构成一个基，那么算符 $A$ 就是一个观察算符。当然，构成基的条件可以用封闭性关系式：\n$$ \\sum^\\infty_{n=1}\\sum^{g_n}_{i=1}\\ket{\\psi_n^i}\\bra{\\psi_n^i}=\\mathscr{1} $$\n本征子空间 $\\mathscr{E}_n$ 上的投影算符 $P_n$ 可以写作：\n$$ P_n=\\sum^{g_n}_{i=1}\\ket{\\psi_n^i}\\bra{\\psi_n^i} $$\n对于连续谱（非简并情况）， $\\psi^i_n \\rightarrow \\psi_\\nu,\\ a_n\\rightarrow a(\\nu),\\ \\delta_{nn'}\\delta_{ii'}\\rightarrow \\delta(\\nu-\\nu')$，封闭性方程式换为积分。\n3、可对易观察算符的集合 a. 重要定理 (i) 如果两个算符 $A,B$ 可对易，且 $\\ket{\\psi}$ 是 $A$ 的一个本征矢，则 $B\\ket{\\psi}$ 也是 $A$ 的本征矢，且属于同一对本征值。\n数学形式：\n$$ [A,B]=0,\\ A\\ket\\psi=a\\ket\\psi \\Rightarrow A(B\\ket\\psi)=a(B\\ket\\psi) $$\n另一种表述：如果两个算符 $A,B$ 可对易，那么 $A$ 的所有本征子空间在 $B$ 的作用下都是整体不变的\n(ii) 如果两个算符 $A,B$ 可对易，又若 $\\ket{\\psi_1},\\ket{\\psi_2}$ 是 $A$ 的两个本征矢，属于不同的本征值，则 $\\bok{\\psi_1}{B}{\\psi_2}=0$\n数学形式：\n$$ [A,B]=0,\\ A\\ket{\\psi_1}=a_1\\ket{\\psi_1},A\\ket{\\psi_2}=a_2\\ket{\\psi_2} \\Rightarrow \\bok{\\psi_1}{B}{\\psi_2}=0 $$\n(iii) （基本定理）如果两个算符 $A,B$ 可对易，则 $A,B$ 的共同本征矢构成态空间的一个正交归一基。\n可以用记号 $\\ket{u_{n,p}^i}$ 来标记 $A,B$ 的共同本征矢（本征值为 $a_n, b_p$）。\n该定理可以逆向使用。\nb. 可对易观察算符的完全集合（法文 ECOC,英文 CSCO） 假如一个本征值不简并，那么本征值 $a_n$ 就可以表述一个基矢 $\\ket{u_n}$。但如果本征值是简并的，就需要额外的一个指标 $i$ 来确定各基矢了。\n可取另一个与 $A$ 对易观察算符 $B$ ，使用它们的共同本征矢构成一个正交归一基。如果这个基是唯一的，那么 $A,B$ 构成一个 ECOC。（相当于 $a_n$ 区分不出来的基矢加上一个额外的指标 $b_p$ 就能区分出来了）。\n一系列观察算符 $A,B,C,\\cdots$ 的集合叫做可对易观察算符的完全集合的条件是：\n(i) 这些观察算符是两两对易的\n(ii) 给出了全体算符的本征值的一个数组，便足以决定唯一一个共同本征矢。（倍乘因子除外）\n等价说法：\n存在着由共同本征矢构成的一个正交归一基，而且这个基是唯一的。（相位因子除外）\n我们通常考虑的是它的最小集合。\nComment 这一节讲述了非常重要的本征值/矢的概念，这些方法在量子力学中相当于经典力学中的求值\u0026amp;求它们出现的概率\u0026amp;求此时矢量的状态，只不过是本征值以概率形式出现而不是期望值。同时还讲述了 ECOC 的性质，是量子力学中十分重要的一个概念。\n","date":"2021-11-24T20:24:24+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-2-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7-d-part/","title":"[量子力学] 2 量子力学的数学工具 D part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} $$\nC 态空间中的表象 1、引言 a.表象的定义 选择一种表象就是在态空间 $\\scr E$ 中选择一个离散或连续的正交归一基。\n在选定的基中，矢量和算符都是用数表示的：\n 对于矢量，这些数就是它的分量 对于算符，这些数就是它的矩阵元  上一节中的运算就变成了矩阵运算。\n原则上来说，表象的选择是任意的，但如果具体问题具体选择那会更好。\n2、一个正交归一基的特征关系式 a. 正交归一关系式 满足以下关系式的称为正交归一关系式：\n$$ \\bk{u_i}{u_j}=\\delta_{ij}\\quad \\text{or} \\quad \\bk{w_\\alpha}{w_{\\alpha'}}=\\delta(\\alpha-\\alpha') $$\nb. 封闭性关系式 一个右矢能唯一地展开，通过以下推导：\n$$ \\begin{aligned} |\\psi\\rangle \u0026amp;=\\sum_{i} c_{i}\\left|u_{i}\\right\\rangle=\\sum_{i}\\left\\langle u_{i} \\mid \\psi\\right\\rangle\\left|u_{i}\\right\\rangle \\nl \u0026amp;=\\sum_{i}\\left|u_{i}\\right\\rangle\\left\\langle u_{i} \\mid \\psi\\right\\rangle=\\left(\\sum_{i}\\left|u_{i}\\right\\rangle\\left\\langle u_{i}\\right|\\right)|\\psi\\rangle \\nl |\\psi\\rangle \u0026amp;=\\int \\mathrm{d} \\alpha c(\\alpha)\\left|w_{\\alpha}\\right\\rangle=\\int \\mathrm{d} \\alpha\\left\\langle w_{\\alpha} \\mid \\psi\\right\\rangle\\left|w_{\\alpha}\\right\\rangle \\nl \u0026amp;=\\int \\mathrm{d} \\alpha\\left|w_{\\alpha}\\right\\rangle\\left\\langle w_{\\alpha} \\mid \\psi\\right\\rangle=\\left(\\int \\mathrm{d} \\alpha\\left|w_{\\alpha}\\right\\rangle\\left\\langle w_{\\alpha}\\right|\\right)|\\psi\\rangle \\end{aligned} $$\n可以得出：\n$$ \\begin{eqnarray} \u0026amp;P_{{u_i}}=\\sum_i \\ket{u_i} \\bra{u_i} = \\mathbb{1} \\nl \u0026amp;P_{{w_\\alpha}}=\\int \\dd \\alpha \\ket{w_\\alpha} \\bra{w_\\alpha} = \\mathbb{1} \\end{eqnarray} $$\n这两条式子称为封闭性关系式。\n同理，这个推导可以反向进行操作。\n\rimage-20211124194640763\r\n3、左矢右矢表示法 a.右矢的表示法 右矢$\\ket{\\psi}$是由其分量的集合来表示的。含有一列和无穷多行：\n$$ \\begin{pmatrix} \\bk{u_1}{\\psi} \\nl \\bk{u_2}{\\psi} \\nl \\vdots \\nl \\bk{u_i}{\\psi} \\nl \\vdots \\end{pmatrix} $$\n连续基则是由无穷多个数（$c(\\alpha)$函数）表示的。函数的任意一个值都代表$\\ket\\psi$的一个分量：\n$$ \\begin{pmatrix} \\vdots \\nl \\bk{w_\\alpha}{\\psi} \\nl \\vdots \\end{pmatrix} $$\nb.左矢的表示法 $$ (\\bk{\\psi}{u_1}\\ \\bk{\\psi}{u_2}\\ \\cdots \\bk{\\psi}{u_i} \\ \\cdots) $$\n$$ (\\cdots \\bk{\\psi}{w_\\alpha} \\ \\cdots) $$\n4、算符的表示法 a. 方阵表示 A 线性算符的值依赖于两个指标：\n$$ A_{ij}=\\bok{u_i}{A}{u_j} \\quad \\text{or} \\quad A(\\alpha, \\alpha')=\\bok{w_\\alpha}{A}{w_{\\alpha'}} $$\n因此可以排列成一个方阵，展开后：\n$$ \\left(\\begin{array}{ccccc} A_{11} \u0026amp; A_{12} \u0026amp; \\cdots \u0026amp; A_{1 j} \u0026amp; \\cdots \\nl A_{21} \u0026amp; A_{22} \u0026amp; \\cdots \u0026amp; A_{2 j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\nl A_{i 1} \u0026amp; A_{i 2} \u0026amp; \\cdots \u0026amp; A_{i j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\end{array}\\right) $$\n连续情况的类似。\n线性算符的乘法：\n$$ \\bok{u_i}{AB}{u_j}=\\bok{u_i}{A \\mathbb{1} B}{u_j}=\\bok{u_i}{A P_{{u_k}} B}{u_j}=\\sum_k\\bok{u_i}{A}{u_k}\\bok{u_k}{B}{u_j} $$\nb.右矢$\\ket{\\psi'}=A\\ket\\psi$的表示： 易得：\n$$ c'i=\\sum_jA{ij}c_j $$\n可以写出矩阵形式：\n$$ \\left(\\begin{array}{c} c_{1}^{\\prime} \\nl c_{2}^{\\prime} \\nl \\vdots \\nl c_{i}^{\\prime} \\nl \\vdots \\nl \\vdots \\end{array}\\right)=\\left(\\begin{array}{ccccc} A_{11} \u0026amp; A_{12} \u0026amp; \\cdots \u0026amp; A_{1 j} \u0026amp; \\cdots \\nl A_{21} \u0026amp; A_{22} \u0026amp; \\cdots \u0026amp; A_{2 j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\nl A_{i 1} \u0026amp; A_{i 2} \u0026amp; \\cdots \u0026amp; A_{i j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\end{array}\\right)\\left(\\begin{array}{c} c_{1} \\nl c_{2} \\nl \\vdots \\nl \\vdots \\nl c_{j} \\nl \\vdots \\end{array}\\right) $$\nc.数$\\bok{\\varphi}{A}{\\psi}$的矩阵表示 $$ \\bok{\\varphi}{A}{\\psi}=\\sum_{i,j}b^*_iA_{ij}c_j $$\n$$ \\langle\\varphi|A| \\psi\\rangle=\\left(b_{1}^{*} b_{2}^{*} \\cdots b_{i}^{*} \\cdots\\right)\\left(\\begin{array}{ccccc} A_{11} \u0026amp; A_{12} \u0026amp; \\cdots \u0026amp; A_{1 j} \u0026amp; \\cdots \\nl A_{21} \u0026amp; A_{22} \u0026amp; \\cdots \u0026amp; A_{2 j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\nl A_{i 1} \u0026amp; A_{i 2} \u0026amp; \u0026amp; A_{i j} \u0026amp; \\cdots \\nl \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\end{array}\\right)\\left(\\begin{array}{c} c_{1} \\nl c_{2} \\nl \\vdots \\nl c_{j} \\nl \\vdots \\nl \\vdots \\end{array}\\right) $$\nd. $A^\\dagger$的矩阵表示 $$ (A^\\dagger){ij}=A^*{ji} $$\n转置+复数操作。\n若一个算符是 Hermite 的，易知对角元素必为实数（$(A^\\dagger){ij}=A^*{ji}=A_{ij}$）\n5、表象的变换 a.梗概 在一种指定的表象中，右矢等等由一个矩阵表示。换一种表象，那么将由另一个矩阵表示。求这两个矩阵的联系。\n设从${\\ket{u_i}}$变换到${\\ket{t_k}}$。那么定义：\n$$ S_{ik}=\\bk{u_i}{t_k} $$\n那么$S$称为基的变换矩阵。\n（S 是一个幺正矩阵）\nb.右矢分量的变换 $$ \\bk{t_k}{\\psi}=\\sum_i\\bk{t_k}{u_i}\\bk{u_i}{\\psi}=\\sum_iS^\\dagger_{ki}\\bk{u_i}{\\psi} $$\n反向公式：\n$$ \\bk{u_i}{\\psi}=\\sum_iS_{ik}\\bk{t_k}{\\psi} $$\nc.左矢 类似\nd.矩阵元的变换 $$ A_{kl}=\\bok{t_k}{A}{t_l}=\\sum_{i,j}\\bk{t_k}{u_i}\\bok{u_i}{A}{u_j}\\bk{u_j}{t_l}=\\sum_{i,j}S^\\dagger_{ki}A_{ij}S_{jl} $$\n同理：\n$$ A_{ij}=\\sum_{k,l}S_{ik}A_{kl}S^\\dagger_{lj} $$\nComment 这一节介绍了如何在某个表象下表示一个态矢量（分量组成的矩阵），终于使得态矢量脱离了高高在上无法计算的问题~。最后还探讨了表象之间的变换。\n","date":"2021-11-24T19:19:07+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-2-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7-c-part/","title":"[量子力学] 2 量子力学的数学工具 C part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} $$\n这一节可能有点复杂，只要了解上一节各种量可以对应这一节的量，以及了解数学结构即可。\nB 态空间；Dirac 符号 1 引言 通过上一节的讨论，我们发现有许多量的结构是类似的。\n\rimage-20211124122238702\r\n那么我们就可以引入态空间/态矢量的方法来描述这些量。书中是这么讨论的：\n\rimage-20211124122403356\r\n我们定义的态空间是$\\scr E_\\bf r$，是希尔伯特空间的子空间。下一章将要提出的一个假定就是**任何物理体系的量子态都由一个态矢量来描述，态矢量属于$\\scr E$空间，即体系的态空间**\n接下来将定义态空间中的运算及狄拉克符号。\n2、狄拉克符号 a. $\\scr E$空间的元素：右矢（ket） I 定义 标记法：$\\ket{\\psi}$\n我们定义一个一一对应的映射：\n$$ \\psi(\\boldsymbol{r}) \\in \\mathscr{F} \\Longleftrightarrow|\\psi\\rangle \\in \\mathscr{E}_{\\boldsymbol{r}} $$\n\rimage-20211124123336256\r\nII 标量积 $(\\ket\\varphi,\\ket\\psi)$\nb. $\\scr E$的对偶空间$\\scr E^*$：左矢（bra） 线性泛函 balabala。这里不是数学课，要详细了解是什么去看线性代数。\n符号标记：$\\bra{\\psi}$\n总之，左矢也构成一个矢量空间，也符合线性运算。\nc. 左矢与右矢的对应关系 I 对于每一个右矢$\\ket{\\varphi}$，都存在一个左矢$\\bra\\varphi$对应。 两个矢量的标量积：\n$$ \\bk{\\varphi}{\\psi}=(\\ket\\varphi,\\ket\\psi) $$\nII 标量积对于第一个矢量是反线性的（内积的定义）。 而映射也相应的是反线性的：\n$$ \\lambda_{1}\\left|\\varphi_{1}\\right\\rangle+\\lambda_{2}\\left|\\varphi_{2}\\right\\rangle \\Longrightarrow \\lambda_{1}^{*}\\left\\langle\\varphi_{1}\\right|+\\lambda_{2}^{*}\\left\\langle\\varphi_{2}\\right| $$\n简单来说：\n$$ \\begin{eqnarray} \u0026amp;\\ket{\\lambda\\psi}=\\lambda\\ket{\\psi}\\nl \u0026amp;\\bra{\\lambda\\psi}=\\lambda^*\\bra{\\psi}\\nl \\end{eqnarray} $$\nIII 标量积的狄拉克符号 以后以后只用$\\bra\\varphi\\ket{\\psi}$着一种符号\n一些性质：\n\rimage-20211124144504505\r\nIV 有些左矢没有对应的右矢 但这并不影响我们对量子力学的讨论。\n3、线性算符 a. 定义 线性算符使得每一个右矢$\\ket\\psi\\in\\scr E$都有一个对应的右矢$\\ket\\psi'\\in\\scr E$，且对应关系是线性的：\n$$ \\ket{\\psi'}=A\\ket\\psi $$\n对于算符乘法与对易子定义与上一节相同。\n矩阵元：\n$$ \\bra\\varphi (A\\ket{\\psi}) $$\n这是一个数。\nb. 重要例子：投影算符 $$ \\ket\\psi \\bra\\varphi $$\n若取任意一个右矢，使用投影算符进行运算：\n$$ \\ket\\psi \\bk{\\varphi}{\\chi} $$\n可以得到一个右矢，因此证明这是一个算符。\n我们可以见到，符号的先后顺序是十分有意义的。一个数可以随意移动，但算符和左右矢的位置不能移动。\n假设$\\ket\\psi$是归一化的（内积为一），那么定义以下算符：\n$$ P_\\psi=\\ket\\psi \\bra\\psi $$\n将其作用到任意一个右矢上：\n$$ P_\\psi=\\ket\\psi \\bk{\\psi}{\\varphi} $$\n可以清晰的知道他的几何意义：在右矢$\\ket\\psi$上进行垂直投影。\n一些性质：\n$$ P_\\psi^2=P_\\psi $$\n子空间上的投影算符：\n$$ P_q=\\sum_{i=1}^q\\ket{\\varphi_i}\\bra{\\varphi_i} $$\n4、Hermite 共轭 a. 线性算符也能对左矢进行作用 $$ \\bra\\varphi(A\\ket\\psi)=(\\bra\\varphi A)\\ket\\psi=\\bok{\\varphi}{A}{\\psi} $$\n因此$\\bra\\varphi A$是一个左矢。易验证也符合线性组合。\n顺序十分重要。$\\bra\\varphi A$是一个左矢，而$A \\bra\\varphi$是一个算符。\nb. 伴随算符$A^\\dagger$ 左矢和右矢之间的关系作用到一个线性算符上，就能得到它的伴随算符$A^\\dagger$\n\rimage-20211124150647362\r\n根据内积定义：\n$$ \\left\\langle\\psi^{\\prime} \\mid \\varphi\\right\\rangle=\\left\\langle\\varphi \\mid \\psi^{\\prime}\\right\\rangle^{*} $$\n可得：\n$$ \\bra\\psi A^\\dagger \\ket\\varphi=\\bra\\varphi A \\ket \\psi^* $$\n一些符号标注的问题：$\\ket{A\\psi}=A\\ket\\psi$，而$\\bra{A\\psi}=\\bra\\psi A^\\dagger$\nc. 伴随算符易证性质 $$ \\begin{eqnarray} \u0026amp;\\left(A^{\\dagger}\\right)^{\\dagger}=A \\nl \u0026amp;(\\lambda A)^{\\dagger}=\\lambda^{*} A^{\\dagger}(\\lambda \\text { 是一个数 }) \\nl \u0026amp;(A+B)^{\\dagger}=A^{\\dagger}+B^{\\dagger}\\nl \u0026amp;(AB)^\\dagger=B^\\dagger A^\\dagger \\end{eqnarray} $$\nd. Dirac 符号的 Hermite 共轭 简单的例子：\n$$ (\\ket\\psi \\bra\\varphi)^\\dagger=\\ket\\varphi \\bra\\psi $$\n统合成的规则：\n\rimage-20211124151800734\r\ne. Hermite 算符 如果：\n$$ A=A^\\dagger $$\n那么这个算符就是 Hermite 算符。\n一些性质：\n$$ \\begin{eqnarray} \u0026amp;\\bra\\psi A \\ket\\varphi=\\bra\\varphi A \\ket \\psi^*\\nl \u0026amp;P_\\psi^\\dagger=P_\\psi\\nl \u0026amp;[A,B] = 0 \\Rightarrow\\text{(AB)为厄米算符} \\end{eqnarray} $$\nComment 这一节将上一节的运算更加抽象了一层，但适用的范围也更加广泛了。这张主要是定义了态空间的数学结构（希尔伯特空间的子集）和一些运算。下一节将找到$\\scr F$空间和$\\scr E$空间两个之间的关系。\n","date":"2021-11-24T12:19:32+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-2-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7-b-part/","title":"[量子力学] 2 量子力学的数学工具 B part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\newcommand{\\bok}[3]{\\bra{#1}#2\\ket{#3}} \\def\\nl{\\newline} $$\n本篇非常重要！为后面的所有运算都打下了基础。\nA 一个粒子的波函数空间 在整个空间中找到粒子的概率是 1，因此：\n$$ \\int\\dd^3 r|\\psi(\\mbf r,t^2)| = 1 $$\n我们必须研究平方可积函数。\n1、波函数空间$\\scr F$的结构 a. $\\scr F$是一个矢量空间 易证明。线性叠加。\n重要的是平方可积的证明：\n$$ |\\psi(\\boldsymbol{r})|^{2}=\\left|\\lambda_{1}\\right|^{2}\\left|\\psi_{1}(\\boldsymbol{r})\\right|^{2}+\\left|\\lambda_{2}\\right|^{2}\\left|\\psi_{2}(\\boldsymbol{r})\\right|^{2}+\\lambda_{1}^{*} \\lambda_{2} \\psi_{1}^{*}(\\boldsymbol{r}) \\psi_{2}(\\boldsymbol{r})+\\lambda_{1} \\lambda_{2}^{*} \\psi_{1}(\\boldsymbol{r}) \\psi_{2}^{*}(\\boldsymbol{r}) $$\n最后两项的和不大于：\n$$ \\left|\\lambda_{1} | \\lambda_{2}\\right|\\left[\\left|\\psi_{1}(\\boldsymbol{r})\\right|^{2}+\\left|\\psi_{2}(\\boldsymbol{r})\\right|^{2}\\right] $$\n平方可积性质证明完成。\nb. 标量积 I 定义：\n$$ (\\varphi, \\psi)=\\int\\dd^3 r \\varphi^*(\\mbf r)\\psi(\\mbf r) $$\nII 性质：\n$$ \\begin{eqnarray} \u0026amp;(\\varphi, \\psi)=(\\psi, \\varphi)^{*} \\nl \u0026amp;\\left(\\varphi, \\lambda_{1} \\psi_{1}+\\lambda_{2} \\psi_{2}\\right)=\\lambda_{1}\\left(\\varphi, \\psi_{1}\\right)+\\lambda_{2}\\left(\\varphi, \\psi_{2}\\right) \\nl \u0026amp;\\left(\\lambda_{1} \\varphi_{1}+\\lambda_{2} \\varphi_{2}, \\psi\\right)=\\lambda_{1}^{*}\\left(\\varphi_{1}, \\psi\\right)+\\lambda_{2}^{*}\\left(\\varphi_{2}, \\psi\\right) \\end{eqnarray} $$\n第二个因子的关系是线性的，第一个因子的关系是反线性的。$(\\varphi, \\psi)=0$，就说明这两个波函数是正交的。\n$$ (\\psi, \\psi)=\\int \\mathrm{d}^{3} r|\\psi(\\boldsymbol{r})|^{2} $$\n为正实数，当且仅当$\\psi(\\mbf r)=0$时，它才为 0.\n$\\sqrt{(\\psi,\\psi)}$叫做$\\psi$的模。\nSchwartz 不等式：\n$$ |(\\psi_1,\\psi_2)|\\le\\sqrt{(\\psi_1,\\psi_1)}\\cdot\\sqrt{(\\psi_2,\\psi_2)} $$\nc. 线性算符 I 定义：\n$$ \\begin{eqnarray} \u0026amp;\\psi^{\\prime}(\\boldsymbol{r})=A \\psi(\\boldsymbol{r}) \\nl \u0026amp;A\\left[\\lambda_{1} \\psi_{1}(\\boldsymbol{r})+\\lambda_{2} \\psi_{2}(\\boldsymbol{r})\\right]=\\lambda_{1} A \\psi_{1}(\\boldsymbol{r})+\\lambda_{2} A \\psi_{2}(\\boldsymbol{r}) \\end{eqnarray} $$\n一些有意思的算符：\n$$ \\begin{eqnarray} \u0026amp;\\Pi\\psi(x,y,z) = \\psi(-x,-y,-z) \\qquad\\text{宇称算符}\\nl \u0026amp;X\\psi(x,y,z) = x\\psi(x,y,z)\\qquad\\text{倍乘算符}\\nl \u0026amp;D_x\\psi(x,y,z)=\\frac{\\par \\psi(x,y,z)}{\\par x}\\qquad\\text{对x求导数的算符} \\end{eqnarray} $$\nII 乘积：\n$$ (AB)\\psi(\\mbf r)=A[B\\psi(\\mbf r)] $$\nIII 对易子定义：\n$$ [A,B]=AB-BA $$\n2、$\\scr F$中离散的正交归一基：${u_i(\\mbf r)}$ I 定义： 设$\\scr F$空间中的一个可列的函数集合，其中的函数可以用离散的指标$i=1,2,\\cdots,n,\\cdots$标记：\n$$ u_i(\\mbf r)\\in\\scr F, $$\n若符合以下条件：\n1、正交归一条件：\n$$ (u_i,u_j)=\\int\\dd^3 ru_i^*(\\mbf r) u_j(\\mbf r)=\\delta_{ij} $$\n2、完备性：（每一个波函数都能按唯一全体的$u_i(\\mbf r)$展开）：\n$$ \\psi(\\mbf r)=\\sum_ic_iu_i(\\mbf r) $$\n则${u_i(\\mbf r)}$构成一个基。\nII 求波函数在基上的分量： $$ c_i=(u_i,\\psi)=\\int\\dd^3 r u_i^*(\\mbf r) \\psi(\\mbf r) $$\nIII 标量积表示为分量的函数： $$ \\begin{eqnarray} \u0026amp;\\varphi(\\mbf r)=\\sum_ib_iu_i(\\mbf r) \\nl \u0026amp;\\psi(\\mbf r)=\\sum_jc_ju_j(\\mbf r) \\end{eqnarray} $$\n那么：\n$$ \\begin{eqnarray} \u0026amp;(\\varphi,\\psi)=\\sum_ib_i^*c_i \\nl \u0026amp;(\\psi,\\psi)=\\sum_i|c_i|^2 \\end{eqnarray} $$\nIV 封闭性关系式： $$ \\begin{align} \\psi(\\mbf r)=\\sum_i c_i u_i(\\mbf r) \u0026amp;=\\sum_i[\\int\\dd^3 r' u_i^* (\\mbf r') \\psi(\\mbf r')] u_i(\\mbf r) \\nl \u0026amp;= \\int \\dd^3 r'\\psi(\\mbf r')[\\sum_i u_i^*(\\mbf r')u_i(\\mbf r)] \\nl \u0026amp;= \\int \\dd^3 r'\\psi(\\mbf r')F(\\mbf r,\\mbf r') \\end{align} $$\n这正是$\\delta(\\mbf r-\\mbf r')$的性质，因此（封闭性关系式）：\n$$ \\sum_i u_i^*(\\mbf r')u_i(\\mbf r)=\\delta(\\mbf r-\\mbf r') $$\n3 引入不属于$\\scr F$的基 两个例子：$v_p=\\frac{1}{\\sqrt{2\\pi\\hbar}}e^{ipx/\\hbar}$和$\\xi_{\\mbf r_0}(\\mbf r)=\\delta(\\mbf r - \\mbf r_0)$\nc 连续的正交归一基 与离散的基相似，只不过它是连续的，$\\sum\\rightarrow\\int, \\delta_{ij}\\rightarrow\\delta(\\mbf r-\\mbf r')$\n正交归一及封闭性关系式：\n$$ \\begin{eqnarray} \u0026amp;\\left(w_{\\alpha}, w_{\\alpha^{\\prime}}\\right)=\\int \\mathrm{d}^{3} r w_{\\alpha}^{*}(\\boldsymbol{r}) w_{\\alpha^{\\prime}}(\\boldsymbol{r})=\\delta\\left(\\alpha-\\alpha^{\\prime}\\right) \\nl \u0026amp;\\int \\mathrm{d} \\alpha w_{\\alpha}(\\boldsymbol{r}) w_{\\alpha}^{*}\\left(\\boldsymbol{r}^{\\prime}\\right)=\\delta\\left(\\boldsymbol{r}-\\boldsymbol{r}^{\\prime}\\right) \\end{eqnarray} $$\n综合的表格：\n\rimage-20211124121120236\r\nComment 整个推导类似于矢量运算。$\\psi(\\mbf r)$为所求的矢量，$u_i(\\mbf r)$为基矢量（类似于$\\hat{\\imath},\\hat{\\jmath},\\hat{k}$），内积相当于矢量运算中的点乘。基具有正交归一和封闭性关系式（类似于$\\hat{\\imath},\\hat{\\jmath},\\hat{k}$正交及）。\n展开式会出现分量$c_i$，即$\\psi$在某个基$u_i$上的分解。求分量$c_i$则类似于矢量求点乘（在某个方向上分解）。\n","date":"2021-11-23T20:09:10+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-2-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7-a-part/","title":"[量子力学] 2 量子力学的数学工具 A part"},{"content":"$$ \\def\\un{\\mathrm} \\def\\dd{\\mathrm d} \\def\\par{\\partial} \\def\\bl{\\boldsymbol} \\def\\mbf{\\mathbf} \\newcommand{\\bk}[2]{\\left \\langle #1 | #2 \\right \\rangle} \\def\\nl{\\newline} $$\n本篇未完善。\nA 电磁波与光子 1、光量子与普朗克-爱因斯坦关系 对黑体辐射的研究提出了能量量子化（Planck）\n普朗克-爱因斯坦关系（粒子性参量$E, \\mbf p$和波动性参量$\\omega, \\mbf k$之间的关系）：\n$$ \\begin{eqnarray} E=h\\nu=\\hbar \\omega \\nl \\mbf{p}=\\hbar \\mbf{k} \\end{eqnarray} $$\n普朗克常数$h$:\n$$ h = 6.62\\times 10^{-34} \\rm{J\\cdot s} $$\n2、波粒二象性 证据：杨氏双缝干涉——能通过双缝形成分布图（并不是完全的粒子性），强度分布并不是直接相加的（并不是完全的波动性）。\n对波粒二象性的概念：\n 光的粒子性和波动性是不可分割的。 对光子行为的预言只能是概率性的。 波$E(\\mbf r, t)$提供一个光子在$t$时刻的信息。其为概率幅，概率正比为$|E(\\mbf{r},t )|^2$  3、谱分解原理 对光的偏振的一种解释。\n当光子是一个一个通过检偏器时（光子是无法被分解的），那么这个光子要么通过，要么被吸收，其概率为$\\cos^2\\theta$。当通过的光子足够多时，便可以得出经典结论。\n得出结论：\n 测量仪器只能给出特殊的结果，被称为本征结果。 每一个本征结果都有一个对应的本征态。 对于 $\\mbf{e}_p$ 我们可以写出： $\\mbf e_p=\\mbf e_x\\cos\\theta+\\mbf e_y\\sin\\theta$ 。这被叫做谱分解原理。 测量后态改变了，因此测量从根本上干扰了微观体系。  B 物质粒子与物质波 1、de Broglie 关系 de Brogile 假说：其他粒子与光子完全一样，是波粒二象性的。\n德布罗意关系式：\n$$ \\lambda=\\frac{2\\pi}{|\\mbf k|}=\\frac{h}{|\\mbf p|} $$\n2、波函数，Schrödinger 方程 1、一个粒子是由一个波函数$\\psi(\\mbf r, t)$描述的，一个波函数包含了所有关于这个粒子的信息。\n2、$\\psi(\\mbf r, t)$为粒子的概率幅，则$|\\psi(\\mbf r, t)|^2$为概率密度。在时间$t$，某个体积元$\\dd^3 r=\\dd x\\dd y\\dd z$中，概率密度为：\n$$ \\dd \\scr{P(\\mbf r, t)} = C|\\psi(\\mbf r, t)|^2\\dd^3 r $$\n3、谱分解原理适用于任意物理量$\\scr A$的测量：\n(a) 所属结果一定为本征值的集合${a}$\n(b) 每一个本征值 a 都有一个本征态和它联系。\n(c)\n$$ \\begin{eqnarray} \u0026amp;\\psi(\\mbf r, t_0)=\\sum_a c_a\\psi_a(\\mbf r) \\nl \u0026amp;\\scr P_a = \\frac{|c_a|^2}{\\sum_1 |c_a|^2} \\end{eqnarray} $$\n粒子波函数随时间变化的方程（Schrödinger 方程）\n$$ i \\hbar\\frac{\\par}{\\par t}\\psi(\\mbf r,t)=-\\frac{\\hbar^2}{2m}\\triangle\\psi(\\mbf r,t)+V(\\mbf r,t)\\psi(\\mbf r,t) $$\n其中$\\triangle=\\nabla^2=\\frac{\\par^2}{\\par x^2}+\\frac{\\par^2}{\\par y^2}+\\frac{\\par^2}{\\par z^2}$为拉普拉斯算符。这个方程是线性齐次的。\nC 对一个粒子的量子描述，波包 1、自由粒子 若一个粒子在空间各点的势能都为 0（常数），则这个粒子未受力作用，即自由粒子。\n此时的 Schrodinger 方程：\n$$ i \\hbar\\frac{\\par}{\\par t}\\psi(\\mbf r,t)=-\\frac{\\hbar^2}{2m}\\triangle\\psi(\\mbf r,t) $$\n这个微分方程的解为横向波：\n$$ \\psi(\\mbf r,t)=Ae^{i(\\mbf k\\cdot\\mbf r-\\omega t)} $$\n量纲为 0，则$\\mbf k$与$\\omega$之间的关系为：\n$$ \\begin{eqnarray} \u0026amp;\\omega = \\frac{\\hbar \\mbf k^2}{2m} \\nl \u0026amp;E=\\frac{\\mbf p^2}{2m} (\\text{de Brogile}) \\end{eqnarray} $$\n由于$|\\psi(\\mbf r,t)|^2=|A|^2$，因此它在空间中各点出现的概率都一样。\n叠加原理：各平面波的一切线性组合，都是该方程的解：\n$$ \\psi(\\boldsymbol{r}, t)=\\frac{1}{(2 \\pi)^{3 / 2}} \\int g(\\boldsymbol{k}) \\mathrm{e}^{\\mathrm{i}[\\boldsymbol{k} \\cdot \\boldsymbol{r}-\\omega(k) t]} \\mathrm{d}^{3} k $$\n这种类型的波函数，叫做一个三维波包。后面研究一维波包的情况。\n$$ \\psi(x, t)=\\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{+\\infty} g(k) \\mathrm{e}^{\\mathrm{i}[k x-\\omega(k) t]} \\mathrm{d} k $$\n2、波包在指定时刻的形状 3、Heisenberg 不确定性原理 4、自由波包随时间的演变 群速度、相速度。\nD 与时间无关标量式场中的粒子 1、定态解 $$ i \\hbar\\frac{\\par}{\\par t}\\psi(\\mbf r,t)=-\\frac{\\hbar^2}{2m}\\triangle\\psi(\\mbf r)+V(\\mbf r,t)\\psi(\\mbf r,t) $$\n分离变量：\n$$ \\psi(\\mbf r,t) = \\varphi(\\mbf r)\\chi(t) $$\n代入 Schrodinger 方程并令两边等于一个常数$E=\\hbar\\omega$（数理方法常用分离变量操作），可得：\n$$ \\begin{eqnarray} \u0026amp;\\chi(t)=Ae^{-i \\omega t}\\nl \u0026amp;-\\frac{\\hbar^{2}}{2 m} \\Delta \\varphi(\\boldsymbol{r})+V(\\boldsymbol{r}) \\varphi(\\boldsymbol{r})=\\hbar \\omega \\varphi(\\boldsymbol{r})\\nl \u0026amp;\\psi(\\mbf r, t) = \\varphi(\\mbf r)e^{-i\\omega t} \\end{eqnarray} $$\n称为 Schrodinger 方程的定态解。定态指的是$E=\\hbar \\omega$的解\n可以重新组合成：\n$$ \\begin{eqnarray} \u0026amp;[-\\frac{\\hbar^2}{2m}\\triangle+V]\\varphi=E\\varphi \\Rightarrow H\\varphi=E\\varphi \\nl \u0026amp;\\text{where}\\quad H = -\\frac{\\hbar^2}{2m}\\triangle+V \\end{eqnarray} $$\n则意味着$H$式一个测量量，作用到$\\varphi$上得到能量作为本征值。（能量量子化的起因）\n定态叠加：\n$$ \\begin{eqnarray} \u0026amp;H\\varphi_n(\\mbf r) = E_n\\varphi_n(\\mbf r)\\nl \u0026amp;\\psi(\\mbf r,t)=\\varphi_n(\\mbf r)e^{-iE_n/t}\\nl \u0026amp;\\psi(\\mbf r,t)=\\sum_nc_n\\varphi_n(\\mbf r)e^{-iE_n/t}\\nl \u0026amp;\\psi(\\mbf r,0)=\\sum_nc_n\\varphi_n(\\mbf r) \\end{eqnarray} $$\n2、各种情况的求解 见附属材料以及隔壁 Griffiths\n","date":"2021-11-23T17:37:48+08:00","permalink":"https://mizarzh.github.io/p/2021/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6-1-%E6%B3%A2%E5%92%8C%E7%B2%92%E5%AD%90%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"[量子力学] 1 波和粒子；量子力学的基本概念"},{"content":"rust初体验\u0026amp;一些易忘原则/语句 1、函数不用生命周期注解的条件：\n 第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo\u0026lt;'a, 'b\u0026gt;(x: \u0026amp;'a i32, y: \u0026amp;'b i32)，依此类推。\n第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo\u0026lt;'a\u0026gt;(x: \u0026amp;'a i32) -\u0026gt; \u0026amp;'a i32。\n第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 \u0026amp;self 或 \u0026amp;mut self，说明是个对象的方法(method)(译者注： 这里涉及rust的面向对象参见17章), 那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。\n 2、if let是match语句的语法糖，使用else来切换不同match的分支。\n3、Result\u0026lt;T, E\u0026gt;的用法。Ok(T)中包含正确的值，Err(E)包含错误的值。\n4、?运算符是用于返回Result\u0026lt;T, E\u0026gt;的语句中用的，是一个语法糖，其意思是如果正常则让返回表达式返回语句Ok()，如果错误则return Err();（注意有return）。\n5、ref\n如果一个值并非引用，但你又想匹配它而不获取他的所有权，那么就可以使用ref运算符（当然多定义一个变量使用引用也可以，但是不如这么写方便）：\nletmaybe_name=Some(String::from(\u0026#34;Alice\u0026#34;));matchmaybe_name{Some(n)=\u0026gt;println!(\u0026#34;Hello, {}\u0026#34;,n),_=\u0026gt;println!(\u0026#34;Hello, world\u0026#34;),}println!(\u0026#34;Hello again, {}\u0026#34;,maybe_name.unwrap_or(\u0026#34;world\u0026#34;.into()));// 错误，因为maybe_name已经在match语句中被使用 letmaybe_name=Some(String::from(\u0026#34;Alice\u0026#34;));matchmaybe_name{Some(refn)=\u0026gt;println!(\u0026#34;Hello, {}\u0026#34;,n),_=\u0026gt;println!(\u0026#34;Hello, world\u0026#34;),}println!(\u0026#34;Hello again, {}\u0026#34;,maybe_name.unwrap_or(\u0026#34;world\u0026#34;.into()));// 正确，因为使用了ref，将自动转换成引用 // 一个解释： // A `ref` borrow on the left side of an assignment is equivalent to // an `\u0026amp;` borrow on the right side. letrefref_c1=c;letref_c2=\u0026amp;c;6、trait的行为类似于java中的interface？\n7、类型转换的trait\n使用的trait（From, Into）：\nimplFrom\u0026lt;T\u0026gt;forxxx{fn from(item: T)-\u0026gt; Self{...// 返回转换后的Self }}如果可能转换不成功，则使用的trait（TryFrom, TryInto）：\nimplTryFrom\u0026lt;T\u0026gt;forxxx{type Error=();fn try_from(value: T)-\u0026gt; Result\u0026lt;Self,Self::Error\u0026gt;{// Ok() Err() }}8、move运算符\n用于在闭包中获取捕获参数的所有权。\nfn main(){// `Vec` has non-copy semantics. lethaystack=vec![1,2,3];letcontains=move|needle|haystack.contains(needle);println!(\u0026#34;{}\u0026#34;,contains(\u0026amp;1));println!(\u0026#34;{}\u0026#34;,contains(\u0026amp;4));// println!(\u0026#34;There\u0026#39;re {} elements in vec\u0026#34;, haystack.len()); 行不通， // 因为contains函数中使用了haystack，获取了其所有权 }9、match中的guard和binding：\nguard：\nmatchpair{(x,y)ifx==y=\u0026gt;println!(\u0026#34;These are twins\u0026#34;),// The ^ `if condition` part is a guard (x,y)ifx+y==0=\u0026gt;println!(\u0026#34;Antimatter, kaboom!\u0026#34;),(x,_)ifx%2==1=\u0026gt;println!(\u0026#34;The first one is odd\u0026#34;),_=\u0026gt;println!(\u0026#34;No correlation...\u0026#34;),}binding（想要判断同时捕获值）：\n// A function `age` which returns a `u32`. fn age()-\u0026gt; u32 {15}fn main(){println!(\u0026#34;Tell me what type of person you are\u0026#34;);matchage(){0=\u0026gt;println!(\u0026#34;I haven\u0026#39;t celebrated my first birthday yet\u0026#34;),n@1..=12=\u0026gt;println!(\u0026#34;I\u0026#39;m a child of age {:?}\u0026#34;,n),// 匹配到1-12，就走这一支 n@13..=19=\u0026gt;println!(\u0026#34;I\u0026#39;m a teen of age {:?}\u0026#34;,n),// 匹配13-19，就走这一支 n=\u0026gt;println!(\u0026#34;I\u0026#39;m an old person of age {:?}\u0026#34;,n),}}10、结构体方法中的self相关写法：\nstruct Number{value: i32,}implNumber{// 这个是结构体函数 fn new(val: i32)-\u0026gt; Number{Number{value: val}}// 这个是结构体方法 // \u0026amp;self是self: \u0026amp;Self的语法糖，代表借用且不会修改值 fn print(\u0026amp;self){println!(\u0026#34;{}\u0026#34;,self.value);}// \u0026amp;mut self是self: \u0026amp;mut Self的语法糖，代表借用且会修改值 fn change(\u0026amp;mutself,val: i32){self.value=val;}// self是self: Self的语法糖，代表这个方法会获取所有权，结束之后对象会销毁 fn destroy(self){println!(\u0026#34;Destroying Number({})\u0026#34;,self.value);}}11、闭包遵循的trait：\n Fn: the closure captures by reference (\u0026amp;T) FnMut: the closure captures by mutable reference (\u0026amp;mut T) FnOnce: the closure captures by value (T)  12、impl trait\ntrait可以当作参数来传递，但需要使用impl trait语句来传递：\ntraitc{fn print(\u0026amp;self);}fn some_function(f: implc)-\u0026gt; implc13、where语句\n可以是缩写：\nimpl\u0026lt;A: TraitB+TraitC,D: TraitE+TraitF\u0026gt;MyTrait\u0026lt;A,D\u0026gt;forYourType{}// Expressing bounds with a `where` clause impl\u0026lt;A,D\u0026gt;MyTrait\u0026lt;A,D\u0026gt;forYourTypewhereA: TraitB+TraitC,D: TraitE+TraitF{}也可以是更具体的条件：\nusestd::fmt::Debug;traitPrintInOption{fn print_in_option(self);}// Because we would otherwise have to express this as `T: Debug` or // use another method of indirect approach, this requires a `where` clause: impl\u0026lt;T\u0026gt;PrintInOptionforTwhereOption\u0026lt;T\u0026gt;: Debug{// We want `Option\u0026lt;T\u0026gt;: Debug` as our bound because that is what\u0026#39;s // being printed. Doing otherwise would be using the wrong bound. fn print_in_option(self){println!(\u0026#34;{:?}\u0026#34;,Some(self));}}14、泛型impl\n如果一个struct是泛型的，那么impl也记得要加上\u0026lt;T\u0026gt;。对于某个特定的类型，就直接写：\nstruct Number\u0026lt;T\u0026gt;{value: T,}impl\u0026lt;T\u0026gt;Number\u0026lt;T\u0026gt;{...}implNumber\u0026lt;i32\u0026gt;{...}15、多个trait组合使用+号\n泛型trait可以被限定（bound）：\nfn some_fn\u0026lt;T: Display\u0026gt;16、newtype与alias的区别\n顾名思义，newtype是将一个类型包装成另一个类型，但其实本意并不是包装，而是一个只含有一个元素的结构体元组。newtype与原类型不同。\n而alias是一种类型的别名。别名与原类型相同。\n// newtype struct Days(i64);// alias type Days=i64;17、Associated types\n在使用泛型的时候，有可能遇到AB两个类型与另一个类型C有关。\n18、Phantom type\n当作是一个占位符使用。例如可以建立一个单位类型Unit来保存各种单位，然后再新建一个struct，搭配数字+单位来储存一个量。但Unit是不占空间的，因此需要使用Phantom type占有这个位置。\nusestd::ops::Add;usestd::marker::PhantomData;/// Create void enumerations to define unit types. #[derive(Debug, Clone, Copy)]enum Inch{}#[derive(Debug, Clone, Copy)]enum Mm{}/// `Length` is a type with phantom type parameter `Unit`, /// and is not generic over the length type (that is `f64`). /// /// `f64` already implements the `Clone` and `Copy` traits. #[derive(Debug, Clone, Copy)]struct Length\u0026lt;Unit\u0026gt;(f64,PhantomData\u0026lt;Unit\u0026gt;);/// The `Add` trait defines the behavior of the `+` operator. impl\u0026lt;Unit\u0026gt;AddforLength\u0026lt;Unit\u0026gt;{type Output=Length\u0026lt;Unit\u0026gt;;// add() returns a new `Length` struct containing the sum. fn add(self,rhs: Length\u0026lt;Unit\u0026gt;)-\u0026gt; Length\u0026lt;Unit\u0026gt;{// `+` calls the `Add` implementation for `f64`. Length(self.0+rhs.0,PhantomData)}}fn main(){// Specifies `one_foot` to have phantom type parameter `Inch`. letone_foot: Length\u0026lt;Inch\u0026gt;=Length(12.0,PhantomData);// `one_meter` has phantom type parameter `Mm`. letone_meter: Length\u0026lt;Mm\u0026gt;=Length(1000.0,PhantomData);// `+` calls the `add()` method we implemented for `Length\u0026lt;Unit\u0026gt;`. // // Since `Length` implements `Copy`, `add()` does not consume // `one_foot` and `one_meter` but copies them into `self` and `rhs`. lettwo_feet=one_foot+one_foot;lettwo_meters=one_meter+one_meter;// Addition works. println!(\u0026#34;one foot + one_foot = {:?} in\u0026#34;,two_feet.0);println!(\u0026#34;one meter + one_meter = {:?} mm\u0026#34;,two_meters.0);// Nonsensical operations fail as they should: // Compile-time Error: type mismatch. //let one_feter = one_foot + one_meter; }19、生命周期注解：\nfn haha\u0026lt;\u0026#39;a,\u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;ai32,y:\u0026amp;\u0026#39;bi32)-\u0026gt; \u0026amp;\u0026#39;ai32{}意思是'a, 'b这两个注解的变量至少应该比这个函数（方法，结构体etc）存活得长。\n本质上来说'a是一个trait，因此:, +运算可以用到这上面\nIt\u0026rsquo;s important to understand this means that any owned data always passes a 'static lifetime bound, but a reference to that owned data generally does not:\n20、supertrait\ntrait也能套娃，以实现继承的功能：\ntraitPerson{fn name(\u0026amp;self)-\u0026gt; String;}// Person is a supertrait of Student. // Implementing Student requires you to also impl Person. traitStudent: Person{fn university(\u0026amp;self)-\u0026gt; String;}traitProgrammer{fn fav_language(\u0026amp;self)-\u0026gt; String;}// CompSciStudent (computer science student) is a subtrait of both Programmer // and Student. Implementing CompSciStudent requires you to impl both supertraits. traitCompSciStudent: Programmer+Student{fn git_username(\u0026amp;self)-\u0026gt; String;}fn comp_sci_student_greeting(student: \u0026amp;dynCompSciStudent)-\u0026gt; String {format!(\u0026#34;My name is {} and I attend {}. My favorite language is {}. My Git username is {}\u0026#34;,student.name(),student.university(),student.fav_language(),student.git_username())}fn main(){}20、\u0026lt;Form as UsernameWidget\u0026gt;语法\n如果trait中有同名的方法怎么办？定义方法倒很简单，因为使用的是两个不同的impl语句，但调用就需要使用此语法：\n\u0026lt;Form as UsernameWidget\u0026gt;::method()，意思就是转换成某个trait再调用其方法\ntraitUsernameWidget{// Get the selected username out of this widget fn get(\u0026amp;self)-\u0026gt; String;}traitAgeWidget{// Get the selected age out of this widget fn get(\u0026amp;self)-\u0026gt; u8;}// A form with both a UsernameWidget and an AgeWidget struct Form{username: String,age: u8,}implUsernameWidgetforForm{fn get(\u0026amp;self)-\u0026gt; String {self.username.clone()}}implAgeWidgetforForm{fn get(\u0026amp;self)-\u0026gt; u8 {self.age}}fn main(){letform=Form{username: \u0026#34;rustacean\u0026#34;.to_owned(),age: 28,};// If you uncomment this line, you\u0026#39;ll get an error saying // \u0026#34;multiple `get` found\u0026#34;. Because, after all, there are multiple methods // named `get`. // println!(\u0026#34;{}\u0026#34;, form.get()); letusername=\u0026lt;FormasUsernameWidget\u0026gt;::get(\u0026amp;form);assert_eq!(\u0026#34;rustacean\u0026#34;.to_owned(),username);letage=\u0026lt;FormasAgeWidget\u0026gt;::get(\u0026amp;form);assert_eq!(28,age);}21、Iterator和Vec, Array的关系：\n迭代器可以使用next()方法遍历。Vec, Array则是数据类型。\n迭代器可以使用.collect()方法变成Vec，Vec, Array, slice可以使用.iter()方法变成Iterator。\n(1..10)语句生成迭代器。\n当然，Iterator也有区别：\n iter(), which iterates over \u0026amp;T. iter_mut(), which iterates over \u0026amp;mut T. into_iter(), which iterates over T.  疑问：\npubtraitAdd\u0026lt;RHS=Self\u0026gt;{type Output;fn add(self,rhs: RHS)-\u0026gt; Self::Output;}\u0026lt;RHS = Self\u0026gt;这是个啥\n稍微查过一下，rust暂时还没有加入函数默认值的功能，那么加入=号就十分的奇怪。\n","date":"2021-11-21T00:19:05+08:00","permalink":"https://mizarzh.github.io/p/2021/11/rust%E6%9D%82%E7%A2%8E%E7%AC%94%E8%AE%B0/","title":"Rust杂碎笔记"},{"content":"通用 1、对于属性描述符的介绍见MDN 属性描述符\n构造函数 // 对象初始化器（Object initialiser）或对象字面量（literal） { [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] } // 以构造函数形式来调用 new Object([value]) Object构造函数，会根据给定的参数创建对象，具体有以下情况：\n 如果给定值是 null 或 undefined，将会创建并返回一个空对象 如果传进去的是一个基本类型的值，则会构造其包装类型的对象 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址  当以非构造函数形式被调用时，Object 的行为等同于 new Object()。\n静态方法 I 构建 Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的_proto_。\n语法：\nObject.create(proto，[propertiesObject]) proto：新创建对象的原型对象。\n返回：Object，带着指定的原型对象和属性。\n注意点\n如果proto参数不是 null或非原始包装对象，则抛出一个 TypeError 异常。\n可以用于继承中：\nfunction Father() { this.val = 0; } Father.prototype.add = function(x) { this.val += x; } function Son() { father.call(this); } Son.prototype = Object.create(Father.prototype); // here Son.prototype.constructor = Son; Object.assign() 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。\n语法：\nObject.assign(target, ...sources)   target\n目标对象。\n  sources\n源对象。\n  返回：Object，改变后的对象。\n注意点\n如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。\nObject.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。\n若使用assign方法复制到一个空对象中，新对象与旧对象没有关系，即复制是深复制（但若原对象中含有引用类型，则这些引用类型仍是浅复制的）。\nII 操作 Object.defineProperty() 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n语法：\nObject.defineProperty(obj, prop, descriptor)   obj\n要定义属性的对象。\n  prop\n要定义或修改的属性的名称或 Symbol。\n  descriptor\n要定义或修改的属性描述符。\n  返回：被传递给函数的对象。\n例子：\nObject.defineProperty(obj, \u0026#34;key\u0026#34;, { enumerable: false, configurable: false, writable: false, value: \u0026#34;static\u0026#34; }); Object.defineProperties() 语法：\nObject.defineProperties(obj, props) 返回：传递给函数的对象。\n例子：\nvar obj = {}; Object.defineProperties(obj, { \u0026#39;property1\u0026#39;: { value: true, writable: true }, \u0026#39;property2\u0026#39;: { value: \u0026#39;Hello\u0026#39;, writable: false } }); Object.setPrototypeOf() 设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。\n语法：\nObject.setPrototypeOf(obj, prototype)   obj\n要设置其原型的对象。.\n  prototype\n该对象的新原型(一个对象或 null)。\n  返回：传递给函数的对象。\n注意点：\n由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。因此最好使用Object.create()\nObject.preventExtensions() 让一个对象变的不可扩展，也就是永远不能再添加新的属性。\n语法：\nObject.preventExtensions(obj) 返回：已经不可扩展的对象。\n它将永远不会具有它被标记为不可扩展时持有的属性之外的属性。\n注意点：\n仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。\nObject.freeze() 可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。\n语法：\nObject.freeze(obj) 返回：和传入的参数相同的对象。\n这个方法返回传递的对象，而不是创建一个被冻结的副本。\nObject.seal() 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。\n语法：\nObject.seal(obj) 返回：被密封的对象。\npreventExtensions、seal和freeze的差别 preventExtensions：将对象标记为不可拓展，即不能添加新的属性。\nseal：密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置，属性不可配置的效果就是属性变的不可删除。但属性的值仍然可以修改。\nfreeze：冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。\nIII 获取属性(get) Object.getOwnPropertyDescriptor() 返回指定对象上一个自有属性对应的属性描述符。\n语法：\nObject.getOwnPropertyDescriptor(obj, prop)   obj\n需要查找的目标对象\n  prop\n目标对象内属性名称\n  返回：Object，如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。\n例子：\nvar obj = {a: 1}; Object.getOwnPropertyDescriptor(obj, \u0026#39;a\u0026#39;); // 返回 Object { value: 1, writable: true, enumerable: true, configurable: true } Object.getOwnPropertyDescriptors() 获取一个对象的所有自身属性的描述符。\n语法：\nObject.getOwnPropertyDescriptors(obj) 返回：Array，所指定对象的所有自身属性的描述符。如果没有任何自身属性，则返回空对象。\nObject.getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。\n语法：\nObject.getOwnPropertyNames(obj) 返回：Array，在给定对象上找到的自身属性对应的字符串数组。\n例子：\n// 接obj Object.getOwnPropertyNames(obj) // [\u0026#39;a\u0026#39;] Object.getOwnPropertySymbols() 返回一个给定对象自身的所有 Symbol 属性的数组。\n语法：\nObject.getOwnPropertySymbols(obj) 返回：Array，在给定对象自身上找到的所有 Symbol 属性的数组。\n与Object.getOwnPropertyNames()类似。\nObject.getPrototypeOf() 返回指定对象的原型（内部[[Prototype]]属性的值）。\n语法：\nObject.getPrototypeOf(obj) 返回：Object，给定对象的原型。如果没有继承属性，则返回 null。\nIV 判断类型(is) Object.is() 判断两个值是否为同一个值。\n语法：\nObject.is(value1, value2); 返回：bool\n注意点：\n与=== 运算也不相同。 === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将Number.NaN与NaN视为不相等.\npolyfill：\nif (!Object.is) { Object.is = function(x, y) { if (x === y) { // ===判断  // +0和-0不相同  return x !== 0 || 1 / x === 1 / y; } else { // NaN===NaN  return x !== x \u0026amp;\u0026amp; y !== y; } }; } Object.isExtensible(obj) 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\nObject.isFrozen(obj) 判断对象是否已经冻结。\nObject.isSealed(obj) 判断对象是否已经密封。\nV 迭代器 Object.entries() Object.keys() Object.values() 与Array差不多，同样是返回不同的迭代器。\nVI 实验性功能 Object.hasOwn() 查看是否含有指定的属性。\n语法：\nObject.hasOwn(instance,prop) 返回：bool\n如果这个物体含有此属性则返回true，如果这个属性是继承的或不存在，则返回false。\n原型属性/方法 Object#constructor 返回创建实例对象的 Object构造函数的引用。\n例子：\nvar o = {}; o.constructor === Object; // true  var o = new Object; o.constructor === Object; // true  var a = []; a.constructor === Array; // true  var a = new Array; a.constructor === Array // true  var n = new Number(3); n.constructor === Number; // true Object#hasOwnProperty(object) 指示对象自身属性中是否具有指定的属性。\n和in运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\nObject#isPrototypeOf(object) 测试一个对象是否存在于另一个对象的原型链上。\nObject#propertyIsEnumerable(object) 测试指定的属性是否可枚举。\nObject#toLocaleString() Object#toString() Object#valueOf() 不解释。\n","date":"2021-11-13T18:14:10+08:00","permalink":"https://mizarzh.github.io/p/2021/11/object%E6%96%B9%E6%B3%95/","title":"Object方法"},{"content":"1 通用提示 1、Array#someMethod()的含义是Array.prototype.someMethod()。\n2、通常，callback即测试每个元素的函数，接收element：当前值、index：当前索引、array：当前数组三个值。若不解释，则默认为此格式。\n3、thisArg是传入执行callback时作为this对象的值。\n4、修改数组的许多操作都是浅复制的。浅复制对于原生类型来说就是直接复制，新值与旧值没有关系，而对于引用类型来说类似于复制指向他们的指针，修改其中一个，其余被复制的都会改变。\n2 构造 Array() Array(3)：构造出[ , , ]，其中是空槽（与undefined不同）。\nArray(1,2,3)：构造出[1,2,3]。\n与new Array()相同。\n3 静态方法 Array.from() 语法：\nArray.from(arrayLike[, mapFn[, thisArg]]) 从类数组对象或者可迭代对象（arrayLike参数）中创建一个新的数组实例。能转换的类型有：\n1、伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）\n2、可迭代对象（可以获取对象中的元素,如 Map和 Set 等）\n有一个可选参数mapFn：如果指定了该参数，新数组中的每个元素会执行该回调函数（使用map方法）。\nArray.isArray() 用来判断某个变量是否是一个数组对象\n语法：\nArray.isArray() 返回：bool\nArray.of() 创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。\n语法：\nArray.of(element0[, element1[, ...[, elementN]]]) 返回：Array\n同样也是创建数组，但与Array()的不同点是Array.of(3)构造出[3]，而Array(3)构造出[ , , ]。\n4 实例方法 I 查找 以下方法都不会修改原数组。\nArray#includes() 方法用来判断一个数组是否包含一个指定的值\n语法：\narr.includes(valueToFind[, fromIndex]) fromIndex参数指的是从某个索引开始搜索，负数索引即从尾部某个元素开始。\n输出：bool\n注意点\n如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。\nincludes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。\nArray#indexOf() 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。\n语法：\narr.indexOf(searchElement[, fromIndex]) 输出：number\nArray#LastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。\n语法：\narr.lastIndexOf(searchElement[, fromIndex]) 输出：number\nArray#find() 返回数组中满足提供的测试函数的第一个元素的值。\n语法：\narr.find(callback[, thisArg]) 返回：找到的元素，失败则返回undefined\nfind方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。\n当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。\n注意点\n在第一次调用 callback函数时会确定元素的索引范围，因此在 find方法开始执行之后添加到数组的新元素将不会被 callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到，但是其值已经是undefined了。\nArray#findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。\n语法：\narr.findIndex(callback[, thisArg]) 返回：number\n与Array#find()原理相同，只是返回的是元素的索引。\nII 遍历 以下方法都不会修改原数组。\nArray#every() 测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n语法：\narr.every(callback[, thisArg]) 输出：bool\nevery 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 falsy 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。\n注意点\nevery 不会改变原数组。\n若传入一个空数组，无论如何都会返回 true。\nArray#some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。\n语法：\narr.every(callback(element[, index[, array]])[, thisArg]) 输出：bool\n与Array#every()类似。some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some() 将会立即返回 true。否则，some() 返回 false。\nArray#map() 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n语法：\narr.map(callback[, thisArg]) map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。\nArray#filter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\n语法：\narr.filter(callback[, thisArg]) 返回： Array\nfilter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。\nArray#forEach() 对数组的每个元素执行一次给定的函数。\n语法：\narr.forEach(callback[, thisArg]) 返回：无输出\nforEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。\nforEach() 被调用时，不会改变原数组，也就是调用它的数组（尽管 callback 函数在被调用时可能会改变原数组）。\nArray#flat() 会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n语法：\narr.flat([depth]) depth指提取嵌套数组的结构深度，默认值为 1。\n返回：Array\n例子：\nvar arr1 = [1, 2, [3, 4]]; arr1.flat(); // [1, 2, 3, 4] Array#flatMap() 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。\n语法：\narr.flatMap(callback[, thisArg]) 翻译：先使用map()，再使用flat(1)。\n返回： 一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。\n例子：\nvar arr1 = [1, 2, 3, 4]; arr1.map(x =\u0026gt; [x * 2]); // 这里的map对每个数操作之后会返回一个数组，意思就是每个元素都是数组 // [[2], [4], [6], [8]]  arr1.flatMap(x =\u0026gt; [x * 2]); // 先使用map()，再使用flat(1)，就会把返回的数组flat掉 // [2, 4, 6, 8]  // only one level is flattened arr1.flatMap(x =\u0026gt; [[x * 2]]); // [[2], [4], [6], [8]] 注意点：\n使用flatMap()比先使用map()，再使用flat(1)的效率更高一些。\nIII 遍历（累加） Array#reduce() 对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n语法：\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])   callback（其实就是祖传的callback+第一个参数为累加器而已）\n执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：\naccumulator ：累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。\ncurrentValue ：数组中正在处理的元素。\nindex 可选 ：数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。\narray可选 ：调用reduce()的数组。\n  initialValue可选\n作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。\n  翻译：初始值取为initialValue或者数组第一个值（initialValue未指定），然后每次进行callback的函数运算，回调函数的return值就是下一次的accumulator值（意味着第一个accumulator值就是initialValue或第一个数）。\n返回：函数累计处理的结果。\nreduce为数组中的每一个元素依次执行callback函数，返回最后的accumulator。\n注意点\n在空数组上调用 reduce 或 reduceRight 且未提供初始值（例如 [].reduce( (acc, cur, idx, arr) =\u0026gt; {} ) ）的话，会导致类型错误。\nArray#reduceRight() 法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。\n与Array#reduce()类似，只不过方向是从右到左。\nIV 修改 以下方法会修改原数组。\nArray#pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。\n语法：\narr.pop() 返回：最后一个元素的值\n注意点\npop 方法有意具有通用性。\n如果在一个空数组上调用 pop()，它返回 undefined。\nArray#push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\n语法：\narr.push(element1, ..., elementN) 返回：新的length，类型为number。\n注意点\npop 方法有意具有通用性。\nArray#shift() 从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\n语法：\narr.shift() 返回：第一个元素的值\n与Array#pop()类似。\nArray#unshift() 将一个或多个元素添加到数组的开头，并返回该数组的新长度。\n语法：\narr.unshift(element1, ..., elementN) 返回：新的length，类型为number。\n与Array#push()类似。\nArray#sort() 用原地算法对数组的元素进行排序，并返回数组。\n语法：\narr.sort([compareFunction(firstEl, secondEl)])   compareFunction 可选\n用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。\nfirstEl 第一个用于比较的元素。\nsecondEl 第二个用于比较的元素。\n  返回：排序后的数组。请注意，数组已原地排序，并且不进行复制。\n如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：\n  如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n  如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n  如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。\n  compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。\n  Array#fill() 语法：\narr.fill(value[, start[, end]])   value\n用来填充数组元素的值。\n  start 可选\n起始索引，默认值为0。\n  end 可选\n终止索引，默认值为 this.length。\n  返回：Array\n例子：\nvar arr = [1,2,3] arr.fill(4) // [4,4,4] console.log(arr) // [4,4,4] arr.fill(2,0,1) // [2,4,4] console.log(arr) // [2,4,4]  var arr = Array(3).fill({}) // [{}, {}, {}]; // 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型 arr[0].hi = \u0026#34;hi\u0026#34;; // [{ hi: \u0026#34;hi\u0026#34; }, { hi: \u0026#34;hi\u0026#34; }, { hi: \u0026#34;hi\u0026#34; }] 注意点\n会修改原数组。\nfill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象。\n如果使用arr.fill({})，传入的是引用类型。\nArray#copyWithin() 浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。\n语法：\narr.copyWithin(target[, start[, end]])   target\n0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。\n如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。\n  start\n0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。\n如果 start 被忽略，copyWithin 将会从0开始复制。\n  end\n0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。\n如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）。\n  返回：Array，改变后的数组。\n若超过长度而复制未完成，就会截止（不改变原数组长度）。\ncopyWithin 函数被设计为通用式的，其不要求其 this 值必须是一个Array对象。\nArray#splice() 通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。\n语法：\narray.splice(start[, deleteCount[, item1[, item2[, ...]]]])   start\n指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。\n  deleteCount 可选\n整数，表示要移除的数组元素的个数。\n如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。\n如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。\n如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。\n  item1, item2, ... 可选\n要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。\n  翻译：从start位置往后数deleteCount个元素都会被删除，并填入item1, item2, ...元素。\n返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。\nV 打印/输出 以下方法都不会修改原数组。\nArray#join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。\n语法：\narr.join([separator]) separator：若不选此参数，则分隔符为,，常用的如空字符串\u0026quot;\u0026quot;，则所有元素之间都没有任何字符。\n返回：String\n注意点\n如果一个元素为 undefined 或 null，它会被转换为空字符串。\nArray#slice() 返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\n语法：\narr.slice([begin[, end]]) 返回：Array, 原数组一部分的浅拷贝\n对于引用元素是浅拷贝，对于原生类型是复制。\nArray#reverse() 将数组中元素的位置颠倒，并返回该数组。\n语法：\narr.reverse() 返回：Array, 颠倒的数组\n注意点\nreverse方法是特意类化的；此方法可被应用于类似数组对象。对象如果不包含反映一系列连续的、基于零的数值属性中的最后一个长度的属性，则该对象可能不会以任何有意义的方式运行。\nArray#concat() 用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n语法：\nold_array.concat(value1[, value2[, ...[, valueN]]]) valueN：数组和/或值。\n如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝。\n返回：Array, 合并的新数组\nArray#toString() Array#toLocaleString() 返回一个字符串，表示指定的数组及其元素。\n数组中的对象将使用各自的Object#toString()和Object#toLocaleString()\nVI 迭代器 可以用于es6中新的迭代器语法。如for of、.next()方法等。\nArray#entries() 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。\n例子：\nconst array1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const iterator1 = array1.entries(); console.log(iterator1.next().value); // expected output: Array [0, \u0026#34;a\u0026#34;]  console.log(iterator1.next().value); // expected output: Array [1, \u0026#34;b\u0026#34;] Array#keys() 返回一个包含数组中每个索引键的Array Iterator对象。\nArray#values() 返回一个包含数组中每个值的Array Iterator对象。\nArray#[@@iterator]() 数组的 iterator 方法，默认情况下，与 values()返回值相同\n语法：\narr[Symbol.iterator]() VII 实验性功能 Array#at() 支持正数和负数的索引取值。 语法：\nat(index) 返回：相对应的值。 例子：\nvar arr = [1,2,3,4] arr[-1] // undefined, js不支持负数索引 arr[arr.length - 1] // 4 arr.slice(-2, -1) // 4 arr.at(-1) // 4 ","date":"2021-11-10T22:10:09+08:00","permalink":"https://mizarzh.github.io/p/2021/11/array%E6%96%B9%E6%B3%95/","title":"Array方法"},{"content":"本文章是 You Dont Konw JS 类型部分的一个笔记。\n原生函数 常用的原生函数有：\n  String()\n  Number()\n  Boolean()\n  Array()\n  Object()\n  Function()\n  RegExp()\n  Date()\n  Error()\n  Symbol()——ES6 中新加入的\n  实际上，它们就是内建函数。\n原生函数可以被当作构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：\nvar a = new String( \u0026#34;abc\u0026#34; ); typeof a; // 是\u0026#34;object\u0026#34;，不是\u0026#34;String\u0026#34; a instanceof String; // true Object.prototype.toString.call( a ); // \u0026#34;[object String]\u0026#34; typeof 在这里返回的是对象类型的子类型。\n补充：instanceof（用class太多，该回去复习原型链了……）\nobject instanceof constructor // object 某个实例对象, constructor 某个构造函数 内部属性[[Class]] 所有 typeof 返回值为 \u0026ldquo;object\u0026rdquo; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类）。\n可以使用Object.prototype.toString(..)来查看：\nObject.prototype.toString.call( [1,2,3] ); // \u0026#34;[object Array]\u0026#34; Object.prototype.toString.call( null ); // \u0026#34;[object Null]\u0026#34; Object.prototype.toString.call( \u0026#34;abc\u0026#34; ); // \u0026#34;[object String]\u0026#34; 虽然null和undefined的原生构造函数并不存在，但仍然具有内部类型。\nString等类型是包装类型。\n封装对象包装 基本类型是不存在.length 和 .toString() 这样的属性和方法，因此需要通过封装对象才能访问。\n如果想要自行封装基本类型值，可以使用 Object(..) 函数（不带 new 关键字）\n拆封 如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数。\n原生函数作为构造函数 数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常 量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的。应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。\nArray Array(1,2,3) 和 new Array(1,2,3) 是一样的\nObject(..)、Function(..) 和 RegExp(..) 除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)。\nObject可以使用常量值的方法解决。\n构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候。\n强烈建议使用常量形式（如 /^a*b+/g）来定义正则表达式。\nDate(..) 和 Error(..) Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量 形式来作为它们的替代。\n创建日期对象必须使用 new Date()。Date(..) 可以带参数，用来指定日期和时间，而不带 参数的话则使用当前的日期和时间。\n构造函数 Error(..)带不带 new 关键字都可。错误对象通常与 throw 一起使用。\nSymbol(..) Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。但它不支持语法：\u0026ldquo;new Symbol()\u0026quot;。\n原生原型 Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式（无 任何匹配），而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。这种方法的一个好处是 .prototypes 已被创建并且仅创建一次。需要注意的一点是，如果默认值随后会被更改，那就不要使用 Array.prototype。\n","date":"2021-11-10T19:49:42+08:00","permalink":"https://mizarzh.github.io/p/2021/11/js%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/","title":"Js原生方法"},{"content":"本文章是 You Dont Konw JS 类型部分的一个笔记。\n1 js类型 js有七种内置类型：\n  空值（null）\n  未定义（undefined）\n  布尔值（boolean）\n  数字（number）\n  字符串（string）\n  对象（object）：包含array, function等子类型\n  符号（symbol，ES6 中新增）\n  类型可以使用typeof进行判断，但是有一些类型或特殊情况的判断是不同的：\n   类型 typeof判断类型     null \u0026lsquo;object\u0026rsquo;, 应该是\u0026rsquo;null'   function \u0026lsquo;function\u0026rsquo;, 应该是\u0026rsquo;object'   未定义变量（undeclared） \u0026lsquo;undefined\u0026rsquo;   其他（包括array） 相对应的类型（array对应的是\u0026rsquo;object'）    undefined和undeclared不同：已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。使用 undeclared 的变量会报错（ReferenceError）。\n2 数组、字符串、数字 仔细探讨这三个最常用的类型\n数组 1、内部可以容纳任何值。\n2、\nvar a = []; a[0] = 1; a[2] = 1; a[1] // undefined 但是a[1]的undefined和普通的undefined不同。\n3、因为array是对象，因此可以进行对象的操作：\nvar a = []; a[\u0026#39;foobar\u0026#39;] = \u0026#39;xxx\u0026#39;; // 合法 a[\u0026#39;13\u0026#39;] = \u0026#39;xxx\u0026#39; // 会被转换成13 但是并不算入length属性中。\n4、类数组\n类数组（一组通过数字索引的值）转换成真正的数组的方法：\nindexOf(..)、concat(..)、forEach(..)等方法\nArray.prototype.slice.call( arguments )方法\nArray.from(..)方法\n字符串 有很多地方和数组很像\n1、字符串不可变。\n2、可以借用一些数组的函数：\nvar a = \u0026#39;xwefqwef\u0026#39; Array.prototype.join.call( a, \u0026#34;,\u0026#34; ); Array.prototype.map.call Array.prototype.reverse.call无法调用，因为字符串不可变。\n一个经典的方法：\na.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); 对Unicode会无效。\n数字 js 没有真正意义上的整数。\nNumber转换的一些方法（Number.prototype）：\n   方法 作用     toExponential() 指数输出   tofixed(..) 指定小数数位   toPrecision(..) 指定有效数位   toLocaleString(..)    toString(..)    valueOf(..)     42.toFixed(3) // 无效，因为42.被认为是是浮点数 (42).toFixed( 3 ); // \u0026#34;42.000\u0026#34; 0.42.toFixed( 3 ); // \u0026#34;0.420\u0026#34; 42..toFixed( 3 ); // \u0026#34;42.000\u0026#34; 各种进制开头：0b 0o 0x\nIEEE 754浮点数的问题：\n0.1 + 0.2 === 0.3 // false 方法是使用机器精度判断（Number.EPSILON，值为2^-52 (2.220446049250313e-16)）：\nfunction numbersCloseEnoughToEqual(n1,n2) { return Math.abs( n1 - n2 ) \u0026lt; Number.EPSILON; } Number中各种特殊值：\n   特殊值 值 解释     Number.EPSILON 2^-52 ，2.220446049250313e-16 机器精度   Number.MAX_VALUE 1.798e+308 最大值   Number.MIN_VALUE e-324 最小值   Number.MAX_SAFE_INTEGER 2^53 - 1，9007199254740991 最大安全整数   Number. MIN_SAFE_INTEGER -9007199254740991 最小安全整数   Number.NaN NaN 非数字   Number.NEGATIVE_INFINITY -Inf 负无穷大值   Number.POSITIVE_INFINITY Inf 正无穷大值    方法：\n   方法 解释     Number.isInteger(..) 检测整数   Number.isSafeInteger(..) 是否是安全的整数   Number.isNaN(..) 检测是否是NaN   Number.isInfinite(..) 是否为有限数   Number.parseFloat(..) 转换为浮点数   Number.parseInt(..) 转换为整数    特殊值 1、void 运算符：没有返回值，即返回结果为undefined。\n2、检测NaN的另一方法：NaN 是 JavaScript 中唯 一一个不等于自身的值。\nif (!Number.isNaN) { Number.isNaN = function(n) { return n !== n; }; }; 3、Object.is(..)判断两个值是否绝对相等。\n3 值与引用 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。标量基本类型值是不可更改的（字符串和布尔也是如此）。\n而复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值 / 传递。\n即简单值表现为值，复合值表现为引用。\n4 更多的内置对象 见JavaScript 标准内置对象。\n","date":"2021-11-09T20:16:46+08:00","permalink":"https://mizarzh.github.io/p/2021/11/js%E7%B1%BB%E5%9E%8B/","title":"Js类型"},{"content":"background是css属性中经常会遇到的属性，接下来将详解这个属性的各个参数的含义。\nintro background 是一个复合属性，由：\n\u0026lt;attachment\u0026gt; \u0026lt;box\u0026gt; \u0026lt;background-color\u0026gt; \u0026lt;bg-image\u0026gt; \u0026lt;position\u0026gt; \u0026lt;repeat-style\u0026gt; \u0026lt;bg-size\u0026gt; 组成。\n后面是这些值的详解：\nbg-image 决定它的属性是background-image，作用是为一个元素设置一个或者多个背景图像。\n指定的背景可以是none，url()函数指定的图片，gradient()函数指定的梯度颜色。\nbackground-color 顾名思义，就是背景颜色\n可以使用#, rgb(), rgba()等指定颜色，也可以使用transparent（透明）。\nattachment 决定它的属性是background-attachment\n主要区分点是假设有一个元素，这个元素内部有一个滚动条，而外部（如整个窗口）也有一个滚动条。\n\rimage-20211105194635375\r\nfixed：外部和内部滑动都不动\n此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\nlocal：外部和内部滑动都随之而动\n此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\nscroll：内部滑动不动，而外部滑动随之动\n此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。\n可以使用逗号分隔，指定多个不同背景的attachment。\np { background-image: url(\u0026#34;picture1.png\u0026#34;), url(\u0026#34;picture2.png\u0026#34;); background-attachment: fixed, scroll; } position 决定它的属性是background-position。\n语法：\n 关键字 center，用来居中背景图片。关键字 top, left, bottom, right 中的一个，用来指定放在某个方向边缘的中间位置。 两个长度或百分比，指定相对于top和left的距离。 关键字top, left, bottom, right + 长度或百分比 x2。  例子：\nbackground-position: top; background-position: center; background-position: 25% 75%; background-position: 100px 200px; background-position: bottom 10px right 20px; background-position: right 3em bottom 10px; background-position: top right 10px; /* 距离top 0，距离right 10px */ 可以使用负值，即背景在框外。\n可以用逗号隔开，指定多个不同背景的position。\nrepeat-style 定义背景图像的重复方式。\n/* 单值语法 */ background-repeat: repeat-x; /* 相当于 repeat no-repeat，以下同理 */ background-repeat: repeat-y; background-repeat: repeat; background-repeat: space; background-repeat: round; background-repeat: no-repeat; /* 双值语法: 水平horizontal | 垂直vertical */ background-repeat: repeat space; background-repeat: repeat repeat; background-repeat: round space; background-repeat: no-repeat round; repeat：重复，边缘图像会裁剪。\nspace：图像会尽可能得重复，中间会有空隙，最边缘的图像会贴在边缘上, 不会裁剪。background-position会被无视除非只有一张图像。\nround：图像会被拉伸，直到有足够的空间来添加一个图像。当下一个图像被添加后, 所有的当前的图像会被压缩来腾出空间。什么时候添加下一个图像由浏览器决定。\nno-repeat：无重复。\n可以用逗号隔开，指定多个不同背景的background-repeat\nbackground-size 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。\n/* 关键字 */ background-size: cover background-size: contain /* 一个值: 这个值指定图片的宽度，图片的高度隐式的为auto */ background-size: 50% background-size: 3em background-size: 12px background-size: auto /* 两个值 */ /* 第一个值指定图片的宽度，第二个值指定图片的高度 */ background-size: 50% auto background-size: 3em 25% background-size: auto 6px background-size: auto auto 没有被背景图片覆盖的背景区域仍然会显示用background-color属性设置的背景颜色。\n关键字：\ncontain：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见，会尽可能保持图像的比例。\ncover：缩放背景图片以完全装入背景区，可能背景区部分空白，会尽可能保持图像的比例。\nbox 由两个属性决定： background-clip 和 background-origin\nbackground-clip：决定背景图片覆盖盒模型中的哪些部分。\nbackground-clip: border-box; background-clip: padding-box; background-clip: content-box; background-clip: text; background-origin：规定了指定背景图片background-image 属性的原点位置的背景相对区域。\nbackground-origin: border-box; background-origin: padding-box; background-origin: content-box; 当使用 background-attachment为fixed时，该属性将被忽略不起作用。\n综合 \u0026lt;box\u0026gt; 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 background-origin和 background-clip。如果出现 2 次，第一次的出现设置 background-origin，第二次的出现设置 background-clip。\n其他的能出现0次或1次。\n\u0026lt;bg-size\u0026gt; 只能紧接着 \u0026lt;position\u0026gt; 出现，以\u0026quot;/\u0026ldquo;分割，如： \u0026ldquo;center/80%\u0026rdquo;.\n\u0026lt;background-color\u0026gt; 只能被包含在最后一层。\n例子：\nbackground: center / contain no-repeat url(\u0026#34;logo.svg\u0026#34;), #eee 35% url(\u0026#34;logo2.svg\u0026#34;); background: left 5% / 15% 60% repeat-x url(\u0026#34;star.png\u0026#34;); ","date":"2021-11-05T19:37:44+08:00","permalink":"https://mizarzh.github.io/p/2021/11/css%E4%B8%ADbackground%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7/","title":"css中background相关属性"},{"content":"mathjax/katex test: $$ abc+edf $$\npicture test:\n\r\n本来是想要留个纪念（转hugo了），但是一上来就出现了大问题：hugo的运作机制和hexo大为不同，是没有mathjax的插件的，需要自己手动添加代码。\n目测有两种方法：一是在theme中插入mathjax代码从而渲染，二是安装hugo默认markdown渲染引擎goldmark的mathjax插件，或者使用pandoc之类的支持mathjax的渲染引擎。\n因为第一种方法较简单就直接使用第一种。解决方法：在themes/some-theme/layouts/partials/footer/footer.html的\u0026lt;footer\u0026gt;中添加语句：\n{{ if .Params.mathjax}} \u0026lt;!-- 判断文件中是否设置mathjax: true --\u0026gt; \u0026lt;!-- 引入mathjax3 --\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 文件头开启mathjax：\ntitle: \u0026#34;balabala\u0026#34; ... mathjax: true ... ​\n不得不说，hugo和hexo的运转机制十分不同，hugo的速度快，自由度也高许多，期望以后会有更好的使用体验。\n","date":"2021-10-27T16:21:58+08:00","image":"https://mizarzh.github.io/p/2021/10/my-first-post-mathjax-problem/%E5%B0%81%E9%9D%A2%E6%B5%8B%E8%AF%95_hue219db1679193659d52ea91d8c32cf29_372450_120x120_fill_q75_box_smart1.jpg","permalink":"https://mizarzh.github.io/p/2021/10/my-first-post-mathjax-problem/","title":"My First Post \u0026 Mathjax Problem"},{"content":"1 TeX TeX是Donald E. Knuth开发的一个排版系统。用户可以使用一系列的低级控制指令指导系统排版，同时支持变量、作用域、控制流和函数定义。\nTeX可执行文件/引擎是一个将源文件渲染成排版后可供阅读的文件的二进制程序。较早期的输出文件为DVI，目前较流行的文件为PDF。以下方括号内代表对应的可执行文件。\n2 TeX宏包/TeX格式 由于TeX的使用十分繁杂，因此就发展出了更高级别的宏包方便人们使用。\nPlain TeX [tex]: 最原始的TeX宏包。包含了一些基本的宏命令。\nLaTeX [latex]: 目前版本为LaTeX2e，早先版本为LaTeX2.09。目前最常用的格式。\nConTeXt [context]\nTexinfo [tex, makeinfo]: 将Texinfo文件转换成HTML、DocBook、Emacs info、XML和文本。配合其他的工具可以转换为DVI或PDF。\nEplain [eplain]: Plain TeX的拓展。\n3 改良的TeX可执行文件/引擎 由于TeX是一个1970年代的程序，因此并不能适应现在的一些渲染需求。\npdfTeX [pdftex]: 一个可直接渲染pdf文件的引擎。\nXeTeX [xetex]: 与pdfTeX差不多，但支持UTF-8。\nLuaTeX [luatex]: 使用lua作为脚本语言，可以进行更加方便的编程。\ne-TeX [etex]: 是TeX的一个拓展。\n引擎与渲染格式的配合：\n使用pdftex --fmt=latex\n为方便使用，就定义了pdflatex这个命令。\n\r\n使用不同的方法渲染至pdf的步骤：\n\rimage-20211006214418135\r\n4 TeX发行版 TeX发行版能够提供一套成体系的TeX工具。通常人们说安装TeX是指安装发行版。\nTeX Live: 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是“官方”的 TeX 系统。\nMiKTeX: 较为轻量级的一个发行版，初始安装仅包含最基本的宏命令，后续按需安装。\nMacTeX: TeX Live在mac上的替代品。\n5 编辑器 vscode、vim、tex studio之类\n用于编辑tex文件，渲染工作由引擎进行。\n6 CTAN CTAN是“Comprehensive TeX Archive Network”的首字缩写，为世界上最主要的TeX资源集散网站，搜集了关于TeX的各种文件与软件等等。\n7 参考 [1] https://texfaq.org/FAQ-texthings\n[2] https://www.tug.org/levels.html 。通过这里也可以访问tug官网。\n[3] LaTeX入门 by 刘海洋\n[4]https://liam.page/2018/11/26/introduction-to-TeX-engine-format-and-distribution/ 。更加详细的介绍。\n","date":"2021-10-06T20:44:39+08:00","permalink":"https://mizarzh.github.io/p/2021/10/%E5%90%84%E7%B1%BBtex/","title":"各类“TeX”"},{"content":"0 整体参数 参数：速度、尺寸、容量/成本、耐用性/寿命\n1 机械硬盘（Hard Disk Drive, HDD） 大牌：西数，东芝，希捷\n1.1 物理结构 使用磁介质储存数据\n\r\n硬盘的物理结构一般由磁头与盘片、电动机、主控芯片与排线等部件组成；当主电动机带动盘片旋转时，副电动机带动一组（磁头）到相对应的盘片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与盘片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；\n 磁道  当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。资料存储手段从LMR进展到PMR这中又有CMR、SMR等技术。\n 柱面  在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。\n 扇区  磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector）。硬盘的第一个扇区，叫做引导扇区。\n\r\n磁道（Track），柱面（Cylinder），扇区（Sector），磁头（Heads），盘片（Platters）\n每个盘片都有两面，因此也会相对应每盘片有2个磁头。\n\r\nA：磁道 B：扇面 C：扇区 D：簇（扇区组）\n1.2 参数 **尺寸 **2.5寸（笔记本、移动机械硬盘）和3.5寸（主机）。\n转速 7200rpm或5400rpm，显然转速越快读取速度越快。\n传输速度\n5400rpm硬盘平均读写速度大致在60-90MB/s这个区间。\n7200rpm硬盘大致在130-250MB/s区间。\n垂直式（CMR）与叠瓦式（SMR）：推荐CMR。SMR建议用作只读盘而不修改。\n将一个磁道拿出来并近似为平面。\n古早的机械硬盘的磁性颗粒是水平排列的（因为写探头的大小问题）。\n\r\n后来，写探头变小了，因此可以将磁性颗粒竖着排放，这种排列方式被称为PMR：\n\r\n为了提高存储的密度，厂家开发出了更加丧心病狂的SMR（也属于PMR），即将磁性颗粒部分相重叠：\n\r\n原来的传统PMR技术就被称为C(conventional)MR。CMR磁道间有间隔，而SMR叠在了一起，因此没有间隔。\n\r\n\r\n读取探头比写入探头要小。CMR的读写很好理解，写入和读取不同的磁道完全是相互独立的。而对于SMR来说，后写入的数据会覆盖较前写入的数据的磁道的下半部分，但是由于读取探头较小，因此可以正常读取数据（读取之前写入数据的磁道的上半部分）。但是如果要修改之前写入过的数据，就需要缓存后写入的数据，写入新数据，再一层一层写入后面的数据。这就是为什么SMR的缓存较大且最好写入后就不要再修改的原因。\n\r\n空气/氦气\n目前空气硬盘最多可以容纳 6 片盘片（西部数据 HC330，1.67TB x 6 = 10TB），氦气硬盘依靠氦气的低密度降低磁盘间距和盘片厚度，盘体内最多可以容纳 9 片盘片（2.0TB x 9 = 18TB），同时常常兼具功耗低、噪音小等附带属性，但是因为氦气需要被完全密封在盘体内，硬盘的死法又多了一个氦气漏气的类型。\n接口 SATA, USB(移动硬盘)\n1.3 扇区管理 MBR GBT\n主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是电脑引导后访问硬盘时所必须要读取的首个扇区，主引导扇区记录着硬盘本身的相关消息以及硬盘各个分割的大小及位置消息，是资料消息的重要入口。如果它受到破坏，硬盘上的基本数据结构消息将会丢失，需要用繁琐的方式试探性的重建数据结构消息后才可能重新访问原先的资料，对于那些扇区为512位组的磁盘，MBR分割表不支持容量大于2.2TB（2.2×1012字节）的扇区。\n全局唯一标识分区表（GUID Partition Table，GPT）是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准的一部分。GPT分配64bits给逻辑块地址，因而使得最大分区大小为$2^{64}-1$个扇区。对于每个扇区大小为512字节的磁盘，相当于9.4ZB（9,444,732,965,739,290,426,880字节或 18,446,744,073,709,551,615（$2^{64}-1$）个扇区x 512（$2^9$）字节每扇区）。\n\r\n1.4 历史 来源链接：https://zhuanlan.zhihu.com/p/74275200\n1973年Winchester技术硬盘，确定了硬盘的基本架构，利用几个同轴涂上磁性材料的金属圆盘和可移动磁头密封在一个盒子里，通过圆盘旋转读出信号的改变。 1979年IBM研发了薄膜磁头技术，进一步减小硬盘体积。 1981年IBM研发了MR（Magnerto Resistive磁阻）技术，将存储密度从200Mbpsi提高了数十倍，为大容量硬盘的诞生奠定了基础。 1991年，经过了10年推出了MR技术3.5英寸的1GB硬盘。3.5寸也成为了现在计算机硬盘的标准规格。 1997年，GMR巨磁阻效应磁头诞生，存储密度比MR技术高了8倍多，但是好景不长也基本达到了瓶颈。 2005年，**垂直写入技术（Perpendicular Recording，PMR）**的大量使用使得在2007年日立推出了第一款突破TB级容量的硬盘。进入1TB时代。（单盘1TB） 2010年后SSD走上舞台。 2012年才有了第一款4TB的硬盘。 受限于机械硬盘的瓶颈，2012-2017年机械硬盘技术发展基本处于停滞状态，价格对于今天而言略降。 2017年推出了叠瓦式磁记录(Shingled Magneting Recording，SMR)技术，允许磁轨互相重叠，像屋顶的瓦片。这种方式使得单盘容量能够达到2TB。但是SMR硬盘的缺点是比较致命的，对于一些存有数据的磁轨，如果写入，针对的是磁轨的全部宽度，而磁轨的重叠会导致临近的磁轨被重写。\n1.5 杂项 护理\n不要拆开！不要拆开！不要拆开！机械硬盘拆开直接报废。\nSMR硬盘最好不要频繁修改数据。\n2 固态硬盘（Solid-state Drive,SSD） 牌子有很多\n来源：https://www.zhihu.com/question/355642710/answer/897977012\n第一梯队（自产自销）：\n三星，西数/闪迪，东芝，英特尔/镁光。\n其中三星最贵也最好，西数性价比略高，东芝性能一般，英特尔便宜的真便宜，贵的真™贵。\n第二梯队（原厂颗粒）：\n浦科特，金士顿。\n浦科特近年来都没出几个好的固态，性价比不算高。金士顿用的是买原厂颗粒自己封装的，颗粒稳定性不如第一梯队。\n第三梯队（白片）：\n各种品牌定制，联想，宏碁，影驰，七彩虹等等。这些一般都是拿原厂检测不合格但能用的白片，可靠性一般，性能还行。\n第四梯队（黑片）：\n光威悍将，以及各种便宜到不可思议的固态，多是国产品牌。黑片的可靠性不用多说了吧，说不准哪天突然就boom了。\n以下部分数据来源：https://www.zhihu.com/question/19926569/answer/547791508\nhttps://zh.wikipedia.org/wiki/固态硬盘\n1.1 物理结构 \r\n用非易失性存储器（主要以闪存中的 NAND Flash）作为永久性存储设备。\n固态硬盘由主控、缓存、闪存（NAND Flash）组成。\n主控 主控是SSD非常重要的一部分，相当于电脑的CPU，是决定固态性能优劣的核心。由于技术门槛较高，所以主控品牌比较少，目前头部品牌有马牌（Marvell）、三星、英特尔（Intel），另外还有瑞昱、东芝（铠侠）、慧荣、群联等表现不错。\n闪存 NAND Flash分为四种：SLC, MLC, TLC, QLC。分别代表一个Cell能存储1bit、2bit、3bit和4bit的数据。能储存的数据量从QLC至SLC依次递增。\n\r\n读取速度SLC依次递减至QLC，价格同理。\n目前主流是TLC，QLC也在逐渐占领市场，SLC和MLC基本只能在高端产品中见到。\n1.2 接口/外形 根据物理外形可以分为2.5英寸、M.2和AIC（独立显卡那样的插卡式）三类。\n根据电气标准可以分为SATA和PCIe两类。\n根据数据协议可以分为AHCI和NVMe两类。\nSSD的类型：\n\r\nPCIe接口和SATA接口的区别：\n\r\nm.2的长度：\n\r\nPCIe4.0与PCIe3.0 PCIe 4.0的传输速率定义为16GT/s，比3.0翻番。但PCIe 4.0技术较新，价格昂贵，因此不一定适合需求。\n1.3 参数 成本 比机械硬盘昂贵。\n速度 sata协议的硬盘接口：m.2接口，sata3接口，PCI-E x2接口。速度在500-700MB/SNVME协议的硬盘接口：m.2接口，PCIE-E x4接口。3000MB/S以上。\n与机械硬盘相比，固态硬盘拥有更快的读写速度（无论是顺序读写还是随机读写）、更高的IOPS（每秒响应次数）以及更低的响应延迟（类比机械硬盘的寻道时间）。\n寿命 由于浮栅MOSFET中本征电场的存在，随着时间流逝产生的电荷泄漏，会逐渐导致NAND闪存中的数据出错甚至无法读取。由于陷阱辅助隧穿（Trap-assisted tunneling (TAT)）效应，随着擦写次数（编程/擦除周期数，Program/Erase Cycle (P/E Cycle)）的增加，氧化物绝缘层逐渐磨损，NAND闪存的可靠性会逐渐降低（数据保持时间缩短）。升高温度也会使数据保持时间缩短。\n一些特性 由于没有像机械硬盘那样的运动部件，固态硬盘对振动/震动没那么敏感，较为耐摔，运行时发出的噪音几乎不可闻。但是，固态硬盘在发生故障或因误操作删除、覆盖数据时基本无法恢复。\nU盘 结构类似固态硬盘。\n同样使用NAND Flash作为储存，同样有主控进行写入。最大差别是便携性、容量和接口。\n各种接口在下篇文章有详解。\nSD/TF卡 同样使用NAND作为储存\n链接：https://zhuanlan.zhihu.com/p/66018996\n外观区分：\nSD卡体积为24mm×32mm×2.1mm；\nTF卡体积为15mm×11mm×1mm！\n名称区分：\nSD卡即Secure Digital Memory Card，中文翻译为安全数码卡。\nTF卡即T-Flash又称MicroSD，是一种记忆卡。后改称为TransFlash；而重新命名为MicroSD的原因是因为被SD协会（SDA）采立。另一些被SDA采立的记忆卡包括miniSD和SD卡。\n用途区分：\nSD卡被广泛地于便携式装置上使用，例如数码相机、个人数码助理(PDA)和多媒体播放器等。\nTF卡主要于手机使用，但因它拥有体积极小的优点，随着不断提升的容量，它慢慢开始于GPS设备、便携式音乐播放器和一些快闪存储器盘中使用。\nSD卡级别：\n\r\n","date":"2021-09-27T19:44:52+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E7%A1%AC%E7%9B%98/%E5%82%A8%E5%AD%98%E4%BB%8B%E8%B4%A8%E7%AC%94%E8%AE%B0/","title":"硬盘/储存介质笔记"},{"content":"天文光度学 几个重要参数和概念 衡量光的强度使用的是能量$E$，衡量光单位时间内的强度用的是功率$P$。由于光不断在运动，恒星不断在产能，因此使用后者是较为合理的。\n定义以下参数：\n流量(flux): 单位$\\text W$，指单位时间内某个面积流过的总能量。\n流量密度(flux density) $F$: 单位$\\text{W/m}^2$，即单位面积单位时间上流过的总能量。\n光度(luminosity) $L$：即天文学上对恒星使用的流量，某些情境中可交替使用。\n有时候单位中会有$\\text{Hz}^{-1}$，这种情况指的是在某个不同频率的波段上的相应参数。\n导出参数及关系 如果源是各向同性发射的，那么有一条关系式： $$ L=4\\pi r^2 F $$ 即众所周知的平方反比定律：\n\r\n星等 历史 公元前二世纪，Hipparchos定义了一套星等系统：将天上所有可见的星分为六等，最明亮的为一等星，勉强可见的最暗星为六等星。\n这个定义十分的不准确，因此到了1856年，Norman R. Pogson定义了一套全新的系统，这就是现在的星等系统。\n原理及推导 人眼对光的响应是对数的。假如有三颗星，它们的流量密度之比为1:10:100，人眼就会感觉一二颗星及二三颗星之间的差别是相等的。即每降一个星等，星的流量密度就要乘一个倍数，这是一个对数运算。\n利用这个特性，我们可以定义一等星与六等星的流量密度之比为100。那么对于人眼来说，n比n+1等要亮$\\sqrt[5]{100}=2.512$等。那么： $$ \\frac{F_n}{F_{n+1}}=\\sqrt[5]{100}\\Rightarrow\\lg\\frac{F_n}{F_{n+1}}=2/5\\Rightarrow-2.5\\lg\\frac{F_n}{F_{n+1}}=-1=n-(n+1) $$\n即假设星等和对应流量密度$m_1,F_1,m_2,F_2$，则有普森（Pogson）公式： $$ m_1-m_2=-2.5\\lg\\frac{F_1}{F_2} $$\n有时候为便运算，可定义零等星对应的流量密度为$F_0$，则任意星等$m$及对应流量密度$F$的定义式为： $$ m=-2.5\\lg \\frac{F}{F_0} $$\n星等系统 星等可以代表不同波段上的光的强度。如我们可以定义眼睛看到的星等为$m_V$，摄像机拍到的星等为$m_{\\text{pg}}$等。\n如果可以测量所有波长的光，那么我们得到的星等就是热星等$m_{\\text{bol}}$，这是一个十分有用的参数，但难以测量，因此天文学家定义了一个参数热改正$\\text{BC}$(bolometric correction)来快速计算热星等： $$ m_{\\text{bol}}=m_{V}-\\text{BC} $$ 当然也有可能是正号，看具体情况。\n$m_V$，$m_{\\text{pg}}$定义的星等并不准确，因此在1950年早期Harold L. Johnson 和 William W. Morgan定义了一套星等系统叫做UBV系统，即加入不同波段的透镜让望远镜接收不同波段的光从而判断颜色。后续发展出了UBVRI和ubvy系统：\n\r\n\r\n我们常用色指数(color index)这个参数来判断星的颜色，常用的如$U-B,B-V$，对于A0型星，这两个指数都为0。\n绝对星等 之前的星等都是一个相对的概念，为了绝对地衡量一颗星的亮度，需要使用绝对星等。\n绝对星等$M$的定义即为一颗星放在10pc处的星等。根据定义： $$ m-M=-2.5\\lg\\frac{F(r)}{F(10\\mathrm{pc})}=-2.5\\lg\\frac{\\frac{L}{4\\pi r^2}}{\\frac{L}{4\\pi (10\\mathrm{pc})^2}}\\\n=5\\lg\\frac{r}{10\\mathrm{pc}}\\\n=5\\lg r-5\\ (r单位为\\mathrm{pc}) $$ 可以定义绝对星等之间的比较。如，假设有一颗星对应的参数为$M_{\\text{bol}},F,L$，太阳对应的参数为$M_{\\text{bol}\\odot},F_\\odot,L_\\odot$，则： $$ M_{\\text{bol}}-M_{\\text{bol}\\odot}=-2.5\\lg\\frac{F}{F_\\odot}=-2.5\\lg\\frac{L/4\\pi r^2}{L_\\odot/4\\pi r^2}=-2.5\\lg\\frac{L}{L_\\odot} $$\n消光(extinction)和光深(optical thickness) 解说待补充 $$ dL=−\\alpha Ldr $$ $\\alpha$ opacity\noptical thickness: $$ d\\tau = \\alpha dr $$ thus: $$ dL=-Ld\\tau\\Rightarrow L=L_0e^{-\\tau} $$ 对星等系统的影响： $$ m-M=5\\lg\\frac{r}{10\\mathrm{pc}}+(2.5 \\lg e)\\tau=5\\lg\\frac{r}{10\\mathrm{pc}}+A $$ 若均匀，则： $$ \\tau=\\alpha\\int^r_0dr=\\alpha r\\\nm-M=5\\lg\\frac{r}{10\\mathrm{pc}}+ar, a=2.5\\alpha $$\n色余(color excess) 色指数： $$ B-V=M_B-M_V+A_B-A_V=(B-V)0+E{B-V} $$\n$(B-V)0$被称为intrinsic color，$E{B-V}=(B-V)-(B-V)_0$被称为色余(color excess)。星际介质导致：\n$$ R=\\frac{A_V}{E_{B-V}}\\approx 3.0 $$ 几乎一致。这个现象被称为星际红化。\n大气消光 \r $$ X=\\sec z \\\nm=m_0+kX $$ $X$被称为空气质量(air mass)，$k$被称为消光系数。\n","date":"2021-09-11T15:34:01+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E5%A4%A9%E6%96%87%E5%85%89%E5%BA%A6%E5%AD%A6/","title":"天文光度学"},{"content":"天文望远镜基本知识 天文望远镜类型  折射望远镜 反射望远镜 折反式望远镜  折射与反射望远镜示意图：\n\rreflect-and-refract\r\n折射望远镜 最老的是伽利略式望远镜，使用的是一凸一凹的镜片。\n\r伽利略\r\n后来改进成两个凸透镜，但出现了另一个问题：色差(chromatic aberration)，即不同颜色聚焦在不同的焦点上，导致成像有色彩分离和偏差现象。\n\r色差\r\n解决方法是加入一个或多个凸透镜从而消除色差的影响。可以分为普通消色差和复消色差望远镜。\n由于复消色差望远镜如此优秀，其仍是拍摄的最佳选择，就是贵。\n反射望远镜 分牛反和其他反，牛反在开头的示意图，卡塞格林反射镜如下：\n\r卡塞格林\r\n反射望远镜的问题有彗差(coma)和球差(spherical aberration)。\n彗差是由于是轴外物点发出宽光束通过光学系统后，并不会聚一点，相对于主光线而是呈彗星状图形的一种失对称的像差。\n球差是由于电磁透镜中心区域和边缘区域对电磁波会聚能力不同而造成的。\n\r彗差\r\n\r球差\r\n折反射望远镜 为了解决反射望远镜的种种问题，就需要在前面增加矫正镜。有两种不同的添加方式，对应两种不同的望远镜。\n\r施卡和马卡\r\nmounting 系统 实在不知道怎么翻译……\n望远镜有两种 mounting 系统，即地平式及赤道式。对于普通望远镜来说赤道式的望远镜是最适合的，但对于大型望远镜来说，赤道式所承受的重量不够，且有软件的辅助，基本都采用地平式。\n参数 基本参数   口径$D$：最重要的参数。\n  焦距$f$\n  目镜焦距 $f'$\n  人眼参数：瞳孔直径$d_{\\text{pupil}}=6\\text{mm}$，对 555nm 光线最敏感。最小分辨角$e_{\\text{pupil}}\\approx2'$。\n  推导参数 放大率 $$G=f/f'$$ \r\n推导：放大率顾名思义即镜中看到的大小与实际物体角大小的比值。即：\n$$ G=u'/u \\\ns=f\\tan u\\approx fu = f\u0026rsquo;u' \\\nG=u'/u=f/f' $$\n焦比 $F=f/D$，通常写法 f/3.5,f/10 等等。这个数与望远镜收集光的数量相关。\n理论视场 $\\tan(\\omega/2)=D/f$，及其小角近似。简单推导即可得。\n分辨本领、最小分辨角 \r $$\\theta=1.22\\lambda/D$$ 取$\\lambda=550\\text{nm}$，可得：$\\theta(^\u0026quot;)=140/D(\\text{mm})$。\n底片比例尺 $$\\omega=d/f$$ 意为底片上$d$的长度相当于视场中$\\omega$的角大小。推导：\n\r\n极限星等 推导：人眼极限星等 6，口径 6mm。 $$m=6+2.5\\lg(\\frac{D}{6})^2=2.1+5\\lg D$$\n最大放大率 眼睛的最小分辨角/望远镜的最小分辨角即为最大放大率 $$G_{\\text{max}}=2'/\\theta\\approx 2'\\cdot D/\\lambda\\approx D/1\\text{mm}$$\n最小放大率、出瞳口径 \r\n如图，出瞳口径$L$必须比瞳孔大小要小。 $$L=\\frac{f'}{f}D=\\frac{D}{G}$$ 由$L\\le d_{\\text{pupil}}$即可知$G\\ge D/d_{\\text{pupil}}$\n常识 影响观测的因素 seeing（视宁度）：大气的抖动。视宁度越好，大气抖动越少，观测条件越好。\n接收器材 照相底片-\u0026gt;光电倍增管-\u0026gt;CCD（电子耦合器件）\n量子效率逐渐提升，线性性逐渐增加，光子利用率逐渐增大。\n还有另一类重要的观测方法即光谱。\n有两种方法分光：棱镜分光和光栅分光。光栅分光的损耗率远远低于棱镜分光，因此基本都在用光栅分光。\n波段观测 概况 波段分类：\n\r\n波段在大气中的通过率及相关信息：\n\r \r\n蟹状星云在不同波段下的相片：\n\r\n以下的例子都是大型望远镜。\n射电 两种模式：steerable（可转动的）和不可转动的。\n组合模式：单体和多体（使用干涉技术提升等效口径）\n例子：\n可转动的如飞马, green bank\n不可转动如 FAST, Arecibo。这类望远镜其实并不是完全不可动，它可以将一部分球形变形为抛物线形从而接收信号并获得一部分的转向能力。\n多体如 ALMA, VLA。\n微波 微波与射电较为相似，但镜面更加光滑。\n红外 和光学望远镜较为相似。\n由于大气的阻隔，大部分是太空望远镜，只有少部分在高海拔地区的地面望远镜。\n例子：\nHerschel 太空望远镜，鸽王 James Webb 太空望远镜。\n可见光 地面望远镜、太空望远镜。\n分折射、反射。\n最大的折射望远镜是在 Yerkes Observatory 的 1m 折射望远镜。\n现在主流的大口径望远镜都是反射望远镜，有单体磨成的镜片和许多块单独镜面拼成，目前最大 10m，详情见望远镜排行榜。未来的大望远镜有 E-ELT 39m 及 TMT 30m。新技术有主动光学和有限的干涉。\n太空望远镜最著名的就是 Hubble 望远镜。\n紫外 分软紫外及硬紫外。\n说实话，没啥著名的（\nX 射线 分软 X 射线及硬 X 射线。\n由于 X 射线极强的穿透性，导致传统的折射和反射类型望远镜都无法使用。\n有两种解决方案：\n1、grazing（掠射）。如瞳（反向调节最为致命），钱德拉 X 射线天文台。\n2、做成桶状，直接接收。如 HXMT（慧眼）\n$\\gamma$射线 同样的使用掠射的方案。\n著名的卫星有：swift（雨燕）卫星，Fermi（费米）伽马射线太空望远镜。\n有一种间接观测的方法是观测通过$\\gamma$射线与空气之间的切伦科夫效应发出的光，如 MAGIC 望远镜。\n其他媒介 中微子\n中微子与其他物质难以作用，但也不是完全不可作用。主要方法是探测中微子在重水中的切伦科夫辐射。\n著名天文台：日本的神冈、南极的 IceCube。\n引力波\n原理是通过迈克尔逊干涉仪测量空间上的微小震荡从而观测引力波的发生。科学仪器：LIGO。\n后记 望远镜介绍这里好多图都没有放，就是懒……以后有机会补上吧。\n","date":"2021-09-09T23:27:17+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E5%A4%A9%E6%96%87%E6%9C%9B%E8%BF%9C%E9%95%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"天文望远镜基础知识"},{"content":"webpack 学习 介绍 webpack 不用多介绍，一个大名鼎鼎的前端打包工具。\n官网上是这么介绍的：\n 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n 关键概念 webpack 的核心概念有四个：\n 入口(entry) 输出(output) loader 插件(plugins)  webpack 配置文件：\nconst path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./src/js/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;index.bundle.js\u0026#39;, }, module: { rules: [{ test: /\\.txt$/, use: \u0026#39;raw-loader\u0026#39; }], }, plugins: [new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; })], mode: \u0026#39;development\u0026#39;, }; entry 指从指定文件处开始进行打包，output 指定打包后输出的位置及名称。\nmodule(loader)对于引入的特定文件会有特殊的处理。文件通过正则表达式进行匹配，可选择不同的 loader 从而达成不同的操作效果。\nplugin 相较于 loader 则有着更为强大的功能。\nmode 指定工作模式。development 生成文件易读，production 则会开启代码压缩等等。\n一些应用 总体配置 const path = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); // 导入html插件  module.exports = { mode: \u0026#39;production\u0026#39;, entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;index.bundle.js\u0026#39;, }, module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;], }, { test: /\\.sass/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39;], }, { test: /\\.(jpg|png|gif)$/, use: [ { loader: \u0026#39;file-loader\u0026#39;, options: { outputPath: \u0026#39;img\u0026#39;, name: \u0026#39;[hash:10].[ext]\u0026#39;, }, }, ], }, { test: /\\.(csv|txt)$/, use: [\u0026#39;raw-loader\u0026#39;], }, { exclude: /\\.(html|js|css|jpg|png|gif)$/, use: [ { loader: \u0026#39;file-loader\u0026#39;, options: { outputPath: \u0026#39;media\u0026#39;, name: \u0026#39;[hash:10].[ext]\u0026#39;, }, }, ], }, ], }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, }), ], devServer: { hot: true, compress: true, port: 9000, }, }; 学习过程中迷惑的点  在 js 文件中引入的 html 文件使用HTMlWebpackPlugin不需要在\u0026lt;script\u0026gt;\u0026lt;link\u0026gt;等标签中再引入 js 和 css。 一种情况：  import someFile from \u0026#39;./data/someFile\u0026#39;; 若使用file-loader，则 someFile 返回的是地址（网址+目录）\n若使用raw-loader，则返回的是纯文本\n","date":"2021-09-08T23:10:32+08:00","permalink":"https://mizarzh.github.io/p/2021/09/webpack%E5%AD%A6%E4%B9%A0/","title":"webpack学习"},{"content":"最近工作（moon-3d，2021-9-4） 概括 目的：模拟月球天平动和月相，即模拟月球在某个时间点的样子。\n科学方向：月球天平动、NASA 科学程序（jpleph, de440, stellarium(st)源码）\n技术栈：three.js, webGL, webpack 为主的一众打包工具, web 模块化\n未来工作：canvas 视频渲染、科学视频、三维引擎学习\n过程中遇到的具体阻碍：403 Forbidden\n1、数据获取 天平动及月相数据获取 首先有两种方法：力学模拟及直接使用数据。\n前者显然是不可能的，力学模拟天平动考虑的因素和运算量远超个人的能力。因此接下来的工作都在致力于获取天平动的数据集。\n在完全没有任何线索的情况下，我第一时间想到的就是 st 的源代码，因为 st 的模拟不可能没考虑天平动的影响，通过挖掘 st 源代码发现底层数据来源是 NASA 的jpleph 程序及 de441(de440)数据集。\n下一个问题是如何生成数据。理论上可以直接通过 jpleph 的 api 直接生成数据，但需要通过 ftp 获取 jpleph(ftp://ssd.jpl.NASA.gov/pub/eph/planets/ascii/)，访问时总是 timeout。接下来尝试使用 python 的jplephem，却又因为文档不清晰的问题而放弃。最后无奈只能使用 NASA 提供的 web 界面horizons，虽然自定义参数少了许多，但至少好在方便易用。\n仔细阅读horizons 文档并经历了好几次因找不到对应参数而碰壁的过程后，最终确定了一系列需要的参数（一些是展示和验证需要的参数，有三项是模拟必须的参数，用*号标出）：\n 时间。Date__(UT)__HR:MN（UT 时间）以及 L_Ap_SOL_Time（本地太阳时）。 月相相关参数，如被照亮面积百分比（Illu%）及月相角（S-T-O） *月下点经纬度（ObsSub-LON，ObsSub-LAT） *日照中心点经纬度（SunSub-LON，SunSub-LAT） *北极点位置（只需要其中的角度一个参数，NP.ang） 其他重要参数。星等 APmag，表面亮度 S-brt，距离 d 等等  在 horizons 中导出了这些数据的 csv 文件，保存备用。\n其实在过程当中发现了 NASA 的一个页面：Moon Phase and Libration，在这里可以快速找到 2021 一整年的月相及天平动参数，后来发现和 jpleph 生成的参数如出一辙（其实本页下面引用就写着使用的是 jpleph 的数据），但好在 jpleph 的时间跨度和自定义程度远超这个页面，也不枉前面这么久的研究。\n月球模型 又是 NASA 的数据，不得不说 NASA 的科普做得真的好，我们什么时候才能赶上呢……\n来自 NASA 页面CGI Moon Kit，这里提供了各种分辨率的月球表面的图和月球高度图。\n有了以上的数据，就可以开始思考使用什么技术栈实现模拟了。\n2、技术选择 实现的技术有很多：\n 类似 st 的确定太阳月球地球星体位置及各种数据后综合计算 类似 NASA 页面的直接进行三维模拟  对于这个项目来说，显然后者是更好的选择。\n接下来就是技术栈的选择：\n 大型三维软件 unity，blender 等 openGL，使用 python, C++语言 webGL，使用浏览器的渲染 echarts、plotly 等及它们 python 的版本  对于这类科学数据可视化，进行编程的渲染大概率是最可靠的（其实是我不会用第一种的软件）。openGL 和 webGL 的引擎都是偏底层的（应该吧），并不利于快速实现。接下来我将目标转向了 echarts，发现的确是有类似的三维图例，但自由度不能达到项目的需求。最后选择第三种的原因是因为 three.js 库。\nthree.js是在 webGL 上层的一个库，比 webGL 更加高级一点。\n3、编程实现 这段过程就只讲一点点，其他详情直接看源代码。\n坐标轴的确立/旋转方向的确定 因为程序导入月球表面图的中心点是该图的左侧中心点，而 NASA 提供的表面图的经纬度原点是在该图的中心，导致导入后原点位置与预想并不相符。最后选择将摄影机移到经纬度为(0,0)的位置，但这样会导致坐标轴出现问题，因此可以看到 js 其中的一个程序：\nreturn [ r * Math.cos(lat) * Math.cos(lon), r * Math.sin(lat), -r * Math.cos(lat) * Math.sin(lon), ]; 有一个负号。\n其实这个问题是刚上手 three.js 遇到的问题，现在一想直接将球转 90 度不就好了吗……。不过程序既定，就懒得改了。\n旋转方向这个就是玄学问题了……。three.js 里面的 rotate 根本不知道绕着哪个轴转，只能通过实验确定。最后还闹了个笑话：北极点的旋转代码camera.rotateZ(-(rotateAng / 180) * Math.PI)之前是没有负号的，导致月球倾斜方向与正确的方向完全对称。差点就要因为严谨性问题被拉出去打了……\n打包 说实话，对打包/前端工程化的概念在这个暑假才有确切的概念，曾经仅仅是学过而已。一开始选择的是 parcel，因为它的零配置可以让我在时间紧急的情况下（这个项目只用了两天做出来）快速得到编程结果。但到了后面这种简单性变成了累赘：\n parcel 的体积大到离谱。global 安装一次，本地安装一次，我的 C 盘直接就告急了。 到了后期，这种简单的无配置打包逐渐不能适应愈发增加的资源。如这个项目要用到的 png/csv 资源。  因此，最后全面倒向了 webpack。在前段时间学习的 webpack 也算是派上了用场。\nnginx 403 Forbidden 及 gzip 压缩（没错，又是你 nginx） 最后发现是需要将所有文件夹和文件都调成可读及可运行，之前是忘记调成可运行了。\n对于 gzip 压缩，仅需\ngzip_vary on;\rgzip_proxied any;\rgzip_comp_level 6;\rgzip_buffers 16 8k;\rgzip_http_version 1.1;\rgzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r取消这一段的注释即可。\n4、一点想法 曾经的我还未被物理摧毁信心时，总会想着做一些数据驱动的科普小视频。这类视频没办法简单用 AE 做，因为 AE 的图像难以使用科学数据量化。\n可视化编程则是没有什么思路，特别是三维。这个项目前我大概只知道 matplotlib 和 plotly 等一系列可视化项目，但 matplotlib 的三维简直垃圾，echarts 等可视化项目的包装程度太高了，有时候一些想法没办法做。\n在这个项目后，确实是打开了思路。three.js/echarts/d3 等等优秀的前端可视化库也可以做到优秀的数据可视化。至于导出图片/视频的问题，因为 webGL 是渲染在 canvas 元素上，因此我们只需考虑如何导出 canvas 的数据即可。一些库如 node-canvas 和 CCapture.js 等就能做到。\n当然，并不意味着 python 就一无是处了，有一些我以前不知道的优秀的 python3d 库也是很能胜任这个任务的，且 python 的科学库比 node 多得多，以后有机会也会去体验一下。\n","date":"2021-09-08T23:05:27+08:00","permalink":"https://mizarzh.github.io/p/2021/09/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952021-9-4-moon3d/","title":"最近进展2021-9-4 moon3d"},{"content":"初始配置 2020-12-23 这真的是大工程…… 简单说来，由于学生机服务器带宽过于拉跨，因此想使用学生机frp做内网穿透，使用raspberry作为wordpress服务器。 wordpress中文官网 此文章主要参考这个教程以及这个配置来操作。 以下内容默认开启su\n1、下载 使用wget获取官网下载内容：\nwget https://cn.wordpress.org/latest-zh_CN.tar.gz tar -zxvf latest-zh_CN.tar.gz 然后见到一大堆php文件，不要慌，先将文件夹中wp-config-sample.php复制一份并改名为wp-config.php。 复制一份到/var/www/html或者其子文件夹处，这一份是被别人访问的。修改访问权限（不知道这步有没有用）：\nchown -R www-data:www-data /var/www/html 接下来整一些别的东西。\n2、数据库 wordpress是需要使用数据库的，我嫌弃mysql安装太麻烦而且不在apt中，改用mariadb，其用法与mysql基本一致。\napt install mariadb-server #安装 mysqladmin -u root password \u0026#34;[enter your password here]\u0026#34; #设置root密码 mysql -u root -p #用root用户密码登录 #以下是在mysql环境中操作CREATEDATABASEwordpress#创建新数据库wordpress#这两句似乎是授予权限，但是感觉就在服务器本机做这个没什么必要GRANTALLPRIVILEGESONdatabasename.*TO\u0026#34;wordpressusername\u0026#34;@\u0026#34;hostname\u0026#34;FLUSHPRIVILEGES;EXIT;#退出3、配置wp-config.php 修改其中的内容：\n/** WordPress数据库的名称 */ define( \u0026#39;DB_NAME\u0026#39;, \u0026#39;database_name_here\u0026#39; ); /** MySQL数据库用户名 */ define( \u0026#39;DB_USER\u0026#39;, \u0026#39;username_here\u0026#39; ); /** MySQL数据库密码 */ define( \u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;password_here\u0026#39; ); /** MySQL主机 */ define( \u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39; ); 这几句将之前创建的数据库数据填入即可\ndefine( \u0026#39;AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_KEY\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;SECURE_AUTH_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;LOGGED_IN_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); define( \u0026#39;NONCE_SALT\u0026#39;, \u0026#39;put your unique phrase here\u0026#39; ); 填入随机数，在此处获取，直接复制进去就好了。 填入后即完成配置\n4、服务器配置（nginx） nginx代理这部分对于我这种新手来说做起来非常复杂（主要是由于php的原因），在网上也见到不下于三种对nginx的操作，这里选择了成功的一种讲。 首先需要安装php相关服务：\napt install php-fpm php-mysql 接下来修改nginx中的server block configuration部分：\nvim /etc/nginx/sites-available/default 在server出做出如下修改：\n 在index index.html那一行加上index.php 取消对location ~ .php$和location ~/.ht部分的注释，但注意location ~ .php 中只需要开启fastcgi_pass unix://那一条即可（记得匹配fpm版本号） nginx.conf就不需要修改了 此步玩成了就算正式完成了wordpress的配置，打开nginx服务：  service nginx start 打开http://yourip/wp-login.php登陆使用gui配置就方便多啦。 ps：如果是放在/var/www/html的子文件夹处，如/var/www/html/blog，那么就需要在访问网址后加上这个名称，如http://yourip/wp-login.php/blog，或者将nginx配置中的root设为这个目录处。\n5、frp配置 放在有公网的学生机的frps配置：\n[common] bind_port = 7000 vhost_http_port = 80 放在内网web服务的frpc配置：\n[common] server_addr = frp服务器ip server_port = 7000 [web] type = http local_port = 80 custom_domains = frp服务器ip或服务器域名 使用nohup挂载在后台即可\nip迁移 在宿舍迁回家，由于ip不同导致wordpress打开缓慢，这里写下解决方法以备不时之需。\n暴力解决法 在数据库中，修改以下几个表中的值：\n wp_options 直接将表中的option_value 字段中所有的老地址都替换成新地址 update wp_options set option_value = replace(option_value,\u0026lsquo;老地址\u0026rsquo;, \u0026lsquo;新地址\u0026rsquo;); wp_posts 修改guid字段和post_content字段，将其中的老ip替换为新IP wp_dtree_cache 在我的侧边栏菜单里，还需要修改一下这个表才能变过来： update wp_dtree_cache set content = replace(content, \u0026lsquo;老地址\u0026rsquo;, \u0026lsquo;新地址\u0026rsquo;);  UPDATEwp_optionsSEToption_value=replace(option_value,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;)WHEREoption_name=\u0026#39;home\u0026#39;ORoption_name=\u0026#39;siteurl\u0026#39;;UPDATEwp_postsSETpost_content=replace(post_content,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;);UPDATEwp_postsSETguid=replace(guid,\u0026#39;http://www.old.com\u0026#39;,\u0026#39;http://www.new.com\u0026#39;);在nginx中/etc/nginx/sites-available/default中修改地址为新地址\n简单方法 wp-login应该还是可以访问的。通过它进入管理界面，在设置中修改ip地址即可。\n","date":"2021-01-10T20:54:39+08:00","permalink":"https://mizarzh.github.io/p/2021/01/wordpress%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%8F%8Aip%E8%BF%81%E7%A7%BB/","title":"wordpress初始配置及ip迁移"},{"content":"github网址 虽然离开学只有一个月了这个脚本估计也没什么用了233，但是研究这套系统对以后的自动化也是有帮助的。\n研究历程： 其实在五六月份的时候就已经开始想做这个脚本了。我以为只需要直接post账号和密码即可，但是发现是带加密的，当时又很菜不知道怎么搞定lt会更新的问题，于是便搁置了一段时间。但是在某日看到某位dalao在知乎发的贴子，突然就想到使用session保持状态即可（我太菜了）。登录的方法和知乎文章几乎一致。以下是过程：\nlt的值每次会话都会不一样。lt的值储存在页面\u0026lt;input id=\u0026ldquo;lt\u0026rdquo;\u0026gt;的控件中，因此需要使用get方法获取页面并得到lt值\n接下来使用post登录，post需要传递的数据是rsa,ul,pl,lt,execution,_eventId。通过翻阅登录按钮的事件函数发现：\n ul、pl分别为账号和密码长度 rsa是由一个叫strEnc(u+p+lt,\u0026lsquo;1\u0026rsquo;,\u0026lsquo;2\u0026rsquo;,\u0026lsquo;3\u0026rsquo;)的函数算出来的 execution看不懂是什么，一般为e1s1，目测和url的长短有关 _eventId为固定值submit 接下来要解决的问题是如何运行strEnc。首先将strEnc所在的des.js下载到本地，再通过pyExesJS的包运行js得到rsa，再由同一个session post即可完成登录验证。  接下来需要解决上报信息的问题。 这里的表单比较长，建议不要自己填而是抓取网页中post的json下载到本地再加以改造。 表单是报平安的各项数据，基本是固定值，但其中几个时间需要注意，不然可能时间冲突导致无法更新。\n   键 值     \u0026ldquo;inHubeiToHubeiDate\u0026rdquo; 固定为1580910916335   \u0026ldquo;recordDate\u0026rdquo; \u0026ldquo;visitingRelativesOrTravelToWenzhouDate\u0026rdquo; \u0026ldquo;recordShowDate\u0026rdquo; 每日0时的毫秒值   \u0026ldquo;createTime\u0026rdquo; 此页面创建时间的毫秒值，亲测可以使用当前时间代替   \u0026ldquo;updateTime\u0026rdquo; 当前时间的毫秒值    将这些时间数据更新后post即可\n最后是每日定时执行脚本。使用python内部的sched的话需要一直运行python不太方便，于是转而使用系统的定时执行 win系统为例：\n win + R，输入compmgmt.msc 打开任务计划程序栏，创建基本任务 输入名称和描述，设置每天某个时间点运行，操作为启动程序 最重要的一步：程序或脚本输入python.exe，添加参数为.py文件所在位置，起始于为python.exe的位置（添加到了PATH的话应该不需要填写这项）  ","date":"2020-07-04T16:49:29+08:00","permalink":"https://mizarzh.github.io/p/2020/07/%E5%8D%8E%E5%B7%A5%E8%87%AA%E5%8A%A8%E6%8A%A5%E5%B9%B3%E5%AE%89%E8%84%9A%E6%9C%AC/","title":"华工自动报平安脚本"},{"content":"Nodejs服务器 写了一个Tool-box，其中有下载视频的功能。 原理是使用服务端的you-get识别下载网址的url从而得到下载地址，但却冒出一堆奇妙的bug。emm\n起初的想法是用户端发送get/post到服务端，然后服务端调用you-get识别URL并将其返回，再由客户端开启下载。\n首先解决要解决的问题是python的运行环境问题。对于我这种python渣渣来说，用了好一会才搞明白python（或者是anaconda吧）除了REPL还有命令行的直接运行环境（就是有一个base前面的）。使用you-get必须激活这个环境。\nconda activate base you-get -u URL 然后是服务器的routing。用express并不难解决，但是后端功力仍需锻炼。\n最后发现在下载bilibili时遇到了CORS不能跨域的问题（客户端无法调节referer，似乎使用xhr.setRequestHeader也无法设定access-control-allow-origin不过我觉得是我不会用），可能需要改用服务端下载并传输。然后发现无法调用下载的界面emmm，可能需要使用下载.js之类的组件。总之慢慢改善好了。\n\u0026ndash;6/4\u0026ndash; access-control-allow-origin是使用在服务端的回应上的，客户端的Referer单纯用js无法伪造，这类的技术叫做防盗链。但是使用服务端可以伪造referer，因为可能需要将下载放在服务端了。 bootstrap的使用还是比较正常的，就是在使用tab的时候使用flex结构会导致不能相互隐藏，可能是内部还要再套一层div吧。 正在制作新主页。\n计算机组成原理 开始啃四大了233，计算机组成原理6/3到130页，继续加油。 \u0026ndash;6/4\u0026ndash; 计算机组成原理到170页，实在是太难刷了qwq。js算法也快读完了，接下来可以开始搞算(gua)法(ke)了。\n","date":"2020-06-03T23:40:33+08:00","permalink":"https://mizarzh.github.io/p/2020/06/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-6-3/","title":"最近进展2020-6-3"},{"content":"众所周之frp是一款内网穿透工具，可以用来干很多神奇的事情。我使用frp也有很多种目的，接下来就慢慢细说。\nMC服务器 在某个ddl成堆的晚上，某损友找上了我说要帮他整个MC服务器，并向我吹嘘它家的电脑多么强劲。我想着回头再帮他看看吧，最终碍于爱搞事情的本性愉快的放弃了一堆没做的东西开始折腾起怎么搭建mc服务器的事情。\n其实搭建mc服务器本身并不难，在有一台云主机（没有公网ip也想整frp就别想了→_→）的情况下，第一反应就是在云主机上搭建mc服务器。我在之前的blog中已经写过mc服务器应该如何搭建了，但是这孱弱的性能怕撑不起这么多人，加上他吹嘘他家的电脑，我决定使用本地主机搭建服务器+内网穿透的方法搭建多人mc服务器。\n首先先下载frp。 frps是frp的服务器，应放置在有公网ip的服务器上（这里指的是孱弱服务器）。 使用scp传文件到服务器上 frpc是frp的客户端，应放置在要暴露服务的机器上（这里指的是损友电脑）。\n接下来在服务端配置frps.ini：\n[common] bind_port = // 其他机器访问的端口 客户端frpc.ini的配置:\n[common] server_addr = // 服务器的地址 server_port = // frps.ini中的bind_port [minecraft] type = tcp local_ip = 127.0.0.1 // 本地 local_port = 25565 // mc开启的端口 remote_port = 25565 都配置好之后就在命令行中分别运行\n./frps ./frpc 同时开启mc服务器，在其他机器上输入连接frpc.ini中的server_addr:server_port即可开始游戏。\n","date":"2020-05-19T23:36:19+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8Bfrp/","title":"瞎折腾之frp"},{"content":"自从上大学换了新电脑以后，家里的这台没啥电脑知识的我爸在电脑城买的联想傻大黑粗配置还不怎么样的旧笔记本就闲置在家多月。前几个月疫情肆虐，待在家里使用内网的需求也大大提升，于是这台旧电脑就被我改造成了家庭内网服务器。\nVNC viewer 由于旧电脑存了太多的黑历史，一时半会还整理不完全，于是没有办法装linux系统。众所周知win的cmd是个废柴，因此决定使用VNC来远程操控服务器。\n去到VNC的官网下载Windows版本的Server，在一系列操作后就装好了VNC Server。新电脑装上VNC Client就可以访问服务器电脑了。\nPlex 在家庭服务器上部署plex媒体服务，然后就可以在其他设备上自由浏览家庭服务器上的视频资源了。\n去Plex下载处下载windows server，也是和VNC一样简单易用。再给电视装上Plex的应用就可以直接访问服务器的视频资源而不是用蠢到要死的自带资源了。\n初级文件管理及分享 使用windows的鸡肋分享功能做了个简易的文件分享。不得不说windows的配置和用户管理让我摸不着头脑。 首先是文件夹右键-属性-共享-共享\u0026hellip;，然后在下拉框内选择Everyone并添加。这还没完，还需要在高级共享\u0026hellip;勾选共享此文件夹，并在权限内添加everyone的读取/写入权限，才能算完全开启文件夹的共享功能。 这一套下来就搞不懂用户的用处以及为什么要分两个共享……，之前有一段时间似乎是想明白有什么区别，但是现在又搞不清楚了。 anyway，总之共享上能用，没有什么问题了。然后android手机安装文件管理器app，就可以远程访问服务器内的资源了。只不过访问必须要使用anonymous访问，不然不管输入什么用户名什么密码都无法连接。\naria2 ","date":"2020-05-19T23:36:02+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8B%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"瞎折腾之家庭服务器"},{"content":"nodejs入门笔记 全局对象 global process属性 提供了一个与操作系统的简单接口\n process.argv是命令行参数数组 process.stdout是标准输出流。stdout.write()更加底层 process.stdin是标准输入流。初始被暂停，要读取必须恢复流：  process.stdin.resume(); process.nextTick(callback)的功能是为事件循环设置一项任务，Node.js 会在下次事件循环调响应时调用 callback。  console 用于向标准输出流（stdout）或标准错误流（stderr）输出字符\n log() error() trace(),向标准错误流输出当前的调用栈。  常用工具 util  inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。  还有isArray(),isRegExp(),isDate(),isError(),format(),debug()\n事件驱动 events  EventEmitter事件发射器。  var events = require(\u0026#39;events\u0026#39;); var emitter = new events.EventEmitter(); emitter.on(\u0026#39;aEvent\u0026#39;,function(arg1,arg2){ //dosomething(); }) emitter.emit(\u0026#39;aEvent\u0026#39;,arg1,arg2) EventEmitter.on(event, listener) 为指定事件注册一个监听器 EventEmitter.emit(event, [arg1], [arg2], [\u0026hellip;]) 发射 event 事件 EventEmitter.once(event, listener) 为指定事件注册一个单次监听器 EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。 2. error事件\nemitter.emit(\u0026#39;error\u0026#39;); 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它  fs  readFile(filename,[encoding],[callback(err,data)]) 或readFile(filename,[callback(err,data)]) 同步版本readFileSync(filename, [encoding]) open(path, flags, [mode], [callback(err, fd)]) flags:r r+ w w+ a a+ mode:用于创建文件时给文件指定权限 fd:文件描述符。是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引 read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)]) write同理  http HTTP 服务器 var http = require(\u0026#39;http\u0026#39;); http.createServer(function (req,res){ res.writeHead(\u0026#39;200\u0026#39;,{\u0026#39;Content-Type\u0026#39;:\u0026#39;text/html\u0026#39;}); res.write(\u0026#39;\u0026lt;h1\u0026gt;Node.js\u0026lt;/h1\u0026gt;\u0026#39;); res.end(\u0026#39;\u0026lt;p\u0026gt;test\u0026lt;/p\u0026gt;\u0026#39;); }).listen(3000); console.log(\u0026#39;http server is listening at port 3000\u0026#39;); http.createServer 创建了一个 http.Server 的实例\nhttp.Server 的事件  request:当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是 http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。 connection:当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为 net.Socket 的实例。 close:当服务器关闭时，该事件被触发。 除此之外还有 checkContinue、upgrade、clientError 事件 createServer（创建一个 HTTP 服务器并将requestListener 作为 request 事件的监听函数）拆开写法：  var server = new http.Server(); // 新建http.Server实例 // 在服务器收到请求时的事件响应 server.on(\u0026#39;request\u0026#39;, function (req, res) { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); res.write(\u0026#39;\u0026lt;h1\u0026gt;Node.js\u0026lt;/h1\u0026gt;\u0026#39;); res.end(\u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;); }); // 指定服务器监听端口 server.listen(3000); http.ServerRequest 事件\n data:当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。 end:当请求体数据传输完成时，该事件被触发 close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。  属性 complete 客户端请求是否已经发送完成 httpVersion,method,url,headers,trailers,connection,socket,client\n获取GET内容 使用url模块中的parse解析url参数，生成一个对象\n获取POST内容 var querystring = require(\u0026#39;querystring\u0026#39;); http.createServer(function (req, res) { var post = \u0026#39;\u0026#39;; // 侦测POST传入的data事件并记录  req.on(\u0026#39;data\u0026#39;, function (chunk) { post += chunk; }); // 检测传入是否结束  req.on(\u0026#39;end\u0026#39;, function () { post = querystring.parse(post); res.end(util.inspect(post)); }); }).listen(3000); http.ServerResponse 返回给客户端的信息\n writeHead(statusCode, [headers])：向请求的客户端发送响应头。 write(data, [encoding])：向请求的客户端发送响应内容。 end([data], [encoding])：结束响应，必须被调用一次。  HTTP 客户端 http.request(options, callback) 发起 HTTP 请求。 options:\n{ host : 127.0.0.1, // 请求网站的ip地址  port : 3000, // 请求网站的端口  method : \u0026#39;get\u0026#39;, //请求方法  path : //相对于根的路径，应该包括queryString  headers : //请求头的内容 } callback 传递一个参数，为 http.ClientResponse 的实例。 http.request 返回一个 http.ClientRequest 的实例。\nhttp.get(options, callback),自动将请求方法设为了 GET 请求，同时不需要手动调用req.end()。\nhttp.ClientRequest 它提供一个 response 事件 提供了 write 和 end 函 数，用于向服务器发送请求体 request.abort()：终止正在发送的请求。 request.setTimeout(timeout, [callback])：设置请求超时时间 request.setNoDelay([noDelay])、request.setSocketKeepAlive ([enable], [initialDelay])\nhttp.ClientResponse 事件 data、end 和 close response.setEncoding([encoding])：设置默认的编码 response.pause()：暂停接收数据和发送事件 response.resume()：从暂停的状态中恢复\n","date":"2020-05-19T22:54:13+08:00","permalink":"https://mizarzh.github.io/p/2020/05/nodejs%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","title":"nodejs入门笔记"},{"content":"科学动画\n5-10 有两种类型的图片： 1、类似于js中canvas和python中matplotlib的位图 2、类似于svg或操作html DOM元素的矢量图\n使用js做动画 本来想使用canvas或anime.js做动画，但碍于一些原因（比如不能生成图片），甚至不如python直接画\n使用python做动画 本来想使用matplotlib.animation做动画，但是发现ffmpeg的配置有问题（即使将ffmpeg放到PATH或者使用pip和conda安装ffmpeg都不行）。于是就使用最原始的方法：生成图片再使用ffmpeg合成视频\nimport matplotlib.pyplot as plt import numpy as np import scipy as sci import math import random a = 100 b = 90 c = math.sqrt(abs(a**2 - b ** 2)) theta = [] x = [] y = [] color = [\u0026#39;red\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;green\u0026#39;] SMI_max = 2 * c #ellipse for i in np.linspace(0 , math.pi * 2, 300): x.append(a * math.cos(i)) y.append(b * math.sin(i)) line = np.linspace(-b,b,100) #for theta in np.linespace(0, math.pi * 2, 10000) #知道theta的情况 def calc(theta): SMI = (math.sqrt((a+c)**2 - (c * math.sin(theta))**2) - c * math.cos(theta) - \\ math.sqrt((a * math.cos(theta))**2 + (b * math.sin(theta))**2)) / (2 * c) return SMI plt.figure(figsize=[6,6],dpi = 300) count = 0 for theta in np.linspace(0, math.pi * 8, 300): ax = plt.gca() ax.set_aspect(1) plt.axis(\u0026#39;off\u0026#39;) plt.plot(x,y,c=\u0026#39;C1\u0026#39;,zorder=0) for i in range(0,99): plt.plot([120,120],[line[i],line[i+1]],c = color[i % 3],zorder=0) plt.scatter(-c,0,s = 100) plt.scatter(a * math.cos(theta),b * math.sin(theta),zorder = 1, c=\u0026#39;gray\u0026#39;,s=10) plt.scatter(120,calc(theta) * 2 * b - b,zorder = 1,c=\u0026#39;purple\u0026#39;,s=10) plt.savefig(\u0026#39;pictures2/\u0026#39; + str(count) + \u0026#39;.jpg\u0026#39;) plt.clf() count += 1 然后就在pictures2中生成了300张图片，再使用ffmpeg：\nffmpeg -i %d.jpg -r 25 output.mp4 -r指fps\n5-11 将右侧坐标变为渐变色： plot是不能直接使用渐变色的，因此这里使用scatter强行画出渐变色\n# 渐变颜色 cmap_i = np.linspace(-b, b, 100) plt.scatter([110]*100, cmap_i, zorder=0,c=cmap_i, cmap=plt.get_cmap(\u0026#39;cool\u0026#39;),marker=\u0026#39;s\u0026#39;,s=5) # 标注 plt.plot([109, 111], [-b, -b], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [b, b], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [0, 0], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [b/2, b/2], zorder=0, c=\u0026#39;black\u0026#39;) plt.plot([109, 111], [-b/2, -b/2], zorder=0, c=\u0026#39;black\u0026#39;) plt.text(112, -b - 2, \u0026#39;0%\u0026#39;, fontsize=8) plt.text(112, b - 2, \u0026#39;100%\u0026#39;, fontsize=8) plt.text(112, -2, \u0026#39;50%\u0026#39;, fontsize=8) plt.text(112, b/2 - 2, \u0026#39;75%\u0026#39;, fontsize=8) plt.text(112, -b/2 - 2, \u0026#39;25%\u0026#39;, fontsize=8) 去除图片周围空白：\nplt.savefig(\u0026#39;pictures3/\u0026#39; + str(count) + \u0026#39;.png\u0026#39;, bbox_inches=\u0026#39;tight\u0026#39;) 每次打开生成图片使用clf()清理后，循环内使用的就是一个新的figure，其他图片设置中的设置就不会起作用。如果将plt.figure放到循环内，就会因为生成太多figure而出错 原代码：\nplt.figure(figsize=[6, 6], dpi=300) for theta in np.linspace(0, 8 * math.pi, 300): #其他图片设置 #作图 plt.clf() 使用plt.close()就可以真正的清理掉一个figure 修改后：\nfor theta in np.linspace(0, 8 * math.pi, 300): plt.figure(figsize=[6, 6], dpi=300) #其他图片设置 #作图 plt.close() 生成图片后，使用PIL放入月球和地球的图片。接下来就遇到了最难受的坐标转化问题。 一开始月球和点之间总是差一点点距离，后来强行乘了一个系数后便正常了\nmoon = Image.open(\u0026#39;moon.png\u0026#39;).resize([50, 50]) earth = Image.open(\u0026#39;earth.png\u0026#39;).resize([500, 500]) im = Image.open(\u0026#39;pictures3/0.png\u0026#39;) arg = 0.96 centerX = im.size[0] / 2 centerY = im.size[1] / 2 c_c = c / figlen / 2 * im.size[0] * arg imc = 0 for theta in np.linspace(0, 8 * math.pi, 300): im = Image.open(\u0026#39;pictures3/\u0026#39; + str(imc) + \u0026#39;.png\u0026#39;) c_x = a * math.cos(theta) / figlen / 2 * im.size[0] * arg c_y = b * math.sin(theta) / figlen / 2 * im.size[1] * arg layer = Image.new(\u0026#39;RGBA\u0026#39;, im.size, (0, 0, 0, 0)) layer.paste( earth, (int(centerX - c_c - earth.size[0] / 2), int(centerY - earth.size[1] / 2))) layer.paste(moon, (int(centerX + c_x - moon.size[0] / 2), int(centerY - c_y - moon.size[1] / 2))) out = Image.composite(layer, im, layer) out.save(\u0026#39;output/\u0026#39; + str(imc) + \u0026#39;.png\u0026#39;, \u0026#39;PNG\u0026#39;) imc += 1 最终效果： \r2.jpg\r\n（未完待续）\n","date":"2020-05-10T23:17:07+08:00","permalink":"https://mizarzh.github.io/p/2020/05/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-5-10/","title":"最近进展2020-5-10"},{"content":"这两天闲来无事，写了两个和展示文字相关的页面，其中遇到了读取文本与跨网页通信的问题。\n文件操作 js中直接读取和处理本地的文件是很困难的（除非nodejs），这种事情还是交给python比较好 但是可以手动上传文件从而达到读取的目的。使用HTML5的新功能。 首先使用\u0026lt;input type=\u0026ldquo;file\u0026rdquo;\u0026gt; 从而获得文件。\n选择文件后可以通过inputDOM.files获取文件的FileList，再通过数组访问则可以得到文件（但是不能直接显示内容）\ninputDOM = document.querySelector(input[type=file]) inputDOM.files // FileList file = inputDOM.files[0] file.name //文件名 file.size //文件大小 file.webkitRelativePath //路径 file.type //文件类型 使用FileReader来读取文件中的内容。\nvar fReader = new FileReader() fReader.readAsText(file) //读取文件 fReader.result //显示文本内容 FileReader有四种打开方式，我们这里只用到了readAsText。\n跨网页通信 跨域通信可以直接使用XHR，不在这里的讨论范围。 使用H5的新功能localStorage：\nlocalStorage.setItem(\u0026#39;name\u0026#39;,\u0026#39;value\u0026#39;) //设置本地储存值 localStorage.removeItem(\u0026#39;name\u0026#39;) //移除本地储存值 这样在两个不同的网页也可以读取相同的本地存储 另一种方法（H5之前）是使用Cookie。\n","date":"2020-04-24T23:23:20+08:00","permalink":"https://mizarzh.github.io/p/2020/04/js%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8E%E8%B7%A8%E7%BD%91%E9%A1%B5/","title":"js的读取文本与跨网页"},{"content":"wincmd脚本 ffmpeg ffmpeg -ss 00:00:00 -t 00:00:03.000 -i \u0026#34;x.wav\u0026#34; -filter_complex afade=t=out:st=1:d=2 \u0026#34;y.wav\u0026#34; -filter_complex afade=t=out:st=1:d=2 代表从1s开始淡出，持续2s\njs 文件读取 界面 机理 html \u0026lt;audio\u0026gt; 的使用\npython 月球项目 首先调用astropy的solar_system_ephemeris.set(\u0026lsquo;jpl\u0026rsquo;)，从jpl处下载数据 然后使用astropy.coordinates中的get_moon()和get_sun()函数获取日月的RA、DEC、distance 先找到满月的第一个点，然后取下一次时间时增加一个朔望月周期，并在其周围(-1.2,1.2,0.1)进行校正，矫正次数记录在err.txt，因此这种计算的误差为+-0.05d\nfrom astropy import units as u from astropy.time import Time import numpy as np from astropy.coordinates import solar_system_ephemeris from astropy.coordinates import get_moon, get_sun x = open(\u0026#39;datafull.txt\u0026#39;, \u0026#39;w\u0026#39;) y = open(\u0026#39;datanew.txt\u0026#39;, \u0026#39;w\u0026#39;) z = open(\u0026#39;err.txt\u0026#39;, \u0026#39;w\u0026#39;) jds = Time(\u0026#39;1900-01-15T19:12:00.000\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd jds2 = Time(\u0026#39;1900-01-01T14:24:00.000\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd jde = Time(\u0026#39;2100-01-01T00:00:00\u0026#39;, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;).jd # 2488069.5 circle = 29.53059 #一个朔望月周期 h = True #进度条相关 m = (jde + jds)/2 #进度条相关 def diff(ra1, ra2): dra = abs(ra1-ra2) if dra \u0026gt; 180: dra = 360 - dra return dra for i in np.arange(jds, jde, circle): largest = 0 #最大RA距离 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i \u0026gt; m and h): print(\u0026#39;half1\u0026#39;) h = False z.write(\u0026#39;--------------\\n\u0026#39;) for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format=\u0026#39;jd\u0026#39;, scale=\u0026#39;tdb\u0026#39;) #在朔望月周期附近微调 moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra \u0026gt; largest): #判断是否为最大 largest = dra #最大RA距离 dis = moon.distance.value #最大RA距离时距离 time = t #最大RA距离时时间 errcount += 1 z.write(str(errcount)) z.write(\u0026#39;\\n\u0026#39;) x.write(time.iso + \u0026#39; \u0026#39;) x.write(str(time.jd) + \u0026#39; \u0026#39;) x.write(str(dis)) x.write(\u0026#39;\\n\u0026#39;) print(\u0026#39;end1\u0026#39;) h = True m = (jde + jds2)/2 x.close() z.write(\u0026#39;++++++++++++++++++++++++++\\n\u0026#39;) for i in np.arange(jds2, jde, circle): smallest = 180 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i \u0026gt; m and h): print(\u0026#39;half2\u0026#39;) h = False z.write(\u0026#39;--------------\\n\u0026#39;) for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format=\u0026#39;jd\u0026#39;, scale=\u0026#39;tdb\u0026#39;) moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra \u0026lt; smallest): smallest = dra dis = moon.distance.value time = t errcount += 1 z.write(str(errcount)) z.write(\u0026#39;\\n\u0026#39;) y.write(time.iso + \u0026#39; \u0026#39;) y.write(str(time.jd) + \u0026#39; \u0026#39;) y.write(str(dis)) y.write(\u0026#39;\\n\u0026#39;) print(\u0026#39;end2\u0026#39;) y.close() z.close() 文件读取：\nx = open(\u0026#39;xxx\u0026#39;,\u0026#39;r\u0026#39;) #有很多选项 x.read() x.readlines() csv:\nwith open(\u0026#39;xxx.csv\u0026#39;,\u0026#39;r\u0026#39;) as f freader = csv.reader(f) for row in freader: #... fdreader = csv.DictReader(f) #读字典 with open(\u0026#39;xxx.csv\u0026#39;,\u0026#39;w\u0026#39;,newline=\u0026#39;\u0026#39;) as f #newline = \u0026#39;\u0026#39;是为了防止每次写完之后都换行 fwriter = csv.writer(f) fwriter.writerow([xx,xx,xx]) fdwriter = csv.DictWriter(f) #写字典 json:\nimport json json.dumps(某个数据结构) #将某个数据结构转化为json j = json.loads(某json) #将json转化为python内置数据结构 从香港天文台获取数据，使用爬虫：\nfrom urllib.request import urlopen from urllib.request import Request import time #for i in range(0,100): maping = {} file = open(\u0026#39;s2l.txt\u0026#39;,\u0026#39;a\u0026#39;) url = \u0026#39;https://www.hko.gov.hk/tc/gts/time/calendar/text/files/\u0026#39; headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39; } for i in range(0,200): fileName = \u0026#39;T\u0026#39; + str(1901 + i) +\u0026#39;c.txt\u0026#39; req = Request(url = url + fileName,headers = headers) x = urlopen(req) fulltext = x.read().decode(\u0026#39;Big5\u0026#39;) fulllist = fulltext.split(\u0026#39;\\n\u0026#39;)[3:-1] for j in range(0,len(fulllist)): file.write(fulllist[j] + \u0026#39;\\n\u0026#39;) print(i) time.sleep(1) file.close() 后续将尝试转化农历和公历\n","date":"2020-04-09T11:50:15+08:00","permalink":"https://mizarzh.github.io/p/2020/04/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-9/","title":"最近进展2020-4-9"},{"content":"1、写了一个网页 前端练习 website\n2、配置服务器 Jupyter notebook\n3、学习爬虫 4、事件相关 某同学的一个网页，写一个js脚本，重复点击四（五）个按钮。\n首先找出每个按钮（button）的定位，这里使用document.querySelector()定位\nvar x = document.querySelector(str[0]); var button = [\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#34;.ut-button-group:first-child\u0026#34;,\u0026#34;ut-navigation-button-control\u0026#34;]; 接下来调试，发现无法使用x.click()点击按钮。使用浏览器查看事件发现使用了mousedown和mouseup确定点击事件 修改代码：\nfunction handler(str){ var x = document.querySelector(str); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } var button = [\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#34;.ut-button-group:first-child\u0026#34;,\u0026#34;ut-navigation-button-control\u0026#34;]; 再令其每隔一段时间点击一次按钮，则：\nwhile(true){ for(let i = 0;i \u0026lt; button.length;++i){ setTimeout(handler(button[i]),1000); } } 发现setTimeout好像并不是很符合要求（似乎是因为setTimeout并不会真的等待一段时间才执行下一个循环，而是生成四个setTimeout进程）。于是改用了setInterval，并增加了一些东西：\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var i = button.length - 1; var count = 0; var id; function handler(){ loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 500){ clearInterval(id) } } id = setInterval(handler,5000); （所有代码，以后可能会增加try catch块）\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var input = document.querySelector(\u0026#39;.numericInput\u0026#39;); var i = button.length - 1; var count = 0; var id; function doer(ci = i){ var x = document.querySelector(button[ci]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function handler(){ try{ loop_i(); doer(); } catch(e){ if(e instanceof TypeError){ console.error(\u0026#34;TypeError\u0026#34;); i = 0; doer(4); } else{ console.error(\u0026#34;UnknownError\u0026#34;); i = 0; doer(4); } } } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 20){ input.value = 0; } } id = setInterval(handler,5000); clearInterval(id) 加入try catch块\nvar button = [\u0026#39;.increment-value\u0026#39;,\u0026#34;.call-to-action\u0026#34;,\u0026#34;.buyButton\u0026#34;, \u0026#39;section.Dialog .ut-button-group button\u0026#39;,\u0026#34;.ut-navigation-button-control\u0026#34;]; var i = button.length - 1; var clear = document.querySelector(\u0026#39;.flat.camel-case\u0026#39;); var count = 0; var id; function handler(){ loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); x.dispatchEvent(up); } function loop_i(){ ++count; if(i === button.length - 1) i = 0; else ++i; if(count \u0026gt;= 5){ var down = document.createEvent(\u0026#34;MouseEvents\u0026#34;); down.initMouseEvent(\u0026#34;mousedown\u0026#34;, true, true, document.defaultView); clear.dispatchEvent(down); var up = document.createEvent(\u0026#34;MouseEvents\u0026#34;); up.initMouseEvent(\u0026#34;mouseup\u0026#34;, true, true, document.defaultView); clear.dispatchEvent(up); count = 0; } } id = setInterval(handler,5000); 另一种解法\n","date":"2020-04-02T23:39:38+08:00","permalink":"https://mizarzh.github.io/p/2020/04/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-2/","title":"最近进展2020-4-2"},{"content":"远端jupyter notebook的配置 python下载 这里使用anaconda\nwget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh ./Anaconda3-2020.02-Linux-x86_64.sh 并一直yes，安装anaconda\njupyter notebook配置 conda jupyter notebook #anaconda安装jupyter notebook jupyter notebook --generate-config #生成配置文件 配置文件为.jupyter/jupyter_notebook_config.py\n打开IPython，产生密码：\nIn [1]: from notebook.auth import passwd In [2]: passwd() 接下来就会让你输入密码，输入密码后就会生成一个\u0026rsquo;sha1:xxx\u0026rsquo;的东西，复制它。\nvim .jupyter/jupyter_notebook_config.py 修改以下选项（可以使用vim \u0026lsquo;/\u0026lsquo;的搜索功能）：\nc.NotebookApp.ip=\u0026#39;*\u0026#39; #可以由所有ip访问jupyter notebook c.NotebookApp.password = \u0026#39;sha:xx\u0026#39; #刚刚复制的东西 c.NotebookApp.open_browser = False #启动不打开浏览器 c.NotebookApp.port =8888 #使用的端口 启动：\njupyter notebook 或者后台一直启动：\nnohup jupyter notebook\u0026amp; 使用插件 conda install -c conda-forge jupyter_contrib_nbextensions jupyter contrib nbextension install --user 然后在header处就能见到多一个nbextensions选项卡，进入里面选择所需的插件即可\n","date":"2020-03-25T17:01:13+08:00","permalink":"https://mizarzh.github.io/p/2020/03/jupyter-notebook%E9%85%8D%E7%BD%AE/","title":"jupyter notebook配置"},{"content":"一个文学渣的瞎唠嗑\n《雪国》[日]川端康成 创作于1935-1948年\n自己的想法： 这的确是一本非常晦涩难懂的书。驹子对岛村的感情表达地十分晦涩（当然在岛村每次到雪国时感情都会深入，但书中没有明说），而岛村对她的感想则是全书的核心：“徒劳”。岛村认为驹子的生活是徒劳的，也能在书中读出来驹子平日生活（忍不住打扫）、待人（为了行男和养家而做艺妓）的辛苦。结尾最后很短的篇幅爆发，虽然结尾很难读懂就是了……\n参考资料后： 岛村追求的是一种虚幻的美丽（虚无主义）。他热衷于写舞蹈的文章，却不去追求真正的舞蹈；他对叶子映在车窗上的倒影入迷，却对驹子注重现实生活而感到徒劳。他觉得现实生活中的一切东西都是“徒劳”的，去做也没有什么用。 叶子暗喻了驹子的精神。叶子对驹子的责怪就是驹子对自己的责怪；叶子对驹子的嫉妒就是驹子对自己的嫉妒；叶子对岛村的爱慕就是驹子对岛村的爱慕。而最后叶子在火灾中死去，驹子失去了精神，便是结尾处的“疯掉了”。 展现了作者的一些看法：死的唯美意境，虚无与悲观。\n 《雷雨》曹禺 1934年7月发表，背景在1925年前后 受某人推荐，同时因为在教科书中有出现过所以感觉挺有意思的，就决定开始看了。\n自己的想法： 如果不考虑什么文学性和时代背景的话，剧情可以说算是很狗血了233。当然评判这一部冲突性极强的戏剧单纯考虑男欢女爱的情节是不合适的。文章主要围绕着当时贫苦人民和资本家之间的矛盾与冲突，非常生动的展示了当时的社会大环境——资本家毫无同情心的剥削普通民众，普通人民苦不堪言；男权（不知道作者有没有这方面的想法了）主导，女性成为附庸。 在这个背景下，许多人的关系交织。鲁家有没文化的鲁贵频频向资本家低头不肯斗争，有涉世未深的四凤还未看出资本家的邪恶，也有鲁侍萍、鲁大海坚决与资本家势不两立（但是反抗程度有所不同）；周家有象征着当时资本家的周朴园，有在周朴园压迫下的蘩漪，有儒弱的周萍，也有作为地主和资本家的儿子但却关心鲁家的周冲。路人也有在吃到甜头后就不再反抗的工人。人物代表了当时各种态度的人，性格丰富，冲突也十分激烈，着实精彩（就是情节是有点狗血233）。 虽然我并不是很认同将这部作品强加在工人阶级觉醒之类的上面（不然鲁大海的下场也不会是这样了，但显然语文课本就是这么做的），但是可以确定这部作品绝对是有对于资本家和大地主对普通人民各种手段的剥削和压制的严厉的批判的。\n参考资料后（直接抄百度）： 《雷雨》所展示的是一幕人生大悲剧，是不平等的社会里，命运对人残忍的捉弄。周朴园的专制、冷酷和伪善；周冲的热情和单纯；以及蘩漪对爱情的深挚乃至略显变态的执着；痛悔着罪孽却又不自知地犯下更大罪孽的软弱的周萍；被侮辱的被捉弄的悲苦的鲁妈……还有家庭的秘密，身世的秘密，所有这一切在一个雷雨夜爆发。最后，有错的、有罪的，无错的、无辜的人，竟然一起走向了毁灭。它讲述了资产阶级周家和城市平民鲁家两个家庭纠结复杂的悲剧故事。一是以周朴园为代表的带有浓厚封建色彩的资产阶级家庭的生活悲剧：二是以鲁妈为代表的城市平民不能把握自己命运、被别人所操控的悲惨境遇。而周、鲁两家复杂的血缘联系，更是突出、生动地反映了两个不同阶层的家庭之间的矛盾。揭露了旧中国旧家庭的种种黑暗现象以及地主资产阶级的专横、冷酷与伪善，反映了中国20世纪二、三十年代正在酝酿着一场大变动的社会现实，对受压迫者给予了深切的同情。\n","date":"2020-03-16T23:12:57+08:00","permalink":"https://mizarzh.github.io/p/2020/03/%E5%90%8D%E8%91%97%E7%9F%AD%E8%AF%84/","title":"名著短评"},{"content":"思路： 模型： $$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$\n其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离\n轨道计算：先计算出椭圆轨道的参数，再映射到实际轨道当中\n数据 Orbital elements: C/2019 Y4 (ATLAS) Epoch 2020 May 31.0 TT = JDT 2459000.5 T 2020 May 30.99149 TT Bell q 0.2522871 (2000.0) P Q z +0.0052736 Peri. 177.54315 +0.48067371 +0.62763038 +/-0.0005749 Node 120.47328 -0.81617007 +0.57558163 e 0.9986695 Incl. 45.27974 -0.32065433 -0.52420025 From 171 observations 2019 Dec. 28-2020 Jan. 9, mean residual 0\u0026quot;.4.\ne (eccentricity) : 0.9991890 q (perihelion distance) : 0.2529910 i (inclination) : 45.39050 Ω (Longitude of ascending node) : 120.57800 ω (Argument of perihelion) : 177.39850 L (Longitude of perihelion) : 118.75041 B (Latitude of perihelion) : 1.85172 T (Time of perihelion passage) : 2459000.54440 P (Orbital period in years) : 5509.68 Epoch : 2020 Feb 27 Family/Group: : Nearly isotropic\n02 January 2020 00:00 UTC\n轨道根数： – semimajor axis a, – eccentricity e, – inclination i (or ι), – longitude of the ascending node Ω, – argument of the perihelion ω, – time of the perihelion τ. (或者true anomaly或者mean anomaly)\n作图 三维图： mplot3d\nfrom mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import numpy as np ax1 = plt.axes(projection=\u0026#34;3d\u0026#34;) ax1.set_xlim3d(-lim,lim) ax1.set_ylim3d(-lim,lim) ax1.set_zlim3d(-lim,lim) ax1.plot3D(x,y,z) plt.show() 在jupyter notebook上：\n%matplotlib notebook ax1.mouse_init() #使用鼠标操控 ax1.view_init(elev=number, azim=number) #调整视角 交互式plotly\n天文相关 poliastro 问题：使用Orbit.from_classical时的ecc过大，导致数据精度不足（或者是使得运行时间过长），但是使用直接绘图就没有这个问题 poliastro\nastropy\nfrom astropy import units as u from astropy.coordinates import CartesianRepresentation u.deg u.one u.km u.AU #单位 CartesianRepresentation.x.value #带单位转化为值 astropy\n目前状况（2020-03-16） 爆肝到两点emm 之前某个时间也强行写了很久\n结构：轨道运算、画图、Mk计算 轨道运算：poliastro库 导入轨道后再导出数据 使用近日点的true anomaly和mean anomaly都为0的方法规避这个库只能输入true anomaly的缺点（使用t代替，然后再使用propagation()确定相应的时间）\ntime2 = \u0026#34;2020-05-31T00:51:39\u0026#34; t2 = Time(time2, format=\u0026#39;isot\u0026#39;, scale=\u0026#39;tdb\u0026#39;) se = Orbit.from_body_ephem(Earth,t2) sc = Orbit.from_classical(Sun,a,ecc,inc,raan,argp,0 * u.deg,t2) setemp = Orbit.from_classical(Sun,se.a,se.ecc,se.inc,se.raan,se.argp,se.nu,t2) #鬼知道我遇到了什么，必须再导入时间才能正常 orbnc = [[],[],[]] #comet[[xs],[ys],[zs]] orbne = [[],[],[]] #earth for x in np.linspace(-60 * u.day,60 * u.day,120): #-60 - 60 天 orbnctemp = sc.propagate(x) #x为astropy.unit的时间，用来计算经过某段时间后的轨道 pn1 = orbnctemp.represent_as(CartesianRepresentation) #表示为xyz轴 orbnc[0].append(pn1.x.value) orbnc[1].append(-pn1.y.value) orbnc[2].append(-pn1.z.value) xc = pn1.x.value / (1.5 * 10**8) #转化为AU yc = pn1.y.value / (1.5 * 10**8) zc = pn1.z.value / (1.5 * 10**8) orbnetemp = setemp.propagate(x) pn2 = orbnetemp.represent_as(CartesianRepresentation) orbne[0].append(pn2.x.value) orbne[1].append(-pn2.y.value) orbne[2].append(-pn2.z.value) xe = pn2.x.value / (1.5 * 10**8) ye = pn2.y.value / (1.5 * 10**8) ze = pn2.z.value / (1.5 * 10**8) r.append(math.sqrt(xc**2+yc**2+zc**2)) d.append(math.sqrt((xe-xc)**2+(ye-yc)**2+(ze-zc)**2)) #计算 m = M + 5lgd + klgr 的参数r,d 最小二乘：\n#此处lgr lgd m已输入数据 A = np.vstack([lgr, np.ones(len(lgr))]).T np.linalg.lstsq(A,m - 5 * lgd,rcond=None) #输出[[斜率，截距],[方差],xx,xx] plt.scatter(lgr,m - 5 * lgd) #观察离散程度 M = 3.94 k = 25 y1 = [] y2 = [] for x in np.linspace(0,119,120): x = int(x) #此处使用 m - 5lgd = klgr + M 进行最小二乘拟合 y1.append(M + 5 * math.log10(d[x]) + k * math.log10(r[x])) y2.append(12 + 5 * math.log10(d[x]) + 10 * math.log10(r[x])) x = np.linspace(-60,61,120) plt.figure(figsize = [6,4],dpi=150) #设置图的大小 plt.xlabel(\u0026#39;days from perihelion\u0026#39;) plt.ylabel(\u0026#39;magnitude\u0026#39;) plt.title(\u0026#39;picutre\u0026#39;) plt.plot(x,y1,color=\u0026#34;blue\u0026#34;) plt.plot(x,y2,color=\u0026#34;red\u0026#34;) plt.ylim(max([max(y1),max(y2)])+1,min([min(y1),min(y2)])-1) #奇妙的做法，为了翻转y轴，想使用plt.gca().invert_yaxis()但不起作用，于是使用ylim反转上下限 plt.savefig(\u0026#34;figure.jpg\u0026#34;) #保存图片 plt.show() 目前状况（2020-03-17） 解决plt绘图重复的问题（前面分开，后面合并，连着直接绘制会出现问题）（可能是和figure()相关的问题） plt.grid() plt.legend()的配置 plt.subplot linewidth matplotlib的documentation:matplotlib\n重构了代码，更多地使用数组储存数据\n双曲线a为负数 Time(2439054.6837, format=\u0026lsquo;jd\u0026rsquo;,scale=\u0026lsquo;tdb\u0026rsquo;) #JD时间\npoliastro.twobody.propagation.propagate相关： 可以由orbit.propagate()调用，其中第一个参数为经过的时间，第二个参数为求解的方法（mean_motion,kepler,cowell），返回经过时间后的轨道\n下一步：研究python的封装（函数、库、class之类） 下一步：自写轨道库\nmatplotlib颜色映射（默认颜色） np.arange([start,],stop,[step])\n目前状况（2020-03-19） plt.xticks([array]) x轴的刻度标记（如[1,2,3,4,5]，则刻度显示出来的就是12345） xticks系列大概都是用来设置轴的刻度标记的吧 plt.xtickslabel([array]) 使用string设置x轴刻度\nplt.axis([xlim,-xlim,ylim,-ylim]) 相当于设置plt.xlim和plt.ylim\n","date":"2020-02-28T17:57:43+08:00","permalink":"https://mizarzh.github.io/p/2020/02/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97c-2019-y4-comet/","title":"工作日志(C 2019 Y4 comet)"},{"content":"推箱子 pushbox 过于羞耻.jpg\n\rprinciple\r\nHTML与CSS知识相关 这次使用的是外层创建div并限定长度、窗口居中（margin : auto），内部嵌套float:left的元素 应该有更高效的（absolute+计算坐标），但还没搞清楚盒式模型\njs文件过程 js的调用并不是一次性的，可以使用函数重复调用（文件只可以进行一次，但是函数可以进行多次）\n事件监听 事件的监听是并行的，前面定义了click，后面定义了keydown，并不会停留在监听的函数中。 （另外的问题：每个对象的监听是否只能有一个）\n全局变量 在window定义变量，再用window.xxx调用全局变量\n数组嵌套对象 concat(),slice(0)对一维数组有效 数组中如果嵌套了对象，那么concat()、slice(0))也会对数组中的东西产生影响，换句话说就是没有进行深复制。 这里应该深入对作用链的理解\n混乱不堪的代码  运动系统过于复杂 或许可以换种架构，不需要每次移动都更新全部的DOM 全局变量和局部变量纠缠不清   贪吃蛇 Greedy-Snake-js\n随机数 使用Math.random()生成[0-1)的一个数，配合Math.floor()食用更佳\n数组判断相等 数组的判断无法直接使用===号 如果是较简单的数组可以使用Array.toString()方法比较。 嵌套且长短不一的数组可能就需要单独比较了\n深复制 假设一个对象/数组a需要深复制，可使用JSON进行转化\ncopy = JSON.parse(JSON.stringify(a)); 方法 对于数组与对象的方法不熟悉（例如迭代等）\n全局变量 这次使用了对象包裹的方法定义全局变量，应该是稍微科学一点了 也使用了ES6的let及const，更好的控制变量范围\nthrow throw错误之后程序将停止运行\n","date":"2020-02-19T12:42:14+08:00","permalink":"https://mizarzh.github.io/p/2020/02/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-2-19/","title":"最近进展2020-2-19"},{"content":"13事件 js与HTML之间的交互是通过事件实现的 可以使用侦听器（或处理程序）来预订事件\n13.1事件流 13.1.1事件冒泡 即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）\n13.1.2事件捕获 事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。\n13.1.3DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n13.2事件处理程序 而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以\u0026quot;on\u0026quot;开头\n13.2.1HTML事件处理程序 属性onclick=\u0026ldquo;javascript代码\u0026rdquo;\n//前面定义了showMessage() \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;ClickMe\u0026#34; onclick=\u0026#34;showMessage()\u0026#34;/\u0026gt; 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。 这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象 在这个函数内部，this值等于事件的目标元素 在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。\n很多HTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面\n13.2.2DOM0级事件处理程序 每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。\nvarbtn=document.getElementById(\u0026#34;myBtn\u0026#34;); btn.onclick=function(){ alert(\u0026#34;Clicked\u0026#34;); }; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行 也可以删除通过DOM0级方法指定的事件处理程序，将onclick属性设为null即可。\n13.2.3DOM2级事件处理程序 addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法。 它们都接受3个参数：要处理的事件名（意味着没有on前缀）、作为事件处理程序的函数和一个布尔值。这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。\n大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。\n13.2.4IE事件处理程序 过时了吧emm\n13.2.5跨浏览器的事件处理程序 IE、DOM2、DOM0三种方法创建，创建为一个EventUtil的对象。\n13.3事件对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。\n13.3.1DOM中的事件对象 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。\nevent属性：见书355页 其中两个属性： currentTarget：其事件处理程序当前正在处理事件的那个元素 target：事件的目标 this始终等于currentTarget的值 要阻止特定事件的默认行为，可以使用preventDefault()方法。 只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为 stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。 事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则event-Phase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。 只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。\n13.3.2IE中的事件对象 过时了吧\n13.3.3跨浏览器的事件对象 13.4事件类型  UI（UserInterface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为IME（InputMethodEditor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层DOM结构发生变化时触发。  13.4.1UI事件 详细见书362 DOMActivate,(un)load,abort,error,select,resize,scroll 除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件\n13.4.2焦点事件 blur,focus,focusin,focusout\n13.4.3鼠标与滚轮事件 click,dblclick,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup\n鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。 通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，坐标是从页面本身而非视口的左边和顶边计算的。 在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。 screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。\nDOM规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。\n对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。 但对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠标按钮（鼠标滚轮按钮），2表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。\n“DOM2级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。\n当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件。 与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。 Firefox支持一个名为 DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。与 mousewheel 事件一样，DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在 detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是-3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是 3 的倍数\n触摸设备：\n 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生； 如果屏幕没有因此变化，那么会依次发生 mousedown、mouseup 和 click 事件。 轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。 mousemove 事件也会触发 mouseover 和 mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。  13.4.4 键盘与文本事件 keydown,keypress,keyup 前两者如果按住不放的话，会重复触发此事件。 只有一个文本事件：textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。\n在发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同。 表见P380\nIE9、Firefox、Chrome 和 Safari的 event 对象都支持一个 charCode 属性，这个属性只有在发生 keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的 ASCII 编码。此时的 keyCode 通常等于0或者也可能等于所按键的键码\nDOM3级变化：不再包含 charCode 属性，而是包含两个新属性：key 和 char。 key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时，key 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift” 或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。 不同浏览器有不同实现\nDOM3级事件还添加了一个名为 location 的属性，这是一个数值，表示按下了什么位置上的键： 0表示默认键盘，1表示左侧位置（例如左位的 Alt键），2表示右侧位置（例如右侧的 Shift键），3表示 数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂 Wii控制器）。\n后是给 event 对象添加了 getModifierState()方法。这个方法接收一个参数，即等于 Shift、Control、AltGraph 或 Meta 的字符串，表示要检测的修改键。\n“DOM3级事件”规范中引入了一个新事件，名叫 textInput。根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。 由于 textInput 事件主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符（而非字符编码）。 event 对象上还有一个属性，叫 inputMethod，表示把文本输入到文本框中的方式。 （值见P383）\n13.4.5 复合事件 复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。 compositionstart,compositionupdate,compositionend\n13.4.6 变动事件 DOM2级的变动（mutation）事件能在 DOM中的某一部分发生变化时给出提示。 DOMSubtreeModified,DOMNodeInserted,DOMNodeRemoved,DOMNodeInsertedIntoDocument,DOMNodeRemovedFromDocument,DOMAttrModified,DOMCharacterDataModified\n13.4.7 HTML5事件  contextmenu 事件：上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单 beforeunload 事件：是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件的意图是将离开页面的控制权交给用户。 DOMContentLoaded 事件：在形成完整的 DOM树之后就会触发，不理会图像、JavaScript 文件、CSS文件或其他资源是否已经下载完毕。 readystatechange 事件：这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。 pageshow 和 pagehide 事件：这个事件在页面显示时触发，无论该页面是否来自 bfcache（来自bfcache的页面不会有load事件）。 hashchange 事件：在 URL的参数列表（及 URL中“#”号后面的所有字符串）发生变化时通知开发人员。  13.4.8 设备事件  orientationchange 事件 MozOrientation 事件 deviceorientation 事件 devicemotion 事件  13.4.9 触摸与手势事件  触摸事件 手势事件  13.5 内存和性能 在 JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。\n13.5.1 事件委托 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。\nvar list = document.getElementById(\u0026#34;myLinks\u0026#34;); EventUtil.addHandler(list, \u0026#34;click\u0026#34;, function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id){ case \u0026#34;doSomething\u0026#34;: document.title = \u0026#34;I changed the document\u0026#39;s title\u0026#34;; break; case \u0026#34;goSomewhere\u0026#34;: location.href = \u0026#34;http://www.wrox.com\u0026#34;; break; case \u0026#34;sayHi\u0026#34;: alert(\u0026#34;hi\u0026#34;); break; } }); //而不是三个对象分别设置不同的方法 这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。 适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress\n13.5.2 移除事件处理程序 内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的主要原因。 直接移除元素（removeChild()) 好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。\n13.6 模拟事件 13.6.1 DOM中的事件模拟 document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。 在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3级中都变成了单数。\n UIEvents：一般化的 UI事件。鼠标事件和键盘事件都继承自 UI事件。DOM3级中是 UIEvent。 MouseEvents：一般化的鼠标事件。DOM3级中是 MouseEvent。 MutationEvents：一般化的 DOM变动事件。DOM3级中是 MutationEvent。 HTMLEvents：一般化的 HTML事件。没有对应的 DOM3级事件（HTML事件被分散到其他类别中）。  传入参数见书\n","date":"2020-02-12T18:28:18+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B013/","title":"js高设笔记13"},{"content":"10 DOM DOM（文档对象模型）是针对 HTML和 XML文档的一个 API\n10.1 节点层次 DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。 \u0026lt;html\u0026gt; 文档元素 文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。 在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。\n每一段标记都可以通过树中的一个节点来表示： HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。\n10.1.1 Node类型 DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现，JavaScript中的所有节点类型都继承自 Node 类型。 每个节点都有一个 nodeType 属性，用于表明节点的类型。 节点类型由在 Node 类型中定义的下列12个数值常量来表示 Node.ELEMENT_NODE(1)； Node.ATTRIBUTE_NODE(2)； Node.TEXT_NODE(3)； Node.CDATA_SECTION_NODE(4)； Node.ENTITY_REFERENCE_NODE(5)； Node.ENTITY_NODE(6)； Node.PROCESSING_INSTRUCTION_NODE(7)； Node.COMMENT_NODE(8)； Node.DOCUMENT_NODE(9)； Node.DOCUMENT_TYPE_NODE(10)； Node.DOCUMENT_FRAGMENT_NODE(11)； Node.NOTATION_NODE(12)。\nnodeName 和 nodeValue：对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。\n每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。 NodeList 是一种类数组对象（类似但不是Array），用于保存一组有序的节点，可以通过位置来访问这些节点。 访问NodeList可通过方括号，也可以使用 item()方法 转化为数组（或者手动循环）：\nvar arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。 包含在 childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中后一个节点的 nextSibling 属性的值同样也为 null。 父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和后一个节点。\nhasChildNodes()方法\n所有节点都有的后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。\nappendChild()，用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点及以前的后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild() 返回新增的节点。\ninsertBefore() 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作\nreplaceChild() 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。\nremoveChild() 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。\n并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。\ncloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制（复制节点及其整个子节点树，浅复制只复制节点本身）。副本没有指定父节点。\nnormalize()，这个方法唯一的作用就是处理文档树中的文本节点。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。\n10.1.2 Document类型 JavaScript通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。\n nodeType 的值为 9； nodeName 的值为\u0026quot;#document\u0026quot;； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null；其子节点可能是一个 DocumentType（多一个）、Element（多一个）、ProcessingInstruction 或 Comment。  documentElement 属性，该属性始终指向HTML页面中的元素。 document 对象还有一个 body 属性，直接指向元素。 Document 另一个可能的子节点是 DocumentType。通常将\u0026lt;!DOCTYPE\u0026gt;标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息。 不同浏览器支持情况不同 出现在元素外部的注释的引用不同浏览器的支持程度不同。\ndocument.title：通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变\u0026lt;title\u0026gt;元素 URL、domain 和 referrer。只有 domain 是可以设置的。但由于安全方面的限制，也并非可以给 domain 设置任何值。\ngetElementById()和getElementsByTagName()。 前者id不存在返回null，id特性（attribute）严格匹配，包括大小写。 后者返回的是包含零或多个元素的 NodeList。在 HTML文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。 HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name 特性取得集合中的项。（方括号访问亦可） 后者可传入*，代表全部\n虽然标准规定标签名需要区分大小写，但为了最大限度地与既有 HTML 页面兼容，传给 getElementsByTagName()的标签名是不需要区分大小写的。但对于 XML 页面而言（包括 XHTML），getElementsByTagName()方法就会区分大小写。\n只有 HTMLDocument 类型才有的方法，是 getElementsByName()。顾名思义，这个方法会返回带有给定 name 特性的所有元素。\n特殊集合：anchors(\u0026lt;a name=\u0026ldquo;xxx\u0026rdquo;\u0026gt;),forms(\u0026lt;form\u0026gt;),images(\u0026lt;img\u0026gt;),links(\u0026lt;a href=\u0026ldquo;xxx\u0026rdquo;\u0026gt;)\ndocument.implementation 属性为浏览器实现了DOM的哪些部分提供相应信息和功能的对象，其中的方法hasFeature()接受两个参数：要检测的 DOM功能的名称及版本号。若支持返回true。\nwrite()、writeln()、open()和 close()\ndocument.write(\u0026#34;\u0026lt;strong\u0026gt;\u0026#34; + (new Date()).toString() + \u0026#34;\u0026lt;/strong\u0026gt;\u0026#34;); //载入外部脚本 document.write(\u0026#34;\u0026lt;script type=\\\u0026#34;text/javascript\\\u0026#34; src=\\\u0026#34;file.js\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;\\/script\u0026gt;\u0026#34;); 如果在文档加载结束后再调用 document.write()，那么输出的内容将会重写整个页面\n10.1.3 Element类型  nodeType 的值为 1； nodeName 的值为元素的标签名； nodeValue 的值为 null； parentNode 可能是 Document 或 Element； 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。  要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性 在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。\nHTML元素\n id，元素在文档中的唯一标识符。 title，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang，元素内容的语言代码，很少使用。 dir，语言的方向，值为\u0026quot;ltr\u0026quot;（left-to-right，从左至右）或\u0026quot;rtl\u0026quot;（right-to-left，从右至左），也很少使用。 className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为 class 是 ECMAScript的保留字  所有 HTML元素都是由 HTMLElement 或者其更具体的子类型来表示的。 **getAttribute()、setAttribute()和 removeAttribute()**三个方法。 最前者的返回可能会有差异 1 返回的 style 特性值中包含的是 CSS文本，直接访问则是对象， 2 事件处理程序。当在元素上使用时，onclick 特性中包含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。 通常不使用getAttribute()\nsetAttribute() 通过这个方法设置的特性名会被统一转换为小写形式，即\u0026quot;ID\u0026quot;终会变成\u0026quot;id\u0026quot;\n根据 HTML5规范，自定义特性应该加上 data-前缀以便验证。\nElement 的attributes 属性中包含一个 NamedNodeMap，与 NodeList 类似，也是一个“动态”的集合。元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象拥有下列方法。\n getNamedItem(name)：返回 nodeName 属性等于 name 的节点； removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos)：返回位于数字 pos 位置处的节点。  attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称。节点的 nodeValue 就是特性的值。 removeNamedItem()返回表示被删除特性的 Attr 节点，removeAttribute()不返回 attributes属性一般用于遍历元素属性 返回属性的顺序不一定相同\n每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML中指定了相应特性，要么是通过 setAttribute()方法设置了该特性。\ndocument.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。返回一个 DOM元素的引用\n\u0026lt;ul id=\u0026#34;myList\u0026#34;\u0026gt; \u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt;  \u0026lt;li\u0026gt;Item 3\u0026lt;/li\u0026gt;  \u0026lt;/ul\u0026gt;  返回后会有7个元素，包括3个li元素和4个空白符（li之间） 可以通过nodeType的判断消除空白符\n10.1.4 Text类型  nodeType 的值为 3； nodeName 的值为\u0026quot;#text\u0026quot;； nodeValue 的值为节点所包含的文本； parentNode 是一个 Element； 不支持（没有）子节点。  操作文本的方法：\n appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 文本节点还有一个 length 属性，保存着节点中字符的数目。 每个可以包含内容的元素多只能有一个文本节点，而且必须确实有内容存在。  document.createTextNode()创建新文本节点\nnormalize() 浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行 DOM操作的结果出现。 splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。\n10.1.5 Comment类型  nodeType 的值为 8； nodeName 的值为\u0026quot;#comment\u0026quot;； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element； 不支持（没有）子节点。  其他有CDATASection类型，DocumentType类型 ，DocumentFragment类型 ，Attr类型\nDOM操作技术 （待续）\n","date":"2020-02-11T16:11:37+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B010/","title":"js高设笔记10"},{"content":"BOM BOM（浏览器对象模型）\n8.1 window 对象 BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。\n8.1.1 全局作用域 全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。\nvar age = 29; window.color = \u0026#34;red\u0026#34;; //在 IE \u0026lt; 9 时抛出错误，在其他所有浏览器中都返回 false delete window.age; //在 IE \u0026lt; 9 时抛出错误，在其他所有浏览器中都返回 true delete window.color; //returns true 使用 var 语句添加的 window 属性的[[Configurable]]特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除 通过查询 window 对象，可以知道某个可能未声明的变量是否存在。\n8.1.2 窗口关系及框架 页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。\nwindow.frames[0] window.frames[\u0026#34;name属性\u0026#34;] top.frames[0] top对象始终指向高（外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。 与 top 相对的另一个 window 对象是 parent。顾名思义，parent（父）对象始终指向当前框架的直接上层框架。\n除非高层窗口是通过 window.open()打开的（本章后面将会讨论），否则其 window 对象的 name 属性不会包含任何值。 self始终指向 window；实际上，self 和 window 对象可以互 换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来 这些对象都为window的属性，可通过window.xxx访问\n   对象名 指向     top 始终指向高（外）层的框架   parent 始终指向当前框架的直接上层框架   self 始终指向 window    在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生 类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。\n8.1.3 窗口位置 screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。 screenX 和 screenY 各浏览器间实现不同\n使用moveTo() 和 moveBy() 方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，moveTo()接收的是新位置的 x和 y坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数。 另外，这两个方法都不适用于框架，只能对外层的 window 对象使用。\n8.1.4 窗口大小 innerWidth、innerHeight、outerWidth 和 outerHeight outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从外层的 window 对象还是从某个框架访问） innerWidth 和innerHeight 则表示该容器中页面视图区的大小（减去边框宽度）。 不同浏览器代表不同。\ndocument.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息\n对于移动设备，window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。\n**resizeTo()和 resizeBy()**方法可以调整浏览器窗口的大小\n8.1.5 导航和打开窗口 window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。 \ropen参数\r 表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（如top=100，注意，整个特性字符串中不允许出现空格） 调用 close()方法还可以关闭新打开的窗口。 弹出窗口关闭之后，窗口的引用仍然还在，但仅能用类似alert的方法检测closed参数了\n新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。 虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口\n将 opener 属性设置为 null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。\n浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open()的调用封装在一个try-catch 块中\n8.1.6 间歇调用和超时调用 JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。 前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。 超时调用需要使用 window 对象的 **setTimeout()**方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。 第一个参数可以是一个包含 JavaScript代码的字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。（一般用匿名函数） 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个 参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 **clearTimeout()**方法并将相应的超时调用 ID作为参数传递给它。\n间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 setInterval() 取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。\nvar num = 0; var max = 10; //使用递归方法 function incrementNumber() { num++; //如果执行次数未达到 max 设定的值，则设置另一次超时调用  if (num \u0026lt; max) { setTimeout(incrementNumber, 500); } else { alert(\u0026#34;Done\u0026#34;); } } setTimeout(incrementNumber, 500); 一般认为，使用超时调用来模拟间歇调用的是一种佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，好不要使用间歇调用。\n8.1.7 系统对话框 alert()、confirm()和 prompt() 为了确定用户是单击了 OK还是 Cancel，可以检查 confirm()方法返回的布尔值：true 表示单击了 OK，false 表示单击了 Cancel或单击了右上角的 X按钮。\nprompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK和 Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。 prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。如果用户单击了OK按钮，则 prompt()返回文本输入域的值；如果用户单击了 Cancel或没有单击 OK而是通过其他方式关闭了对话框，则该方法返回 null。\nfind() 查找 和 print() 打印 方法\n8.2 location对象 location它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。是window对象的属性，也是document的属性。 属性 \rlocation属性\r\n8.2.1 查询字符串参数 location.search 返回从问号到 URL末尾的所有内容 可以新建函数获取?后面的参数\ndecodeURIComponent()解码URL\n8.2.2 位置操作 location 对象可以通过很多方式来改变浏览器的位置。使用assign()方法 改变window.location或者location.href会调用assgin()方法 每次修改 location 的属性（hash 除外），页面都会以新 URL重新加载。 要禁用生成记录行为，应使用replace()方法，不能回到前一个页面 reload()，作用是重新加载当前显示的页面。传入参数true，则强制从服务器重新加载数据，而不传入则可能从缓存中加载。\n8.3 navigator 对象 navigator对象 属性见书P200-201\n8.3.1 检测插件 plugins属性\n name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME类型数量。 因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。 plugins 集合有一个名叫 refresh()的方法，用于刷新 plugins 以反映最新安装的插件。  8.3.2 注册处理程序 registerContentHandler()和registerProtocolHandler() 这两个方法可以让一个站点指明它可以处理特定类型的信息。 前者接收参数：要处理的 MIME类型、可以处理该 MIME 类型的页面的 URL以及应用程序的名称。 后者接收参数：要处理的协议（例如，mailto 或 ftp）、处理该协议的页面的 URL和应用程序的名称。\nnavigator.registerContentHandler(\u0026#34;application/rss+xml\u0026#34;, \u0026#34;http://www.somereader.com?feed=%s\u0026#34;,\u0026#34;Some Reader\u0026#34;); //%s代表RSS源URL 8.4 screen 对象 用处不大 用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 书中P214\n8.5 history 对象 go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置近。如果历史记录中不包含该字符串，那么这个方法什么也不做 还可以使用两个简写方法 back()和 forward()来代替 go()。 history 对象有一个 length 属性，保存着历史记录的数量。\n","date":"2020-02-10T13:24:43+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B08/","title":"js高设笔记8"},{"content":"7 函数表达式 7.1 递归 使用argument.callee 严格模式下，可使用命名函数表达式来达成相同的结果\nvar factorial = (function f(num){ if (num \u0026lt;= 1){ return 1; } else { return num * f(num-1); } }); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。\n7.2 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。\nfunction createComparisonFunction(propertyName) { return function(object1, object2){ var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 \u0026lt; value2){ return -1; } else if (value1 \u0026gt; value2){ return 1; } else { return 0; } }; } 在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。\n","date":"2020-02-10T12:17:39+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B07/","title":"js高设笔记7"},{"content":"6 面向对象的程序设计 （注意：js中的面向对象实现与C++中不同）\n6.1 理解对象 var person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; person.job = \u0026#34;Software Engineer\u0026#34;; person.sayName = function(){ alert(this.name); }; var person = { name: \u0026#34;Nicholas\u0026#34;, age: 29, job: \u0026#34;Software Engineer\u0026#34;, sayName: function(){ alert(this.name); } }; 6.1.1 属性类型 数据属性 ECMA-262第 5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。 实现 JavaScript引擎用的，因此在 JavaScript中不能直接访问它们。 为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。\n [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。  要修改属性默认的特性，必须使用 ECMAScript 5的Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。\nvar person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { writable: false, value: \u0026#34;Nicholas\u0026#34; }); 这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。\n把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。\n访问器属性 访问器属性不包含数据值；它们包含一对 getter和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter函数并传入新值，这个函数负责决定如何处理数据。\n [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。  var book = { _year: 2004, edition: 1 }; Object.defineProperty(book, \u0026#34;year\u0026#34;, { get: function(){ return this._year; }, set: function(newValue){ if (newValue \u0026gt; 2004) { this._year = newValue; this.edition += newValue - 2004; } } }); book.year = 2005; alert(book.edition); //2 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。 只指定 getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。\n6.1.2 多个属性 var book = {}; Object.defineProperties(book, { _year: { value: 2004 }, edition: { value: 1 }, year: { get: function(){ return this._year; }, set: function(newValue){ if (newValue \u0026gt; 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); 6.1.3 读取属性的特性 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述 符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。\nvar descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;_year\u0026#34;); alert(descriptor.value); //2004 alert(descriptor.configurable); //false alert(typeof descriptor.get); //\u0026#34;undefined\u0026#34;  var descriptor = Object.getOwnPropertyDescriptor(book, \u0026#34;year\u0026#34;); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\u0026#34;function\u0026#34; 6.2 创建对象 6.2.1 工厂模式 function createPerson(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var person1 = createPerson(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); var person2 = createPerson(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); 6.2.2 构造函数模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ alert(this.name); }; } var person1 = new Person(\u0026#34;Nicholas\u0026#34;, 29, \u0026#34;Software Engineer\u0026#34;); var person2 = new Person(\u0026#34;Greg\u0026#34;, 27, \u0026#34;Doctor\u0026#34;); 构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 使用了函数就是对象的想法，将属性添加到this上。\n两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。\n若Person不使用new，则认为是在为window添加属性 可使用call将作用域限定为某个对象\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。不同实例上的同名函数是不相等的。\n6.2.3 原型模式 解决构造函数的方法不相等问题。 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。\nfunction Person(){} Person.prototype.name = \u0026#34;Nicholas\u0026#34;; Person.prototype.age = 29; Person.prototype.job = \u0026#34;Software Engineer\u0026#34;; Person.prototype.sayName = function(){ alert(this.name); }; 在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。\n原型对象的理解：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。\n\rprototype1\r Person 的每个实例—— person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与构造函数没有直接的关系。 所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。 ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。\n每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。\n使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。\nin操作符 单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。\n\u0026#34;name\u0026#34; in person1; ECMAScript 5也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。 要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5的 Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。\n更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象:\nfunction Person(){ } Person.prototype = { name : \u0026#34;Nicholas\u0026#34;, age : 29, job: \u0026#34;Software Engineer\u0026#34;, sayName : function () { alert(this.name); } }; 有一个例外：constructor 属性不再指向 Person 了，指向Object 如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可用defineproperty重设回来。\nconstructor : Person, 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。 如果是重写整个原型对象，实例中的指针仅指向原来的原型，而不指向构造函数。 调用构造函数时会为实例添加一个指向初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与初原型之间的联系。 总结：先定义原型再创建实例，不然实例指向的是原prototype \rprototype2\r\n问题 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 共享，有时候需要分离的属性 因此不经常单独使用\n6.2.4 组合使用构造函数模式和原型模式 function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [\u0026#34;Shelby\u0026#34;, \u0026#34;Court\u0026#34;]; } Person.prototype = { constructor : Person, sayName : function(){ alert(this.name); } } 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，大限度地节省了内存。\n是目前在 ECMAScript中使用广泛、认同度高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。\n6.2.5 动态原型模式(理解？) 它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。\nfunction Person(name, age, job){ //属性  this.name = name; this.age = age; this.job = job; //方法  if (typeof this.sayName != \u0026#34;function\u0026#34;){ Person.prototype.sayName = function(){ alert(this.name); }; } } 6.2.6 寄生构造函数模式 寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。\nfunction Person(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } 除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。\n首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。 我们建议在可以使用其他模式的情况下，不要使用这种模式。\n6.2.7 稳妥构造函数模式 稳妥对象（durable objects）。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。\nfunction Person(name, age, job){ //创建要返回的对象  var o = new Object(); //可以在这里定义私有变量和函数  //添加方法  o.sayName = function(){ alert(name); }; //返回对象  return o; } 除了使用 sayName()方法之外，没有其他办法访问 name 的值。\n6.3 继承 继承分为接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript使用实现继承。 通过原型链实现\n6.3.1 原型链 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\nfunction SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function (){ return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); //true \rprototype_chain\r\ninstance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，后一步才会找到该方法。\n最上层的原型链继承自Object，因此也可以使用Object的方法。\n使用instanceof/isPrototypeof()对原型链上的对象进行比较都会返回true\n子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。\n即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链\n问题 1 SubType 的所有实例都会共享属性。 2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n6.3.2 借用构造函数 在子类型构造函数的内部调用超类型构造函数。通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数\nfunction SuperType(){ this.colors = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]; } function SubType(){ //继承了 SuperType  SuperType.call(this); } 两者没有关系 如果SuperType可以传递参数，则使用call()方法也可传递参数 问题：方法都在构造函数中定义，无法复用函数。\n6.3.3 组合继承 组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。\n过程：先定义supertype的属性，再定义subtype的私有属性，再定义原型链。 js中最常用的继承模式\n6.3.4 原型式继承 function object(o){ function F(){} F.prototype = o; return new F(); } 进行浅复制，复制后仍指向原来的对象（共享属性）\nECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。\n6.3.5 寄生式继承 function createAnother(original){ var clone = object(original); //通过调用函数创建一个新对象  clone.sayHi = function(){ //以某种方式来增强这个对象  alert(\u0026#34;hi\u0026#34;); }; return clone; //返回这个对象 } 6.3.6 寄生组合式继承 组合继承大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。\n寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。| 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。\nfunction inheritPrototype(subType, superType){ var prototype = object(superType.prototype); //创建对象  prototype.constructor = subType; //增强对象  subType.prototype = prototype; //指定对象 } 在定义完supertype和subtype之后调用此函数，则完成了继承。\n总结 [[xxx]]当作是属性的属性，则可理解defineProperty和defineProperties的写法，以及getOwnPropertyDescripter指向的东西 模式： [[Prototype]]实例所有，指向该实例的构造函数的原型对象 prototype为构造函数所有，指向该构造函数的原型对象 constructor实例所有，指向构造函数\n 工厂模式 createPerson() + return 构造函数模式 Person() + new 原型模式 Person()的对象名prototype含有的属性Person.prototype.xxx 上面两个组合 动态原型 寄生构造函数、稳妥构造函数  继承：\n 原型链。subType的prototype指向superType的实例，则逻辑：subType为superType的一个实例 -\u0026gt; subType拥有[[Prototype]]属性，且指向构造函数superType的原型对象superType.prototype -\u0026gt; 原型链构造完成，可以寻找到superType.prototype的属性 借用构造函数：在subType内使用call()或apply()构建superType属性的深复制。 上面两者组合 原型式继承 寄生式继承 寄生组合式继承  ","date":"2020-02-07T18:14:42+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/","title":"js高设笔记6"},{"content":"5 引用类型 引用类型是一种结构。\n5.1 Object类型 创造实例的两种方法： 1、new+构造函数 2、对象字面量\nvar person = new Object(); person.name = \u0026#34;Nicholas\u0026#34;; person.age = 29; var person = { name : \u0026#34;Nicholas\u0026#34;, age : 29 }; var person = {}; //相当于new Object() 属性名可以使用字符串（包括字符串数字）。 使用对象字面量定义对象不会调用Object()构造函数\n访问方法：person[\u0026ldquo;name\u0026rdquo;]或person.name 除非必须通过方括号法表示，否则用点表示法\n5.2 Array 每一项可保存不同的数据类型\n//构造函数法 var colors = new Array(); var colors = new Array(20);// len=20 var colors = new Array(\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;); //字面量法 var colors = []; var colors = [\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;]; length属性 设定length，短了切除，长了用undefined填充。在超远的距离填充（如colors[99] = \u0026ldquo;xx\u0026rdquo;，那么2-98都为undefined。 套路：\ncolors[colors.length] = \u0026#34;xx\u0026#34;;//在最后一项添加 5.2.1 检测数组 instanceof（假定只有一个全局环境） **Array.isArray()**方法（不管有多少个环境）\n5.2.2 转换方法 toLocaleString(),toString(),valueOf() 调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf()返回的还是数组。\nvar person = { toLocaleString : function{ ... } toStirng : function{ ... } };//这样改变方法 **join()**方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串（不传入值或undefined就用逗号）。\n5.2.3 栈方法 LIFO:push() pop() push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 而pop()方法则从数组末尾移除后一项，减少数组的 length 值，然后返回移除的项。\n5.2.4 队列方法 FIFO:shift()和push():能够移除数组中的第一个项并返回该项，同时将数组长度减 1 unshift():在数组前端添加任意个项并返回新数组的长度。\n5.2.5 重排序方法 reverse() sort() 方法按升序排列数组项。 sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。 传入比较function判断排序。 如：\nfunction compare(value1, value2) { if (value1 \u0026lt; value2) { return -1; } else if (value1 \u0026gt; value2) { return 1; } else { return 0; } } values.sort(compare); 5.2.6 操作方法 concat() 方法可以基于当前数组中的所有项创建一个新数组。 这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，后返回新构建的数组。\nslice() 能够基于当前数组中的一或多个项创建一个新数组。 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。注意，slice()方法不会影响原始数组。 （可为负数）\nsplice()  删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。  插入：可以向指定位置插入任意数量的项，只需提供 3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。  替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）\n总结：splice(start,length,insert_values\u0026hellip;)\n5.2.7 位置方法 indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。 比较使用===\n5.2.8 迭代方法  every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。  filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。  forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。  map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。  some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。\n5.2.9 归并方法 reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个终返回的值。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。\n5.3 Date类型 var d = new Date();//括号中填入毫秒数 表示自 UTC（Coordinated Universal Time，国际协调时间）1970年 1月 1日午夜（零时）开始经过的毫秒数来保存日期。 parse():不固定具体格式，转化为该日期的毫秒数 UTC()：按照年、月、日、时、分、秒、毫秒顺序填入。其中月和时从0开始，转化为该日期的毫秒数。 toString()/toLocaleString()：转化为日期表示。 （目测toLocaleString()会考虑到时区的问题） now()：返回现在时间的毫秒数\n如同模仿 Date.parse()一样，Date 构造函数也会模仿 Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。\nDate 构造函数接收的参数仍然与 Date.UTC()相同。\nvalueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。 格式方法与组件方法见书P101-102\n5.4 RegExp类型 见另外的文档 RegExp\n5.5 Function类型 函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\nfunction sum (num1, num2) { return num1 + num2; } var sum = function(sum1, sum2){ return num1 + num2; }; var sum = new Function(\u0026#34;sum1\u0026#34;,\u0026#34;sum2\u0026#34;,\u0026#34;return num1 + num2\u0026#34;)//不推荐 不推荐的那种会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。\n5.5.1 没有重载 函数名为指针，如果定义了另外一个函数则会指向另外一个函数。\n5.5.2 函数声明与函数表达式 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。\n5.5.3 作为值的函数 因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。 函数的return可返回一个函数\n5.5.4 函数内部属性 arguments和this。 arguments的callee属性：该属性是一个指针，指向拥有这个 arguments 对象的函数。 如：\nfunction factorial(num){ if (num \u0026lt;=1) { return 1; } else { return num * arguments.callee(num-1) //不是factorial，消除了与这个名字的耦合  } } var trueFactorial = factorial; //可正常调用，factorial则不行 this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window）\nECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。\nECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。\n5.5.5 函数属性和方法 每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数\n在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。\napply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。\ncall() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。\n它们真正强大的地方是能够扩充函数 赖以运行的作用域。\nwindow.color = \u0026#34;red\u0026#34;; var o = { color: \u0026#34;blue\u0026#34; }; function sayColor(){ alert(this.color); } sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值。\n(待续)\n","date":"2020-02-07T18:13:27+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B05/","title":"js高设笔记5"},{"content":"正则表达式的表示方法 来自：regexlab\n1、直接写内容 直接匹配内容\n2、转义字符 1    字符 含义     \\n \\r 换行符   \\t 制表符   \\\\ \\的字符   \\$ $的字符   \\^ ^的字符   \\. .的字符    2    字符 含义     \\d 任意数字   \\w 任意数字、字母及下划线_   \\s 空白或制表符或换页符   . 任意字符（除换行符）    3、方括号 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。 如：[abc] (a,b,c中任意一个)、[^ f-k] (不是f-k的任意一个字母)、[A-F0-9] (A-F和0-9中任意一个)\n4、数量匹配 {n}重复n次 {m,n}重复至少m次至多n次 {m,}至少重复m次 ? 相当于 {0,1} + 相当于 {1,} * 相当于 {0,}\n5、位置匹配？ ^ 与字符串开始的地方匹配，不匹配任何字符（若匹配到的字符不是开始则错误） $ 与字符串结束的地方匹配，不匹配任何字符 \\b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符\n6、其他 | 左右两边表达式之间 \u0026ldquo;或\u0026rdquo; 关系，匹配左边或者右边 ( ) (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到\n7、高级技巧 贪婪与非贪婪 默认是贪婪（匹配得越多越好） 在数量符号后面加上?（如w+?）则为非贪婪模式，匹配越少越好\n引用 \\1、\\2等符号获取在( )中匹配的字符\n预搜索，不匹配；反向预搜索，不匹配 (?=xxxx)\n8、其他 \\xXX \\uXXXX 表示字符（编码相关？） \\S \\D \\W \\B 代表相反意义（非数字等）\n注意事项  表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。 需注意贪婪与非贪婪模式 或 \u0026ldquo;|\u0026rdquo; 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 \u0026ldquo;|\u0026rdquo; 两边的表达式因为交换位置而有所不同。  js里面的正则表达式形式： var exp = / pattern / flags;//字面量类型 var exp2 = new RegExp(\u0026#34;[bc]at\u0026#34;, \u0026#34;i\u0026#34;); //构造函数 模式（pattern）为表达式。 flags: g表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写 m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。 传入构造函数的字符串需双重转义 如匹配\\：\n   字符串 字面量 匹配     \\\\\\\\|\\\\|\\     （嗯其实这里打的markdown已经是四重转义了）      实例的属性  global：布尔值，表示是否设置了 g 标志。 ignoreCase：布尔值，表示是否设置了 i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。 multiline：布尔值，表示是否设置了 m 标志。 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。  实例的方法 exec()：接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。\n返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。\n在数组中，第一项是与整个模式匹配 的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。\n对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，常与for函数一起使用用于找出所有匹配项。\ntest():它接受一个字符串参数。在模式与该参数匹配的情况下返回 true；否则，返回 false。\ntoLocaleString()和toString() 方法都会返回正则表达式的字面量。 valueOf()方法返回正则表达式本身。\nRegExp构造函数属性 原理（NFA） ","date":"2020-02-05T00:57:40+08:00","permalink":"https://mizarzh.github.io/p/2020/02/regexp%E7%9B%B8%E5%85%B3/","title":"Regexp相关"},{"content":"JSON组成 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。\n例子： \u0026ldquo;Hello world!\u0026rdquo; 简单值 {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;Nicholas\u0026rdquo;,\u0026ldquo;age\u0026rdquo;: 29} 对象 [25, \u0026ldquo;hi\u0026rdquo;, true] 数组\njs中解析与序列化 var book = { //JSON表达式 } var jsontext = JSON.stringify(book); var bookC = JSON.parse(book); JSON 对象的两个方法：stringify()和 parse() 将 JSON字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript对象（或数组、值）。\n过滤结果 stringify(book,[year,edition]); JSON.stringify(book, function(key, value){ switch(key){ //判定是哪个属性，不要就返回undifined  } } 第三个参数用于控制结果中的缩进和空白符 如果是一个数值，则为缩进数 如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON字符串中被用作缩进字符\n如果某些对象无法使用JSON对象转化，可以自己定义该对象的toJSON()方法\n序列化顺序： (1) 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。 (2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。 (3) 对第(2)步返回的每个值进行相应的序列化。 (4) 如果提供了第三个参数，执行相应的格式化。\nJSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。这个函数被称为还原函数（reviver）\n","date":"2020-02-05T00:56:57+08:00","permalink":"https://mizarzh.github.io/p/2020/02/json%E7%9B%B8%E5%85%B3/","title":"JSON相关"},{"content":"第四章 4.1  基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。\n 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。 引用类型值（Object？）\njs不允许直接访问内存\n4.1.1 属性 对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。 不能给基本类型值添加属性。\n4.1.2 复制 基本类型值\u0026quot;=\u0026ldquo;将进行值的复制，两个值之间不相关 而引用类型值的\u0026rdquo;=\u0026ldquo;将指向同一个对象\n4.1.3 传递参数  ECMAScript 中所有函数的参数都是按值传递的。 把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。 在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 可以把 ECMAScript函数的参数想象成局部变量。\n my comprehension:不管什么值进入函数都会复制一遍，并在函数内部赋值到一个临时变量上。 基本类型值基本没问题，但引用类型值的引用也被复制了，当在内部改变临时变量的属性时，随着引用外部的对象也会随着改变。\n4.1.4 检测类型 typeof方法和instanceof方法\n4.2 执行环境及作用域  执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局变量与每个函数的执行环境 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。\n 4.2.1 延长作用域链 try-catch语句的catch块： with语句：不解释\n4.2.2 没有块级作用域  变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完add()之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。\n  当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。\n 4.3 垃圾收集 自动垃圾手机机制\n4.3.1 标记清除 变量进入环境时，将变量标记为“进入环境”。离开时标记为“离开环境”。\n4.3.2 引用清除 用得不多。跟踪记录每个值使用的次数。 问题：循环引用。 需手动切断链接。（设置引用为null）\n4.3.3 性能问题 注意性能相关问题。\n4.3.4 管理内存 不需要时手动解除引用。\n","date":"2020-02-05T00:35:24+08:00","permalink":"https://mizarzh.github.io/p/2020/02/js%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%E7%AC%AC%E5%9B%9B%E7%AB%A0/","title":"js高级设计笔记（第四章）"},{"content":" NexT文档   https://theme-next.org/docs/ http://theme-next.iissnan.com/ 网上搜索很方便（hexo文档和blog很多）\n mc相关：   中文论坛 https://www.mcbbs.net/ mod https://www.mcmod.cn/class/category/1-1.html cusreforge https://curseforge.com HMCL https://hmcl.huangyuhui.net gamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wiki gamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki\n   ","date":"2020-01-30T13:20:56+08:00","permalink":"https://mizarzh.github.io/p/2020/01/%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/","title":"有用的网址"},{"content":"1.mc版本 mc（pc端）分为java版与基岩版（C++编写） java版可自行下载，基岩版必须购买\njava版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接）\n以下讨论只针对java版\n2.配置方法 启动游戏需配置三样东西：java环境，游戏本体，启动器\n 游戏运行于java环境，因此首先需下载JDK（java development kit）并安装 目前许多启动器可以直接下载游戏本体，因此不需要再专门下载游戏本体。游戏本体位于.minecraft文件夹内 启动器用于启动游戏，常见的有HMCL等  3、mod相关 安装mod需要下载forge（然鹅官网好像访问很慢） 安装后会出现mods文件夹，直接将mod的jar包拖入其中即可\n4、自建服务器 以ubuntu为例 首先需下载server.jar mc_server ubuntu需要使用wget获得服务器 再安装jdk：\nsudo apt install openjdk-11-jre-headless 安装完成后再在bash输入：\nsudo java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui 就可生成文件 使用文本编辑器在生成的eula.txt文件中修改为true，在server.properties文件中修改online-mode=false 制作启动脚本：\n#!/bin/sh  java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui; ","date":"2020-01-30T11:50:14+08:00","permalink":"https://mizarzh.github.io/p/2020/01/mc%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/","title":"mc相关配置解释"},{"content":"hexo相关 1. vscode使用markdown相关 preview：右上角点击preview即可 可装插件Markdown Preview Enhanced使得preview更好看\n2、hexo标签问题 设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法：\nhexo n page tags #或categories等 然后在source/tags目录中配置index.md\n--- title: 标签 date: type: \u0026#34;tags\u0026#34; //或者\u0026#34;categories\u0026#34; --- 然后hexo g即可\n3、hexo目录乱序 需要按顺序一级一级使用# 如##后应该跟###而不是####\n4、hexo插入图片 摸索出来的新方法：\n 手动在_post文件夹建立与md相同名字的文件夹（不含.md)，往里面放入图片 直接使用![](xxx/文件名)  后面这种网上常见方法在我这里不适用/会出bug 例如我使用了之后就会使得地址处多了一个/.io/，无法连接到正确图片上\n _config.yml里面的post_asset_folder设为true 安装插件  cnpm install hexo-asset-image --save 安装完成后后hexo n \u0026ldquo;xxx\u0026quot;就会生成xxx.md的同时生成一个同名文件夹，图片放在里面即可。 调用图片的命令为![](xxx/文件名)  5、hexo启用公式 使用kramed渲染\ncnpm install hexo-renderer-kramed --save 在_config.yml中将mathjax enable，并在每篇文章的head中添加mathjax: true 有时候遇到pandoc exited with code null的问题，可以直接将pandoc整个卸载：\nnpm remove hexo-renderer-pandoc --save git相关 1、git速度过慢 需设置hosts文件，隔一段时间需重新设置\n浏览器配置 使用firefox\n标签设置 about:config 收藏栏打开使用新标签 browser.tabs.loadBookmarksInTabs设为true 新标签在当前标签右侧打开 browser.tabs.insertAfterCurrent设为true\n拓展安装 tabliss： 主要看重其中的TODO（懒= =） Simple Tab Groups：\nTab Center Redux:\n使用的拓展 Dark Reader:\nIDM:\nuBlock Origin:\nVideo DownloadHelper:\nTo Google Translate:\n打开被禁用端口 config:about network.security.ports.banned.override添加字符串 xxxx,xxxx,xxxx格式\nssh传文件 本地-\u0026gt;远程\nscp local_file remote_username@remote_ip:remote_folder 远程-\u0026gt;本地\nscp remote_username@remote_ip:remote_folder local_folder ffmpeg 叠加图片 ./ffmpeg -r 一秒帧数 -start_number 起始数字 -i img_%04d.jpg（4位整数） output.mp4 剪片 -ss 00:00:00.000 开始时间 -t 00:00:10.000 持续时间 -to 00:00:10.000 结束时间\n旋转 顺时针旋转画面90度ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=1\u0026rdquo; out.mp4 逆时针旋转画面90度ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=2\u0026rdquo; out.mp4 顺时针旋转画面90度再水平翻转ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=3\u0026rdquo; out.mp4 逆时针旋转画面90度水平翻转ffmpeg -i test.mp4 -vf \u0026ldquo;transpose=0\u0026rdquo; out.mp4 水平翻转视频画面ffmpeg -i test.mp4 -vf hflip out.mp4 垂直翻转视频画面ffmpeg -i test.mp4 -vf vflip out.mp4\n","date":"2020-01-28T11:38:56+08:00","permalink":"https://mizarzh.github.io/p/2020/01/%E6%9D%82%E9%A1%B9%E9%97%AE%E9%A2%98/","title":"杂项问题"},{"content":"0、准备：  node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： git config --global user.name \u0026#34;Firstname Lastname\u0026#34; git config --global user.email \u0026#34;your-email@youremail.com\u0026#34;  github新建repository的地址需命名为your-github-name.github.io  1、使用cnpm npm命令在国内较慢，需要安装cnpm(淘宝镜像)\nnpm install -g cnpm --registry=https://registry.npm.taobao.org 2、安装hexo cnpm install -g hexo-cli 3、新建文件夹 新建一个文件夹，里面将存储blog所需文件\nmkdir my_blog cd my_blog 4、初始化hexo hexo init 5、安装hexo部署至github的工具 cnpm install --save hexo-deployer-git （若出现ERROR Deployer not found: git错误，则是这个工具未安装）\n6、其他配置 其中文件_config.yml是配置文件 部署到github上需要配置deploy部分\ntype: \u0026#39;git\u0026#39; 添加两行：\nrepo: _path-to-github-blog_ branch: master 可在theme中更换主题\n本地临时服务器： hexo s s 代表 start 默认地址为localhost:4000\n新建文档： hexo n \u0026#34;name\u0026#34; n 代表 new 文档存放在/source/_post/中\n生成文档： hexo g g 代表 generate 部署文档到github上：\nhexo d d 代表 deploy 第一次配置可能需要输入github的账号密码 若是git bash内提示账号相关的错误，返回第零步进行账号的配置\n","date":"2020-01-27T22:46:41+08:00","permalink":"https://mizarzh.github.io/p/2020/01/hexo-win10%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8github%E4%BD%9C%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/","title":"hexo win10配置方法，并使用github作为博客地址"}]