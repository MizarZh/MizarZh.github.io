{"meta":{"title":"MizarZh's blog","subtitle":"","description":"","author":"MizarZh","url":"https://mizarzh.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-08T06:03:53.939Z","updated":"2020-02-08T06:03:53.939Z","comments":true,"path":"categories/index.html","permalink":"https://mizarzh.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-08T06:03:55.127Z","updated":"2020-02-08T06:03:55.127Z","comments":true,"path":"tags/index.html","permalink":"https://mizarzh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"名著短评","slug":"名著赏析","date":"2020-03-16T15:12:57.000Z","updated":"2020-03-17T09:40:11.798Z","comments":true,"path":"2020/03/16/名著赏析/","link":"","permalink":"https://mizarzh.github.io/2020/03/16/%E5%90%8D%E8%91%97%E8%B5%8F%E6%9E%90/","excerpt":"一个文学渣的瞎唠嗑","text":"一个文学渣的瞎唠嗑 《雪国》[日]川端康成创作于1935-1948年自己的想法：这的确是一本非常晦涩难懂的书。驹子对岛村的感情表达地十分晦涩（当然在岛村每次到雪国时感情都会深入，但书中没有明说），而岛村对她的感想则是全书的核心：“徒劳”。岛村认为驹子的生活是徒劳的，也能在书中读出来驹子平日生活（忍不住打扫）、待人（为了行男和养家而做艺妓）的辛苦。结尾最后很短的篇幅爆发，虽然结尾很难读懂就是了……参考资料后：岛村追求的是一种虚幻的美丽（虚无主义）。他热衷于写舞蹈的文章，却不去追求真正的舞蹈；他对叶子映在车窗上的倒影入迷，却对驹子注重现实生活而感到徒劳。他觉得现实生活中的一切东西都是“徒劳”的，去做也没有什么用。叶子暗喻了驹子的精神。叶子对驹子的责怪就是驹子对自己的责怪；叶子对驹子的嫉妒就是驹子对自己的嫉妒；叶子对岛村的爱慕就是驹子对岛村的爱慕。而最后叶子在火灾中死去，驹子失去了精神，便是结尾处的“疯掉了”。展现了作者的一些看法：死的唯美意境，虚无与悲观。","categories":[{"name":"文学","slug":"文学","permalink":"https://mizarzh.github.io/categories/%E6%96%87%E5%AD%A6/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://mizarzh.github.io/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"工作日志(C 2019 Y4 comet)","slug":"工作日志1","date":"2020-02-28T09:57:43.000Z","updated":"2020-03-17T09:49:57.441Z","comments":true,"path":"2020/02/28/工作日志1/","link":"","permalink":"https://mizarzh.github.io/2020/02/28/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%971/","excerpt":"思路：模型：$$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$ 其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离","text":"思路：模型：$$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$ 其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离 轨道计算：先计算出椭圆轨道的参数，再映射到实际轨道当中 数据Orbital elements: C/2019 Y4 (ATLAS)Epoch 2020 May 31.0 TT = JDT 2459000.5T 2020 May 30.99149 TT Bellq 0.2522871 (2000.0) P Qz +0.0052736 Peri. 177.54315 +0.48067371 +0.62763038 +/-0.0005749 Node 120.47328 -0.81617007 +0.57558163e 0.9986695 Incl. 45.27974 -0.32065433 -0.52420025From 171 observations 2019 Dec. 28-2020 Jan. 9, mean residual 0”.4. e (eccentricity) : 0.9991890q (perihelion distance) : 0.2529910i (inclination) : 45.39050Ω (Longitude of ascending node) : 120.57800ω (Argument of perihelion) : 177.39850L (Longitude of perihelion) : 118.75041B (Latitude of perihelion) : 1.85172T (Time of perihelion passage) : 2459000.54440P (Orbital period in years) : 5509.68Epoch : 2020 Feb 27Family/Group: : Nearly isotropic 02 January 2020 00:00 UTC Element Symbol Value Orbit eccentricity e 0.99871621 Orbit inclination i 45.31898912&deg; Perihelion distance q 0.25306404 AU37,857,841 km Aphelion distance Q 393.99356831 AU58,940,599,007 km Semi-major axis a 197.12331617 AU29,489,228,424 km Orbital period period 2,767.6800 years1,010,893.5413 days Date of perihelion transit Tp 2020-May-31 02:27:302,459,000.6024 JD Argument of perihelion peri 177.46987924671&deg; Longitude of the ascending node node 120.51143626815&deg; Mean anomaly M 359.94690155178&deg; Mean motion n 0.00035612&deg;/day 轨道根数：– semimajor axis a,– eccentricity e,– inclination i (or ι),– longitude of the ascending node Ω,– argument of the perihelion ω,– time of the perihelion τ.(或者true anomaly或者mean anomaly) 作图三维图：mplot3d 1234567891011from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as npax1 = plt.axes(projection=\"3d\")ax1.set_xlim3d(-lim,lim)ax1.set_ylim3d(-lim,lim)ax1.set_zlim3d(-lim,lim)ax1.plot3D(x,y,z)plt.show() 在jupyter notebook上： 123%matplotlib notebookax1.mouse_init() #使用鼠标操控ax1.view_init(elev=number, azim=number) #调整视角 交互式plotly 天文相关poliastro问题：使用Orbit.from_classical时的ecc过大，导致数据精度不足（或者是使得运行时间过长），但是使用直接绘图就没有这个问题poliastro astropy 1234from astropy import units as ufrom astropy.coordinates import CartesianRepresentationu.deg u.one u.km u.AU #单位CartesianRepresentation.x.value #带单位转化为值 astropy 目前状况（2020-03-16）爆肝到两点emm之前某个时间也强行写了很久 结构：轨道运算、画图、Mk计算轨道运算：poliastro库导入轨道后再导出数据使用近日点的true anomaly和mean anomaly都为0的方法规避这个库只能输入true anomaly的缺点（使用t代替，然后再使用propagation()确定相应的时间） 1234567891011121314151617181920212223242526272829time2 = \"2020-05-31T00:51:39\"t2 = Time(time2, format='isot', scale='tdb')se = Orbit.from_body_ephem(Earth,t2)sc = Orbit.from_classical(Sun,a,ecc,inc,raan,argp,0 * u.deg,t2)setemp = Orbit.from_classical(Sun,se.a,se.ecc,se.inc,se.raan,se.argp,se.nu,t2) #鬼知道我遇到了什么，必须再导入时间才能正常orbnc = [[],[],[]] #comet[[xs],[ys],[zs]]orbne = [[],[],[]] #earthfor x in np.linspace(-60 * u.day,60 * u.day,120): #-60 - 60 天 orbnctemp = sc.propagate(x) #x为astropy.unit的时间，用来计算经过某段时间后的轨道 pn1 = orbnctemp.represent_as(CartesianRepresentation) #表示为xyz轴 orbnc[0].append(pn1.x.value) orbnc[1].append(-pn1.y.value) orbnc[2].append(-pn1.z.value) xc = pn1.x.value / (1.5 * 10**8) #转化为AU yc = pn1.y.value / (1.5 * 10**8) zc = pn1.z.value / (1.5 * 10**8) orbnetemp = setemp.propagate(x) pn2 = orbnetemp.represent_as(CartesianRepresentation) orbne[0].append(pn2.x.value) orbne[1].append(-pn2.y.value) orbne[2].append(-pn2.z.value) xe = pn2.x.value / (1.5 * 10**8) ye = pn2.y.value / (1.5 * 10**8) ze = pn2.z.value / (1.5 * 10**8) r.append(math.sqrt(xc**2+yc**2+zc**2)) d.append(math.sqrt((xe-xc)**2+(ye-yc)**2+(ze-zc)**2)) #计算 m = M + 5lgd + klgr 的参数r,d 最小二乘： 123456789101112131415161718192021222324252627#此处lgr lgd m已输入数据A = np.vstack([lgr, np.ones(len(lgr))]).Tnp.linalg.lstsq(A,m - 5 * lgd,rcond=None) #输出[[斜率，截距],[方差],xx,xx]plt.scatter(lgr,m - 5 * lgd) #观察离散程度M = 3.94k = 25y1 = []y2 = []for x in np.linspace(0,119,120): x = int(x) #此处使用 m - 5lgd = klgr + M 进行最小二乘拟合 y1.append(M + 5 * math.log10(d[x]) + k * math.log10(r[x])) y2.append(12 + 5 * math.log10(d[x]) + 10 * math.log10(r[x]))x = np.linspace(-60,61,120)plt.figure(figsize = [6,4],dpi=150) #设置图的大小plt.xlabel('days from perihelion')plt.ylabel('magnitude')plt.title('picutre')plt.plot(x,y1,color=\"blue\")plt.plot(x,y2,color=\"red\")plt.ylim(max([max(y1),max(y2)])+1,min([min(y1),min(y2)])-1) #奇妙的做法，为了翻转y轴，想使用plt.gca().invert_yaxis()但不起作用，于是使用ylim反转上下限plt.savefig(\"figure.jpg\") #保存图片plt.show() 目前状况（2020-03-17）解决plt绘图重复的问题（前面分开，后面合并，连着直接绘制会出现问题）（可能是和figure()相关的问题）plt.grid()plt.legend()的配置plt.subplotlinewidthmatplotlib的documentation:matplotlib 重构了代码，更多地使用数组储存数据 双曲线a为负数Time(2439054.6837, format=’jd’,scale=’tdb’) #JD时间 poliastro.twobody.propagation.propagate相关：可以由orbit.propagate()调用，其中第一个参数为经过的时间，第二个参数为求解的方法（mean_motion,kepler,cowell），返回经过时间后的轨道 下一步：研究python的封装（函数、库、class之类）下一步：自写轨道库 matplotlib颜色映射（默认颜色）np.arange([start,],stop,[step])","categories":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/categories/%E5%A4%A9%E6%96%87/"}],"tags":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/tags/%E5%A4%A9%E6%96%87/"}]},{"title":"最近进展2020-2-19","slug":"最近进展2020-2-19","date":"2020-02-19T04:42:14.000Z","updated":"2020-02-23T13:02:19.933Z","comments":true,"path":"2020/02/19/最近进展2020-2-19/","link":"","permalink":"https://mizarzh.github.io/2020/02/19/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-2-19/","excerpt":"推箱子pushbox过于羞耻.jpg","text":"推箱子pushbox过于羞耻.jpg HTML与CSS知识相关这次使用的是外层创建div并限定长度、窗口居中（margin : auto），内部嵌套float:left的元素应该有更高效的（absolute+计算坐标），但还没搞清楚盒式模型 js文件过程js的调用并不是一次性的，可以使用函数重复调用（文件只可以进行一次，但是函数可以进行多次） 事件监听事件的监听是并行的，前面定义了click，后面定义了keydown，并不会停留在监听的函数中。（另外的问题：每个对象的监听是否只能有一个） 全局变量在window定义变量，再用window.xxx调用全局变量 数组嵌套对象concat(),slice(0)对一维数组有效数组中如果嵌套了对象，那么concat()、slice(0))也会对数组中的东西产生影响，换句话说就是没有进行深复制。这里应该深入对作用链的理解 混乱不堪的代码 运动系统过于复杂 或许可以换种架构，不需要每次移动都更新全部的DOM 全局变量和局部变量纠缠不清 贪吃蛇Greedy-Snake-js 随机数使用Math.random()生成[0-1)的一个数，配合Math.floor()食用更佳 数组判断相等数组的判断无法直接使用===号如果是较简单的数组可以使用Array.toString()方法比较。嵌套且长短不一的数组可能就需要单独比较了 深复制假设一个对象/数组a需要深复制，可使用JSON进行转化 1copy = JSON.parse(JSON.stringify(a)); 方法对于数组与对象的方法不熟悉（例如迭代等） 全局变量这次使用了对象包裹的方法定义全局变量，应该是稍微科学一点了也使用了ES6的let及const，更好的控制变量范围 throwthrow错误之后程序将停止运行","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记13","slug":"js高设笔记13","date":"2020-02-12T10:28:18.992Z","updated":"2020-02-14T09:54:07.142Z","comments":true,"path":"2020/02/12/js高设笔记13/","link":"","permalink":"https://mizarzh.github.io/2020/02/12/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B013/","excerpt":"13事件js与HTML之间的交互是通过事件实现的可以使用侦听器（或处理程序）来预订事件 13.1事件流13.1.1事件冒泡即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 13.1.2事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 13.1.3DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。","text":"13事件js与HTML之间的交互是通过事件实现的可以使用侦听器（或处理程序）来预订事件 13.1事件流13.1.1事件冒泡即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 13.1.2事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 13.1.3DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 13.2事件处理程序而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以”on”开头 13.2.1HTML事件处理程序属性onclick=”javascript代码” 12//前面定义了showMessage()&lt;input type=\"button\" value=\"ClickMe\" onclick=\"showMessage()\"/&gt; 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象在这个函数内部，this值等于事件的目标元素在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。 很多HTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面 13.2.2DOM0级事件处理程序每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。 1234varbtn=document.getElementById(\"myBtn\");btn.onclick=function()&#123;alert(\"Clicked\");&#125;; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行也可以删除通过DOM0级方法指定的事件处理程序，将onclick属性设为null即可。 13.2.3DOM2级事件处理程序addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法。它们都接受3个参数：要处理的事件名（意味着没有on前缀）、作为事件处理程序的函数和一个布尔值。这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。 13.2.4IE事件处理程序过时了吧emm 13.2.5跨浏览器的事件处理程序IE、DOM2、DOM0三种方法创建，创建为一个EventUtil的对象。 13.3事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。 13.3.1DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。 event属性：见书355页其中两个属性：currentTarget：其事件处理程序当前正在处理事件的那个元素target：事件的目标this始终等于currentTarget的值要阻止特定事件的默认行为，可以使用preventDefault()方法。只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则event-Phase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。 13.3.2IE中的事件对象过时了吧 13.3.3跨浏览器的事件对象13.4事件类型 UI（UserInterface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为IME（InputMethodEditor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层DOM结构发生变化时触发。 13.4.1UI事件详细见书362DOMActivate,(un)load,abort,error,select,resize,scroll除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件 13.4.2焦点事件blur,focus,focusin,focusout 13.4.3鼠标与滚轮事件click,dblclick,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup 鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，坐标是从页面本身而非视口的左边和顶边计算的。在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。 DOM规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。 对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。但对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠标按钮（鼠标滚轮按钮），2表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。 “DOM2级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。 当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件。与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。Firefox支持一个名为 DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。与 mousewheel 事件一样，DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在 detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是-3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是 3 的倍数 触摸设备： 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生； 如果屏幕没有因此变化，那么会依次发生 mousedown、mouseup 和 click 事件。 轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。 mousemove 事件也会触发 mouseover 和 mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。 13.4.4 键盘与文本事件keydown,keypress,keyup前两者如果按住不放的话，会重复触发此事件。只有一个文本事件：textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。 在发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同。表见P380 IE9、Firefox、Chrome 和 Safari的 event 对象都支持一个 charCode 属性，这个属性只有在发生 keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的 ASCII 编码。此时的 keyCode 通常等于0或者也可能等于所按键的键码 DOM3级变化：不再包含 charCode 属性，而是包含两个新属性：key 和 char。 key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时，key 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift” 或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。不同浏览器有不同实现 DOM3级事件还添加了一个名为 location 的属性，这是一个数值，表示按下了什么位置上的键： 0表示默认键盘，1表示左侧位置（例如左位的 Alt键），2表示右侧位置（例如右侧的 Shift键），3表示 数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂 Wii控制器）。 后是给 event 对象添加了 getModifierState()方法。这个方法接收一个参数，即等于 Shift、Control、AltGraph 或 Meta 的字符串，表示要检测的修改键。 “DOM3级事件”规范中引入了一个新事件，名叫 textInput。根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。由于 textInput 事件主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符（而非字符编码）。event 对象上还有一个属性，叫 inputMethod，表示把文本输入到文本框中的方式。 （值见P383） 13.4.5 复合事件复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。compositionstart,compositionupdate,compositionend 13.4.6 变动事件DOM2级的变动（mutation）事件能在 DOM中的某一部分发生变化时给出提示。DOMSubtreeModified,DOMNodeInserted,DOMNodeRemoved,DOMNodeInsertedIntoDocument,DOMNodeRemovedFromDocument,DOMAttrModified,DOMCharacterDataModified 13.4.7 HTML5事件 contextmenu 事件：上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单 beforeunload 事件：是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件的意图是将离开页面的控制权交给用户。 DOMContentLoaded 事件：在形成完整的 DOM树之后就会触发，不理会图像、JavaScript 文件、CSS文件或其他资源是否已经下载完毕。 readystatechange 事件：这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。 pageshow 和 pagehide 事件：这个事件在页面显示时触发，无论该页面是否来自 bfcache（来自bfcache的页面不会有load事件）。 hashchange 事件：在 URL的参数列表（及 URL中“#”号后面的所有字符串）发生变化时通知开发人员。 13.4.8 设备事件 orientationchange 事件 MozOrientation 事件 deviceorientation 事件 devicemotion 事件 13.4.9 触摸与手势事件 触摸事件 手势事件 13.5 内存和性能在 JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。 13.5.1 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。 1234567891011121314151617var list = document.getElementById(\"myLinks\"); EventUtil.addHandler(list, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case \"doSomething\": document.title = \"I changed the document's title\"; break; case \"goSomewhere\": location.href = \"http://www.wrox.com\"; break; case \"sayHi\": alert(\"hi\"); break; &#125; &#125;); //而不是三个对象分别设置不同的方法 这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress 13.5.2 移除事件处理程序内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的主要原因。直接移除元素（removeChild())好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。 13.6 模拟事件13.6.1 DOM中的事件模拟document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3级中都变成了单数。 UIEvents：一般化的 UI事件。鼠标事件和键盘事件都继承自 UI事件。DOM3级中是 UIEvent。 MouseEvents：一般化的鼠标事件。DOM3级中是 MouseEvent。 MutationEvents：一般化的 DOM变动事件。DOM3级中是 MutationEvent。 HTMLEvents：一般化的 HTML事件。没有对应的 DOM3级事件（HTML事件被分散到其他类别中）。 传入参数见书","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记10","slug":"js高设笔记10","date":"2020-02-11T08:11:37.000Z","updated":"2020-02-16T14:49:02.266Z","comments":true,"path":"2020/02/11/js高设笔记10/","link":"","permalink":"https://mizarzh.github.io/2020/02/11/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B010/","excerpt":"10 DOMDOM（文档对象模型）是针对 HTML和 XML文档的一个 API 10.1 节点层次DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。&lt;html&gt; 文档元素文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。","text":"10 DOMDOM（文档对象模型）是针对 HTML和 XML文档的一个 API 10.1 节点层次DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。&lt;html&gt; 文档元素文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。 10.1.1 Node类型DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现，JavaScript中的所有节点类型都继承自 Node 类型。每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12个数值常量来表示Node.ELEMENT_NODE(1)；Node.ATTRIBUTE_NODE(2)；Node.TEXT_NODE(3)；Node.CDATA_SECTION_NODE(4)；Node.ENTITY_REFERENCE_NODE(5)；Node.ENTITY_NODE(6)；Node.PROCESSING_INSTRUCTION_NODE(7)；Node.COMMENT_NODE(8)；Node.DOCUMENT_NODE(9)；Node.DOCUMENT_TYPE_NODE(10)；Node.DOCUMENT_FRAGMENT_NODE(11)；Node.NOTATION_NODE(12)。 nodeName 和 nodeValue：对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。 每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组对象（类似但不是Array），用于保存一组有序的节点，可以通过位置来访问这些节点。访问NodeList可通过方括号，也可以使用 item()方法转化为数组（或者手动循环）： 1var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中后一个节点的 nextSibling 属性的值同样也为 null。父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和后一个节点。 hasChildNodes()方法 所有节点都有的后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。 appendChild()，用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点及以前的后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild() 返回新增的节点。 insertBefore() 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作 replaceChild() 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。 removeChild() 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。 并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。 cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制（复制节点及其整个子节点树，浅复制只复制节点本身）。副本没有指定父节点。 normalize()，这个方法唯一的作用就是处理文档树中的文本节点。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。 10.1.2 Document类型JavaScript通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。 nodeType 的值为 9； nodeName 的值为”#document”； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null；其子节点可能是一个 DocumentType（多一个）、Element（多一个）、ProcessingInstruction 或 Comment。 documentElement 属性，该属性始终指向HTML页面中的元素。document 对象还有一个 body 属性，直接指向元素。Document 另一个可能的子节点是 DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息。 不同浏览器支持情况不同出现在元素外部的注释的引用不同浏览器的支持程度不同。 document.title：通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变&lt;title&gt;元素URL、domain 和 referrer。只有 domain 是可以设置的。但由于安全方面的限制，也并非可以给 domain 设置任何值。 getElementById()和getElementsByTagName()。前者id不存在返回null，id特性（attribute）严格匹配，包括大小写。后者返回的是包含零或多个元素的 NodeList。在 HTML文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name 特性取得集合中的项。（方括号访问亦可）后者可传入*，代表全部 虽然标准规定标签名需要区分大小写，但为了最大限度地与既有 HTML 页面兼容，传给 getElementsByTagName()的标签名是不需要区分大小写的。但对于 XML 页面而言（包括 XHTML），getElementsByTagName()方法就会区分大小写。 只有 HTMLDocument 类型才有的方法，是 getElementsByName()。顾名思义，这个方法会返回带有给定 name 特性的所有元素。 特殊集合：anchors(&lt;a name=”xxx”&gt;),forms(&lt;form&gt;),images(&lt;img&gt;),links(&lt;a href=”xxx”&gt;) document.implementation 属性为浏览器实现了DOM的哪些部分提供相应信息和功能的对象，其中的方法hasFeature()接受两个参数：要检测的 DOM功能的名称及版本号。若支持返回true。 write()、writeln()、open()和 close() 1234document.write(\"&lt;strong&gt;\" + (new Date()).toString() + \"&lt;/strong&gt;\");//载入外部脚本document.write(\"&lt;script type=\\\"text/javascript\\\" src=\\\"file.js\\\"&gt;\" + \"&lt;\\/script&gt;\"); 如果在文档加载结束后再调用 document.write()，那么输出的内容将会重写整个页面 10.1.3 Element类型 nodeType 的值为 1； nodeName 的值为元素的标签名； nodeValue 的值为 null； parentNode 可能是 Document 或 Element； 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。 HTML元素 id，元素在文档中的唯一标识符。 title，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang，元素内容的语言代码，很少使用。 dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），也很少使用。 className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为 class 是 ECMAScript的保留字 所有 HTML元素都是由 HTMLElement 或者其更具体的子类型来表示的。getAttribute()、setAttribute()和 removeAttribute()三个方法。最前者的返回可能会有差异1 返回的 style 特性值中包含的是 CSS文本，直接访问则是对象，2 事件处理程序。当在元素上使用时，onclick 特性中包含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。通常不使用getAttribute() setAttribute()通过这个方法设置的特性名会被统一转换为小写形式，即”ID”终会变成”id” 根据 HTML5规范，自定义特性应该加上 data-前缀以便验证。 Element 的attributes 属性中包含一个 NamedNodeMap，与 NodeList 类似，也是一个“动态”的集合。元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象拥有下列方法。 getNamedItem(name)：返回 nodeName 属性等于 name 的节点； removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos)：返回位于数字 pos 位置处的节点。 attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称。节点的 nodeValue 就是特性的值。removeNamedItem()返回表示被删除特性的 Attr 节点，removeAttribute()不返回attributes属性一般用于遍历元素属性返回属性的顺序不一定相同 每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML中指定了相应特性，要么是通过 setAttribute()方法设置了该特性。 document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。返回一个 DOM元素的引用 12345&lt;ul id=\"myList\"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; 返回后会有7个元素，包括3个li元素和4个空白符（li之间）可以通过nodeType的判断消除空白符 10.1.4 Text类型 nodeType 的值为 3； nodeName 的值为”#text”； nodeValue 的值为节点所包含的文本； parentNode 是一个 Element； 不支持（没有）子节点。 操作文本的方法： appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。文本节点还有一个 length 属性，保存着节点中字符的数目。每个可以包含内容的元素多只能有一个文本节点，而且必须确实有内容存在。 document.createTextNode()创建新文本节点 normalize()浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行 DOM操作的结果出现。splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。 10.1.5 Comment类型 nodeType 的值为 8； nodeName 的值为”#comment”； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element； 不支持（没有）子节点。 其他有CDATASection类型，DocumentType类型 ，DocumentFragment类型 ，Attr类型 DOM操作技术（待续）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记8","slug":"js高设笔记8","date":"2020-02-10T05:24:43.000Z","updated":"2020-02-11T07:32:20.082Z","comments":true,"path":"2020/02/10/js高设笔记8/","link":"","permalink":"https://mizarzh.github.io/2020/02/10/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B08/","excerpt":"BOMBOM（浏览器对象模型） 8.1 window 对象BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。","text":"BOMBOM（浏览器对象模型） 8.1 window 对象BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。 8.1.1 全局作用域全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。 12345var age = 29; window.color = \"red\"; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false delete window.age; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true delete window.color; //returns true 使用 var 语句添加的 window 属性的[[Configurable]]特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除通过查询 window 对象，可以知道某个可能未声明的变量是否存在。 8.1.2 窗口关系及框架页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。 123window.frames[0] window.frames[\"name属性\"]top.frames[0] top对象始终指向高（外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。与 top 相对的另一个 window 对象是 parent。顾名思义，parent（父）对象始终指向当前框架的直接上层框架。 除非高层窗口是通过 window.open()打开的（本章后面将会讨论），否则其 window 对象的 name 属性不会包含任何值。self始终指向 window；实际上，self 和 window 对象可以互 换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来这些对象都为window的属性，可通过window.xxx访问对象名|指向-|-top|始终指向高（外）层的框架parent|始终指向当前框架的直接上层框架self|始终指向 window 在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生 类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。 8.1.3 窗口位置screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。screenX 和 screenY各浏览器间实现不同 使用moveTo() 和 moveBy() 方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，moveTo()接收的是新位置的 x和 y坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数。另外，这两个方法都不适用于框架，只能对外层的 window 对象使用。 8.1.4 窗口大小innerWidth、innerHeight、outerWidth 和 outerHeightouterWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从外层的 window 对象还是从某个框架访问）innerWidth 和innerHeight 则表示该容器中页面视图区的大小（减去边框宽度）。不同浏览器代表不同。 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息 对于移动设备，window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。 resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小 8.1.5 导航和打开窗口window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（如top=100，注意，整个特性字符串中不允许出现空格）调用 close()方法还可以关闭新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但仅能用类似alert的方法检测closed参数了 新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口 将 opener 属性设置为 null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。 浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open()的调用封装在一个try-catch 块中 8.1.6 间歇调用和超时调用JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。 前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。超时调用需要使用 window 对象的 setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。第一个参数可以是一个包含 JavaScript代码的字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。（一般用匿名函数）第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个 参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 clearTimeout()方法并将相应的超时调用 ID作为参数传递给它。 间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 setInterval()取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。 123456789101112var num = 0; var max = 10; //使用递归方法function incrementNumber() &#123; num++; //如果执行次数未达到 max 设定的值，则设置另一次超时调用 if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert(\"Done\"); &#125; &#125; setTimeout(incrementNumber, 500); 一般认为，使用超时调用来模拟间歇调用的是一种佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，好不要使用间歇调用。 8.1.7 系统对话框alert()、confirm()和 prompt()为了确定用户是单击了 OK还是 Cancel，可以检查 confirm()方法返回的布尔值：true 表示单击了 OK，false 表示单击了 Cancel或单击了右上角的 X按钮。 prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK和 Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。如果用户单击了OK按钮，则 prompt()返回文本输入域的值；如果用户单击了 Cancel或没有单击 OK而是通过其他方式关闭了对话框，则该方法返回 null。 find() 查找 和 print() 打印 方法 8.2 location对象location它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。是window对象的属性，也是document的属性。属性 8.2.1 查询字符串参数location.search 返回从问号到 URL末尾的所有内容可以新建函数获取?后面的参数 decodeURIComponent()解码URL 8.2.2 位置操作location 对象可以通过很多方式来改变浏览器的位置。使用assign()方法改变window.location或者location.href会调用assgin()方法每次修改 location 的属性（hash 除外），页面都会以新 URL重新加载。要禁用生成记录行为，应使用replace()方法，不能回到前一个页面reload()，作用是重新加载当前显示的页面。传入参数true，则强制从服务器重新加载数据，而不传入则可能从缓存中加载。 8.3 navigator 对象navigator对象属性见书P200-201 8.3.1 检测插件plugins属性 name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME类型数量。因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。plugins 集合有一个名叫 refresh()的方法，用于刷新 plugins 以反映最新安装的插件。 8.3.2 注册处理程序registerContentHandler()和registerProtocolHandler()这两个方法可以让一个站点指明它可以处理特定类型的信息。前者接收参数：要处理的 MIME类型、可以处理该 MIME 类型的页面的 URL以及应用程序的名称。后者接收参数：要处理的协议（例如，mailto 或 ftp）、处理该协议的页面的 URL和应用程序的名称。 12navigator.registerContentHandler(\"application/rss+xml\", \"http://www.somereader.com?feed=%s\",\"Some Reader\"); //%s代表RSS源URL 8.4 screen 对象用处不大用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息书中P214 8.5 history 对象go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置近。如果历史记录中不包含该字符串，那么这个方法什么也不做还可以使用两个简写方法 back()和 forward()来代替 go()。history 对象有一个 length 属性，保存着历史记录的数量。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记7","slug":"js高设笔记7","date":"2020-02-10T04:17:39.000Z","updated":"2020-02-11T07:32:19.270Z","comments":true,"path":"2020/02/10/js高设笔记7/","link":"","permalink":"https://mizarzh.github.io/2020/02/10/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B07/","excerpt":"7 函数表达式7.1 递归使用argument.callee严格模式下，可使用命名函数表达式来达成相同的结果 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125; &#125;); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。","text":"7 函数表达式7.1 递归使用argument.callee严格模式下，可使用命名函数表达式来达成相同的结果 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125; &#125;); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。 7.2 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;; &#125; 在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记6","slug":"js高设笔记6","date":"2020-02-07T10:14:42.000Z","updated":"2020-02-09T15:31:37.514Z","comments":true,"path":"2020/02/07/js高设笔记6/","link":"","permalink":"https://mizarzh.github.io/2020/02/07/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/","excerpt":"6 面向对象的程序设计（注意：js中的面向对象实现与C++中不同） 6.1 理解对象1234567891011121314151617var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\"; person.sayName = function()&#123; alert(this.name); &#125;; var person = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125; &#125;;","text":"6 面向对象的程序设计（注意：js中的面向对象实现与C++中不同） 6.1 理解对象1234567891011121314151617var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\"; person.sayName = function()&#123; alert(this.name); &#125;; var person = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125; &#125;; 6.1.1 属性类型数据属性ECMA-262第 5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。 实现 JavaScript引擎用的，因此在 JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认的特性，必须使用 ECMAScript 5的Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。 12345var person = &#123;&#125;; Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\" &#125;); 这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。 把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。 访问器属性访问器属性不包含数据值；它们包含一对 getter和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter函数并传入新值，这个函数负责决定如何处理数据。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。 1234567891011121314151617var book = &#123; _year: 2004, edition: 1 &#125;; Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;); book.year = 2005; alert(book.edition); //2 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。只指定 getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。 6.1.2 多个属性123456789101112131415161718192021var book = &#123;&#125;; Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125; &#125;); 6.1.3 读取属性的特性Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述 符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。 123456789var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); alert(descriptor.value); //2004 alert(descriptor.configurable); //falsealert(typeof descriptor.get); //\"undefined\" var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\"function\" 6.2 创建对象6.2.1 工厂模式123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\"); var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 6.2.2 构造函数模式12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。使用了函数就是对象的想法，将属性添加到this上。 两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。 若Person不使用new，则认为是在为window添加属性可使用call将作用域限定为某个对象 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。不同实例上的同名函数是不相等的。 6.2.3 原型模式解决构造函数的方法不相等问题。prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 12345678function Person()&#123;&#125; Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; 在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。 原型对象的理解：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。 Person 的每个实例—— person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与构造函数没有直接的关系。所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。 in操作符单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 1\"name\" in person1; ECMAScript 5也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5的 Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象: 123456789function Person()&#123; &#125; Person.prototype = &#123; name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125; &#125;; 有一个例外：constructor 属性不再指向 Person 了，指向Object如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可用defineproperty重设回来。 1constructor : Person, 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。如果是重写整个原型对象，实例中的指针仅指向原来的原型，而不指向构造函数。调用构造函数时会为实例添加一个指向初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与初原型之间的联系。总结：先定义原型再创建实例，不然实例指向的是原prototype 问题它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。共享，有时候需要分离的属性因此不经常单独使用 6.2.4 组合使用构造函数模式和原型模式123456789101112function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; &#125; Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125; &#125; 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，大限度地节省了内存。 是目前在 ECMAScript中使用广泛、认同度高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 6.2.5 动态原型模式(理解？)它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。 123456789101112function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125; &#125; 6.2.6 寄生构造函数模式寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。 12345678910function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; 除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。 首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。我们建议在可以使用其他模式的情况下，不要使用这种模式。 6.2.7 稳妥构造函数模式稳妥对象（durable objects）。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 123456789101112function Person(name, age, job)&#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function()&#123; alert(name); &#125;; //返回对象 return o; &#125; 除了使用 sayName()方法之外，没有其他办法访问 name 的值。 6.3 继承继承分为接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript使用实现继承。通过原型链实现 6.3.1 原型链其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 123456789101112131415function SuperType()&#123; this.property = true; &#125;SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.subproperty; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //true instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，后一步才会找到该方法。 最上层的原型链继承自Object，因此也可以使用Object的方法。 使用instanceof/isPrototypeof()对原型链上的对象进行比较都会返回true 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。 即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链 问题1 SubType 的所有实例都会共享属性。2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 6.3.2 借用构造函数在子类型构造函数的内部调用超类型构造函数。通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数 1234567function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"]; &#125; function SubType()&#123; //继承了 SuperType SuperType.call(this); &#125; 两者没有关系如果SuperType可以传递参数，则使用call()方法也可传递参数问题：方法都在构造函数中定义，无法复用函数。 6.3.3 组合继承组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 过程：先定义supertype的属性，再定义subtype的私有属性，再定义原型链。js中最常用的继承模式 6.3.4 原型式继承12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; 进行浅复制，复制后仍指向原来的对象（共享属性） ECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 6.3.5 寄生式继承1234567function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象 &#125; 6.3.6 寄生组合式继承组合继承大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。|不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。 12345function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象 &#125; 在定义完supertype和subtype之后调用此函数，则完成了继承。 总结[[xxx]]当作是属性的属性，则可理解defineProperty和defineProperties的写法，以及getOwnPropertyDescripter指向的东西模式：[[Prototype]]实例所有，指向该实例的构造函数的原型对象prototype为构造函数所有，指向该构造函数的原型对象constructor实例所有，指向构造函数 工厂模式 createPerson() + return 构造函数模式 Person() + new 原型模式 Person()的对象名prototype含有的属性Person.prototype.xxx 上面两个组合 动态原型 寄生构造函数、稳妥构造函数 继承： 原型链。subType的prototype指向superType的实例，则逻辑：subType为superType的一个实例 -&gt; subType拥有[[Prototype]]属性，且指向构造函数superType的原型对象superType.prototype -&gt; 原型链构造完成，可以寻找到superType.prototype的属性 借用构造函数：在subType内使用call()或apply()构建superType属性的深复制。 上面两者组合 原型式继承 寄生式继承 寄生组合式继承","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记5","slug":"js高设笔记5","date":"2020-02-07T10:13:27.000Z","updated":"2020-02-09T14:05:19.957Z","comments":true,"path":"2020/02/07/js高设笔记5/","link":"","permalink":"https://mizarzh.github.io/2020/02/07/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B05/","excerpt":"5 引用类型引用类型是一种结构。 5.1 Object类型创造实例的两种方法：1、new+构造函数2、对象字面量 12345678910var person = new Object();person.name = \"Nicholas\";person.age = 29;var person = &#123; name : \"Nicholas\", age : 29&#125;;var person = &#123;&#125;; //相当于new Object()","text":"5 引用类型引用类型是一种结构。 5.1 Object类型创造实例的两种方法：1、new+构造函数2、对象字面量 12345678910var person = new Object();person.name = \"Nicholas\";person.age = 29;var person = &#123; name : \"Nicholas\", age : 29&#125;;var person = &#123;&#125;; //相当于new Object() 属性名可以使用字符串（包括字符串数字）。使用对象字面量定义对象不会调用Object()构造函数 访问方法：person[“name”]或person.name除非必须通过方括号法表示，否则用点表示法 5.2 Array每一项可保存不同的数据类型 1234567//构造函数法var colors = new Array();var colors = new Array(20);// len=20var colors = new Array(\"blue\",\"green\");//字面量法var colors = [];var colors = [\"blue\",\"green\"]; length属性设定length，短了切除，长了用undefined填充。在超远的距离填充（如colors[99] = “xx”，那么2-98都为undefined。套路： 1colors[colors.length] = \"xx\";//在最后一项添加 5.2.1 检测数组instanceof（假定只有一个全局环境）Array.isArray()方法（不管有多少个环境） 5.2.2 转换方法toLocaleString(),toString(),valueOf()调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf()返回的还是数组。 12345678var person = &#123; toLocaleString : function&#123; ... &#125; toStirng : function&#123; ... &#125;&#125;;//这样改变方法 join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串（不传入值或undefined就用逗号）。 5.2.3 栈方法LIFO:push() pop()push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除后一项，减少数组的 length 值，然后返回移除的项。 5.2.4 队列方法FIFO:shift()和push():能够移除数组中的第一个项并返回该项，同时将数组长度减 1unshift():在数组前端添加任意个项并返回新数组的长度。 5.2.5 重排序方法reverse()sort() 方法按升序排列数组项。sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。传入比较function判断排序。如： 12345678910function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;values.sort(compare); 5.2.6 操作方法concat() 方法可以基于当前数组中的所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，后返回新构建的数组。 slice() 能够基于当前数组中的一或多个项创建一个新数组。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。注意，slice()方法不会影响原始数组。（可为负数） splice() 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。 插入：可以向指定位置插入任意数量的项，只需提供 3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 总结：splice(start,length,insert_values…) 5.2.7 位置方法indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。比较使用=== 5.2.8 迭代方法 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。 5.2.9 归并方法reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个终返回的值。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。 5.3 Date类型1var d = new Date();//括号中填入毫秒数 表示自 UTC（Coordinated Universal Time，国际协调时间）1970年 1月 1日午夜（零时）开始经过的毫秒数来保存日期。parse():不固定具体格式，转化为该日期的毫秒数UTC()：按照年、月、日、时、分、秒、毫秒顺序填入。其中月和时从0开始，转化为该日期的毫秒数。toString()/toLocaleString()：转化为日期表示。（目测toLocaleString()会考虑到时区的问题）now()：返回现在时间的毫秒数 如同模仿 Date.parse()一样，Date 构造函数也会模仿 Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。 Date 构造函数接收的参数仍然与 Date.UTC()相同。 valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。格式方法与组件方法见书P101-102 5.4 RegExp类型见另外的文档RegExp 5.5 Function类型函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。 1234567function sum (num1, num2) &#123; return num1 + num2; &#125;var sum = function(sum1, sum2)&#123; return num1 + num2;&#125;;var sum = new Function(\"sum1\",\"sum2\",\"return num1 + num2\")//不推荐 不推荐的那种会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。 5.5.1 没有重载函数名为指针，如果定义了另外一个函数则会指向另外一个函数。 5.5.2 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。 5.5.3 作为值的函数因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。函数的return可返回一个函数 5.5.4 函数内部属性arguments和this。arguments的callee属性：该属性是一个指针，指向拥有这个 arguments 对象的函数。如： 123456789function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) //不是factorial，消除了与这个名字的耦合 &#125; &#125; var trueFactorial = factorial; //可正常调用，factorial则不行 this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window） ECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。 ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。 5.5.5 函数属性和方法每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数 在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。 apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。 它们真正强大的地方是能够扩充函数 赖以运行的作用域。 123456789window.color = \"red\"; var o = &#123; color: \"blue\" &#125;; function sayColor()&#123; alert(this.color); &#125; sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值。 (待续)","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"Regexp相关","slug":"Regexp相关","date":"2020-02-04T16:57:40.000Z","updated":"2020-02-08T14:31:13.495Z","comments":true,"path":"2020/02/05/Regexp相关/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/Regexp%E7%9B%B8%E5%85%B3/","excerpt":"正则表达式的表示方法来自：regexlab 1、直接写内容直接匹配内容 2、转义字符1 字符 含义 \\n \\r 换行符 \\t 制表符 \\\\ \\的字符 \\$ $的字符 \\^ ^的字符 \\. .的字符","text":"正则表达式的表示方法来自：regexlab 1、直接写内容直接匹配内容 2、转义字符1 字符 含义 \\n \\r 换行符 \\t 制表符 \\\\ \\的字符 \\$ $的字符 \\^ ^的字符 \\. .的字符 2 字符 含义 \\d 任意数字 \\w 任意数字、字母及下划线_ \\s 空白或制表符或换页符 . 任意字符（除换行符） 3、方括号使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。如：[abc] (a,b,c中任意一个)、[^ f-k] (不是f-k的任意一个字母)、[A-F0-9] (A-F和0-9中任意一个) 4、数量匹配{n}重复n次{m,n}重复至少m次至多n次{m,}至少重复m次? 相当于 {0,1}+ 相当于 {1,}* 相当于 {0,} 5、位置匹配？^ 与字符串开始的地方匹配，不匹配任何字符（若匹配到的字符不是开始则错误）$ 与字符串结束的地方匹配，不匹配任何字符\\b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符 6、其他| 左右两边表达式之间 “或” 关系，匹配左边或者右边( )(1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 7、高级技巧贪婪与非贪婪默认是贪婪（匹配得越多越好）在数量符号后面加上?（如w+?）则为非贪婪模式，匹配越少越好 引用\\1、\\2等符号获取在( )中匹配的字符 预搜索，不匹配；反向预搜索，不匹配(?=xxxx) 8、其他\\xXX \\uXXXX 表示字符（编码相关？）\\S \\D \\W \\B 代表相反意义（非数字等） 注意事项 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。 需注意贪婪与非贪婪模式 或 “|” 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 “|” 两边的表达式因为交换位置而有所不同。 js里面的正则表达式形式：12var exp = / pattern / flags;//字面量类型var exp2 = new RegExp(\"[bc]at\", \"i\"); //构造函数 模式（pattern）为表达式。flags:g表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。传入构造函数的字符串需双重转义如匹配\\：字符串|字面量|匹配-|-|-\\\\\\\\|\\\\|\\（嗯其实这里打的markdown已经是四重转义了） 实例的属性 global：布尔值，表示是否设置了 g 标志。 ignoreCase：布尔值，表示是否设置了 i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。 multiline：布尔值，表示是否设置了 m 标志。 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 实例的方法exec()：接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。 返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。 在数组中，第一项是与整个模式匹配 的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，常与for函数一起使用用于找出所有匹配项。 test():它接受一个字符串参数。在模式与该参数匹配的情况下返回 true；否则，返回 false。 toLocaleString()和toString() 方法都会返回正则表达式的字面量。valueOf()方法返回正则表达式本身。 RegExp构造函数属性原理（NFA）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"JSON相关","slug":"JSON相关","date":"2020-02-04T16:56:57.000Z","updated":"2020-02-11T16:02:52.487Z","comments":true,"path":"2020/02/05/JSON相关/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/JSON%E7%9B%B8%E5%85%B3/","excerpt":"JSON组成简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。","text":"JSON组成简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 例子：“Hello world!” 简单值{“name”: “Nicholas”,”age”: 29} 对象[25, “hi”, true] 数组 js中解析与序列化12345var book = &#123; //JSON表达式&#125;var jsontext = JSON.stringify(book);var bookC = JSON.parse(book); JSON 对象的两个方法：stringify()和 parse()将 JSON字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript对象（或数组、值）。 过滤结果123456stringify(book,[year,edition]);JSON.stringify(book, function(key, value)&#123; switch(key)&#123; //判定是哪个属性，不要就返回undifined &#125;&#125; 第三个参数用于控制结果中的缩进和空白符如果是一个数值，则为缩进数如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON字符串中被用作缩进字符 如果某些对象无法使用JSON对象转化，可以自己定义该对象的toJSON()方法 序列化顺序：(1) 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。(3) 对第(2)步返回的每个值进行相应的序列化。(4) 如果提供了第三个参数，执行相应的格式化。 JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。这个函数被称为还原函数（reviver）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高级设计笔记（第四章）","slug":"js高设笔记4","date":"2020-02-04T16:35:24.000Z","updated":"2020-02-08T14:30:51.296Z","comments":true,"path":"2020/02/05/js高设笔记4/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B04/","excerpt":"第四章4.1 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。引用类型值（Object？） js不允许直接访问内存 4.1.1 属性对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。不能给基本类型值添加属性。","text":"第四章4.1 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。引用类型值（Object？） js不允许直接访问内存 4.1.1 属性对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。不能给基本类型值添加属性。 4.1.2 复制基本类型值”=”将进行值的复制，两个值之间不相关而引用类型值的”=”将指向同一个对象 4.1.3 传递参数 ECMAScript 中所有函数的参数都是按值传递的。把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。可以把 ECMAScript函数的参数想象成局部变量。 my comprehension:不管什么值进入函数都会复制一遍，并在函数内部赋值到一个临时变量上。基本类型值基本没问题，但引用类型值的引用也被复制了，当在内部改变临时变量的属性时，随着引用外部的对象也会随着改变。 4.1.4 检测类型typeof方法和instanceof方法 4.2 执行环境及作用域 执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。全局变量与每个函数的执行环境每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。 4.2.1 延长作用域链try-catch语句的catch块：with语句：不解释 4.2.2 没有块级作用域 变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完add()之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。 4.3 垃圾收集自动垃圾手机机制 4.3.1 标记清除变量进入环境时，将变量标记为“进入环境”。离开时标记为“离开环境”。 4.3.2 引用清除用得不多。跟踪记录每个值使用的次数。问题：循环引用。需手动切断链接。（设置引用为null） 4.3.3 性能问题注意性能相关问题。 4.3.4 管理内存不需要时手动解除引用。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"有用的网址","slug":"有用的网址","date":"2020-01-30T05:20:56.000Z","updated":"2020-02-09T14:06:52.513Z","comments":true,"path":"2020/01/30/有用的网址/","link":"","permalink":"https://mizarzh.github.io/2020/01/30/%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/","excerpt":"NexT文档 https://theme-next.org/docs/http://theme-next.iissnan.com/网上搜索很方便（hexo文档和blog很多） mc相关： 中文论坛 https://www.mcbbs.net/mod https://www.mcmod.cn/class/category/1-1.htmlcusreforge https://curseforge.comHMCL https://hmcl.huangyuhui.netgamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wikigamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki","text":"NexT文档 https://theme-next.org/docs/http://theme-next.iissnan.com/网上搜索很方便（hexo文档和blog很多） mc相关： 中文论坛 https://www.mcbbs.net/mod https://www.mcmod.cn/class/category/1-1.htmlcusreforge https://curseforge.comHMCL https://hmcl.huangyuhui.netgamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wikigamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki","categories":[{"name":"杂物","slug":"杂物","permalink":"https://mizarzh.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[]},{"title":"mc相关配置解释","slug":"mc相关配置解释","date":"2020-01-30T03:50:14.000Z","updated":"2020-02-26T07:05:40.372Z","comments":true,"path":"2020/01/30/mc相关配置解释/","link":"","permalink":"https://mizarzh.github.io/2020/01/30/mc%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/","excerpt":"1.mc版本mc（pc端）分为java版与基岩版（C++编写）java版可自行下载，基岩版必须购买 java版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接） 以下讨论只针对java版","text":"1.mc版本mc（pc端）分为java版与基岩版（C++编写）java版可自行下载，基岩版必须购买 java版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接） 以下讨论只针对java版 2.配置方法启动游戏需配置三样东西：java环境，游戏本体，启动器 游戏运行于java环境，因此首先需下载JDK（java development kit）并安装 目前许多启动器可以直接下载游戏本体，因此不需要再专门下载游戏本体。游戏本体位于.minecraft文件夹内 启动器用于启动游戏，常见的有HMCL等 3、mod相关安装mod需要下载forge（然鹅官网好像访问很慢）安装后会出现mods文件夹，直接将mod的jar包拖入其中即可 4、自建服务器以ubuntu为例首先需下载server.jarmc_serverubuntu需要使用wget获得服务器再安装jdk： 1sudo apt install openjdk-11-jre-headless 安装完成后再在bash输入： 1sudo java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui 就可生成文件使用文本编辑器在生成的eula.txt文件中修改为true，在server.properties文件中修改online-mode=false制作启动脚本： 123#!/bin/shjava -Xms512m -Xmx1024m -jar /path/to/server.jar nogui;","categories":[{"name":"游戏","slug":"游戏","permalink":"https://mizarzh.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"mc","slug":"mc","permalink":"https://mizarzh.github.io/tags/mc/"}]},{"title":"杂项问题","slug":"small-problem","date":"2020-01-28T03:38:56.000Z","updated":"2020-02-08T16:55:12.724Z","comments":true,"path":"2020/01/28/small-problem/","link":"","permalink":"https://mizarzh.github.io/2020/01/28/small-problem/","excerpt":"hexo相关1. vscode使用markdown相关preview：右上角点击preview即可可装插件Markdown Preview Enhanced使得preview更好看 2、hexo标签问题设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法： 1hexo n page tags #或categories等 然后在source/tags目录中配置index.md","text":"hexo相关1. vscode使用markdown相关preview：右上角点击preview即可可装插件Markdown Preview Enhanced使得preview更好看 2、hexo标签问题设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法： 1hexo n page tags #或categories等 然后在source/tags目录中配置index.md 123456---title: 标签date:type: \"tags\" //或者\"categories\"--- 然后hexo g即可 3、hexo目录乱序需要按顺序一级一级使用#如##后应该跟###而不是#### 4、hexo插入图片摸索出来的新方法： 手动在_post文件夹建立与md相同名字的文件夹（不含.md)，往里面放入图片 直接使用![](xxx/文件名) 后面这种网上常见方法在我这里不适用/会出bug例如我使用了之后就会使得地址处多了一个/.io/，无法连接到正确图片上 _config.yml里面的post_asset_folder设为true 安装插件1cnpm install hexo-asset-image --save 安装完成后后hexo n “xxx”就会生成xxx.md的同时生成一个同名文件夹，图片放在里面即可。 调用图片的命令为![](xxx/文件名) git相关1、git速度过慢需设置hosts文件，隔一段时间需重新设置","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"hexo win10配置方法，并使用github作为博客地址","slug":"hexo-blog-in-windows","date":"2020-01-27T14:46:41.000Z","updated":"2020-02-08T14:30:49.829Z","comments":true,"path":"2020/01/27/hexo-blog-in-windows/","link":"","permalink":"https://mizarzh.github.io/2020/01/27/hexo-blog-in-windows/","excerpt":"0、准备： node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： 12git config --global user.name \"Firstname Lastname\"git config --global user.email \"your-email@youremail.com\" github新建repository的地址需命名为your-github-name.github.io 1、使用cnpmnpm命令在国内较慢，需要安装cnpm(淘宝镜像) 1npm install -g cnpm --registry=https://registry.npm.taobao.org","text":"0、准备： node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： 12git config --global user.name \"Firstname Lastname\"git config --global user.email \"your-email@youremail.com\" github新建repository的地址需命名为your-github-name.github.io 1、使用cnpmnpm命令在国内较慢，需要安装cnpm(淘宝镜像) 1npm install -g cnpm --registry=https://registry.npm.taobao.org 2、安装hexo1cnpm install -g hexo-cli 3、新建文件夹新建一个文件夹，里面将存储blog所需文件 12mkdir my_blogcd my_blog 4、初始化hexo1hexo init 5、安装hexo部署至github的工具1cnpm install --save hexo-deployer-git （若出现ERROR Deployer not found: git错误，则是这个工具未安装） 6、其他配置其中文件_config.yml是配置文件部署到github上需要配置deploy部分 1type: 'git' 添加两行： 12repo: _path-to-github-blog_branch: master 可在theme中更换主题 本地临时服务器：12hexo s s 代表 start 默认地址为localhost:4000 新建文档：12hexo n \"name\" n 代表 new 文档存放在/source/_post/中 生成文档：12hexo g g 代表 generate 部署文档到github上： 12hexo d d 代表 deploy 第一次配置可能需要输入github的账号密码若是git bash内提示账号相关的错误，返回第零步进行账号的配置","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://mizarzh.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T13:59:53.866Z","updated":"2020-01-27T13:59:53.866Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"https://mizarzh.github.io/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}