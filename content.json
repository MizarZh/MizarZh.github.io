{"meta":{"title":"MizarZh's blog","subtitle":"","description":"","author":"MizarZh","url":"https://mizarzh.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-08T06:03:53.939Z","updated":"2020-02-08T06:03:53.939Z","comments":true,"path":"categories/index.html","permalink":"https://mizarzh.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-08T06:03:55.127Z","updated":"2020-02-08T06:03:55.127Z","comments":true,"path":"tags/index.html","permalink":"https://mizarzh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"天文望远镜基础知识","slug":"天文望远镜基础知识","date":"2021-09-09T15:27:17.000Z","updated":"2021-09-10T17:05:31.964Z","comments":true,"path":"2021/09/09/天文望远镜基础知识/","link":"","permalink":"https://mizarzh.github.io/2021/09/09/%E5%A4%A9%E6%96%87%E6%9C%9B%E8%BF%9C%E9%95%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"天文望远镜基本知识天文望远镜类型 折射望远镜 反射望远镜 折反式望远镜 折射与反射望远镜示意图：","text":"天文望远镜基本知识天文望远镜类型 折射望远镜 反射望远镜 折反式望远镜 折射与反射望远镜示意图： 折射望远镜最老的是伽利略式望远镜，使用的是一凸一凹的镜片。 后来改进成两个凸透镜，但出现了另一个问题：色差(chromatic aberration)，即不同颜色聚焦在不同的焦点上，导致成像有色彩分离和偏差现象。 解决方法是加入一个或多个凸透镜从而消除色差的影响。可以分为普通消色差和复消色差望远镜。 由于复消色差望远镜如此优秀，其仍是拍摄的最佳选择，就是贵。 反射望远镜分牛反和其他反，牛反在开头的示意图，卡塞格林反射镜如下： 反射望远镜的问题有彗差(coma)和球差(spherical aberration)。 彗差是由于是轴外物点发出宽光束通过光学系统后，并不会聚一点，相对于主光线而是呈彗星状图形的一种失对称的像差。 球差是由于电磁透镜中心区域和边缘区域对电磁波会聚能力不同而造成的。 折反射望远镜为了解决反射望远镜的种种问题，就需要在前面增加矫正镜。有两种不同的添加方式，对应两种不同的望远镜。 mounting 系统实在不知道怎么翻译…… 望远镜有两种 mounting 系统，即地平式及赤道式。对于普通望远镜来说赤道式的望远镜是最适合的，但对于大型望远镜来说，赤道式所承受的重量不够，且有软件的辅助，基本都采用地平式。 参数基本参数 口径$D$：最重要的参数。 焦距$f$ 目镜焦距 $f’$ 人眼参数：瞳孔直径 $d_{\\text{pupil}}=6\\text{mm}$ ，对 555nm 光线最敏感。最小分辨角$e_{\\text{pupil}}\\approx2’$。 推导参数放大率$$G=f/f’$$ 推导：放大率顾名思义即镜中看到的大小与实际物体角大小的比值。即： $$G=u’/u \\s=f\\tan u\\approx fu = f’u’ \\G=u’/u=f/f’$$ 焦比$F=f/D$，通常写法 f/3.5,f/10 等等。这个数与望远镜收集光的数量相关。 理论视场$\\tan(\\omega/2)=D/f$，及其小角近似。简单推导即可得。 分辨本领、最小分辨角$$\\theta=1.22\\lambda/D$$取$\\lambda=550\\text{nm}$，可得：$\\theta(^”)=140/D(\\text{mm})$。 底片比例尺$$\\omega=d/f$$意为底片上$d$的长度相当于视场中$\\omega$的角大小。推导： 极限星等推导：人眼极限星等 6，口径 6mm。$$m=6+2.5\\lg(\\frac{D}{6})^2=2.1+5\\lg D$$ 最大放大率眼睛的最小分辨角/望远镜的最小分辨角即为最大放大率$$G_{\\text{max}}=2’/\\theta\\approx 2’\\cdot D/\\lambda\\approx D/1\\text{mm}$$ 最小放大率、出瞳口径 如图，出瞳口径$L$必须比瞳孔大小要小。$$L=\\frac{f’}{f}D=\\frac{D}{G}$$由$L\\le d_{\\text{pupil}}$即可知$G\\ge D/d_{\\text{pupil}}$ 常识影响观测的因素seeing（视宁度）：大气的抖动。视宁度越好，大气抖动越少，观测条件越好。 接收器材照相底片-&gt;光电倍增管-&gt;CCD（电子耦合器件） 量子效率逐渐提升，线性性逐渐增加，光子利用率逐渐增大。 还有另一类重要的观测方法即光谱。 有两种方法分光：棱镜分光和光栅分光。光栅分光的损耗率远远低于棱镜分光，因此基本都在用光栅分光。 波段观测概况波段分类： 波段在大气中的通过率及相关信息： 蟹状星云在不同波段下的相片： 以下的例子都是大型望远镜。 射电两种模式：steerable（可转动的）和不可转动的。 组合模式：单体和多体（使用干涉技术提升等效口径） 例子： 可转动的如飞马, green bank 不可转动如 FAST, Arecibo。这类望远镜其实并不是完全不可动，它可以将一部分球形变形为抛物线形从而接收信号并获得一部分的转向能力。 多体如 ALMA, VLA。 微波微波与射电较为相似，但镜面更加光滑。 红外和光学望远镜较为相似。 由于大气的阻隔，大部分是太空望远镜，只有少部分在高海拔地区的地面望远镜。 例子： Herschel 太空望远镜，鸽王 James Webb 太空望远镜。 可见光地面望远镜、太空望远镜。 分折射、反射。 最大的折射望远镜是在 Yerkes Observatory 的 1m 折射望远镜。 现在主流的大口径望远镜都是反射望远镜，有单体磨成的镜片和许多块单独镜面拼成，目前最大 10m，详情见望远镜排行榜。未来的大望远镜有 E-ELT 39m 及 TMT 30m。新技术有主动光学和有限的干涉。 太空望远镜最著名的就是 Hubble 望远镜。 紫外分软紫外及硬紫外。 说实话，没啥著名的（ X 射线分软 X 射线及硬 X 射线。 由于 X 射线极强的穿透性，导致传统的折射和反射类型望远镜都无法使用。 有两种解决方案： 1、grazing（掠射）。如瞳（反向调节最为致命），钱德拉 X 射线天文台。 2、做成桶状，直接接收。如 HXMT（慧眼） $\\gamma$射线同样的使用掠射的方案。 著名的卫星有：swift（雨燕）卫星，Fermi（费米）伽马射线太空望远镜。 有一种间接观测的方法是观测通过$\\gamma$射线与空气之间的切伦科夫效应发出的光，如 MAGIC 望远镜。 其他媒介中微子 中微子与其他物质难以作用，但也不是完全不可作用。主要方法是探测中微子在重水中的切伦科夫辐射。 著名天文台：日本的神冈、南极的 IceCube。 引力波 原理是通过迈克尔逊干涉仪测量空间上的微小震荡从而观测引力波的发生。科学仪器：LIGO。 后记望远镜介绍这里好多图都没有放，就是懒……以后有机会补上吧。","categories":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/categories/%E5%A4%A9%E6%96%87/"}],"tags":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/tags/%E5%A4%A9%E6%96%87/"}]},{"title":"webpack学习","slug":"webpack学习","date":"2021-09-08T15:10:32.000Z","updated":"2021-09-10T17:06:11.323Z","comments":true,"path":"2021/09/08/webpack学习/","link":"","permalink":"https://mizarzh.github.io/2021/09/08/webpack%E5%AD%A6%E4%B9%A0/","excerpt":"webpack 学习介绍webpack 不用多介绍，一个大名鼎鼎的前端打包工具。 官网上是这么介绍的： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 _bundle_。","text":"webpack 学习介绍webpack 不用多介绍，一个大名鼎鼎的前端打包工具。 官网上是这么介绍的： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 _bundle_。 关键概念webpack 的核心概念有四个： 入口(entry) 输出(output) loader 插件(plugins) webpack 配置文件： 1234567891011121314const path = require('path');module.exports = &#123; entry: './src/js/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js', &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: 'raw-loader' &#125;], &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;)], mode: 'development',&#125;; entry 指从指定文件处开始进行打包，output 指定打包后输出的位置及名称。 module(loader)对于引入的特定文件会有特殊的处理。文件通过正则表达式进行匹配，可选择不同的 loader 从而达成不同的操作效果。 plugin 相较于 loader 则有着更为强大的功能。 mode 指定工作模式。development 生成文件易读，production 则会开启代码压缩等等。 一些应用总体配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin'); // 导入html插件module.exports = &#123; mode: 'production', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'index.bundle.js', &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125;, &#123; test: /\\.sass/, use: ['style-loader', 'css-loader', 'sass-loader'], &#125;, &#123; test: /\\.(jpg|png|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; outputPath: 'img', name: '[hash:10].[ext]', &#125;, &#125;, ], &#125;, &#123; test: /\\.(csv|txt)$/, use: ['raw-loader'], &#125;, &#123; exclude: /\\.(html|js|css|jpg|png|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; outputPath: 'media', name: '[hash:10].[ext]', &#125;, &#125;, ], &#125;, ], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', &#125;), ], devServer: &#123; hot: true, compress: true, port: 9000, &#125;,&#125;; 学习过程中迷惑的点 在 js 文件中引入的 html 文件使用HTMlWebpackPlugin不需要在&lt;script&gt;&lt;link&gt;等标签中再引入 js 和 css。 一种情况： 1import someFile from './data/someFile'; 若使用file-loader，则 someFile 返回的是地址（网址+目录） 若使用raw-loader，则返回的是纯文本","categories":[{"name":"前端","slug":"前端","permalink":"https://mizarzh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"最近进展2021-9-4 moon3d","slug":"最近进展2021-9-4-moon3d","date":"2021-09-08T15:05:27.000Z","updated":"2021-09-10T17:05:56.360Z","comments":true,"path":"2021/09/08/最近进展2021-9-4-moon3d/","link":"","permalink":"https://mizarzh.github.io/2021/09/08/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952021-9-4-moon3d/","excerpt":"最近工作（moon-3d，2021-9-4）概括目的：模拟月球天平动和月相，即模拟月球在某个时间点的样子。 科学方向：月球天平动、NASA 科学程序（jpleph, de440, stellarium(st)源码） 技术栈：three.js, webGL, webpack 为主的一众打包工具, web 模块化 未来工作：canvas 视频渲染、科学视频、三维引擎学习 过程中遇到的具体阻碍：403 Forbidden","text":"最近工作（moon-3d，2021-9-4）概括目的：模拟月球天平动和月相，即模拟月球在某个时间点的样子。 科学方向：月球天平动、NASA 科学程序（jpleph, de440, stellarium(st)源码） 技术栈：three.js, webGL, webpack 为主的一众打包工具, web 模块化 未来工作：canvas 视频渲染、科学视频、三维引擎学习 过程中遇到的具体阻碍：403 Forbidden 1、数据获取天平动及月相数据获取首先有两种方法：力学模拟及直接使用数据。 前者显然是不可能的，力学模拟天平动考虑的因素和运算量远超个人的能力。因此接下来的工作都在致力于获取天平动的数据集。 在完全没有任何线索的情况下，我第一时间想到的就是 st 的源代码，因为 st 的模拟不可能没考虑天平动的影响，通过挖掘 st 源代码发现底层数据来源是 NASA 的jpleph 程序及 de441(de440)数据集。 下一个问题是如何生成数据。理论上可以直接通过 jpleph 的 api 直接生成数据，但需要通过 ftp 获取 jpleph(ftp://ssd.jpl.NASA.gov/pub/eph/planets/ascii/)，访问时总是 timeout。接下来尝试使用 python 的jplephem，却又因为文档不清晰的问题而放弃。最后无奈只能使用 NASA 提供的 web 界面horizons，虽然自定义参数少了许多，但至少好在方便易用。 仔细阅读horizons 文档并经历了好几次因找不到对应参数而碰壁的过程后，最终确定了一系列需要的参数（一些是展示和验证需要的参数，有三项是模拟必须的参数，用*号标出）： 时间。Date__(UT)__HR:MN（UT 时间）以及 L_Ap_SOL_Time（本地太阳时）。 月相相关参数，如被照亮面积百分比（Illu%）及月相角（S-T-O） *月下点经纬度（ObsSub-LON，ObsSub-LAT） *日照中心点经纬度（SunSub-LON，SunSub-LAT） *北极点位置（只需要其中的角度一个参数，NP.ang） 其他重要参数。星等 APmag，表面亮度 S-brt，距离 d 等等 在 horizons 中导出了这些数据的 csv 文件，保存备用。 其实在过程当中发现了 NASA 的一个页面：Moon Phase and Libration，在这里可以快速找到 2021 一整年的月相及天平动参数，后来发现和 jpleph 生成的参数如出一辙（其实本页下面引用就写着使用的是 jpleph 的数据），但好在 jpleph 的时间跨度和自定义程度远超这个页面，也不枉前面这么久的研究。 月球模型又是 NASA 的数据，不得不说 NASA 的科普做得真的好，我们什么时候才能赶上呢…… 来自 NASA 页面CGI Moon Kit，这里提供了各种分辨率的月球表面的图和月球高度图。 有了以上的数据，就可以开始思考使用什么技术栈实现模拟了。 2、技术选择实现的技术有很多： 类似 st 的确定太阳月球地球星体位置及各种数据后综合计算 类似 NASA 页面的直接进行三维模拟 对于这个项目来说，显然后者是更好的选择。 接下来就是技术栈的选择： 大型三维软件 unity，blender 等 openGL，使用 python, C++语言 webGL，使用浏览器的渲染 echarts、plotly 等及它们 python 的版本 对于这类科学数据可视化，进行编程的渲染大概率是最可靠的（其实是我不会用第一种的软件）。openGL 和 webGL 的引擎都是偏底层的（应该吧），并不利于快速实现。接下来我将目标转向了 echarts，发现的确是有类似的三维图例，但自由度不能达到项目的需求。最后选择第三种的原因是因为 three.js 库。 three.js是在 webGL 上层的一个库，比 webGL 更加高级一点。 3、编程实现这段过程就只讲一点点，其他详情直接看源代码。 坐标轴的确立/旋转方向的确定因为程序导入月球表面图的中心点是该图的左侧中心点，而 NASA 提供的表面图的经纬度原点是在该图的中心，导致导入后原点位置与预想并不相符。最后选择将摄影机移到经纬度为(0,0)的位置，但这样会导致坐标轴出现问题，因此可以看到 js 其中的一个程序： 12345return [ r * Math.cos(lat) * Math.cos(lon), r * Math.sin(lat), -r * Math.cos(lat) * Math.sin(lon),]; 有一个负号。 其实这个问题是刚上手 three.js 遇到的问题，现在一想直接将球转 90 度不就好了吗……。不过程序既定，就懒得改了。 旋转方向这个就是玄学问题了……。three.js 里面的 rotate 根本不知道绕着哪个轴转，只能通过实验确定。最后还闹了个笑话：北极点的旋转代码camera.rotateZ(-(rotateAng / 180) * Math.PI)之前是没有负号的，导致月球倾斜方向与正确的方向完全对称。差点就要因为严谨性问题被拉出去打了…… 打包说实话，对打包/前端工程化的概念在这个暑假才有确切的概念，曾经仅仅是学过而已。一开始选择的是 parcel，因为它的零配置可以让我在时间紧急的情况下（这个项目只用了两天做出来）快速得到编程结果。但到了后面这种简单性变成了累赘： parcel 的体积大到离谱。global 安装一次，本地安装一次，我的 C 盘直接就告急了。 到了后期，这种简单的无配置打包逐渐不能适应愈发增加的资源。如这个项目要用到的 png/csv 资源。 因此，最后全面倒向了 webpack。在前段时间学习的 webpack 也算是派上了用场。 nginx 403 Forbidden 及 gzip 压缩（没错，又是你 nginx）最后发现是需要将所有文件夹和文件都调成可读及可运行，之前是忘记调成可运行了。 对于 gzip 压缩，仅需 123456gzip_vary on;gzip_proxied any;gzip_comp_level 6;gzip_buffers 16 8k;gzip_http_version 1.1;gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript; 取消这一段的注释即可。 4、一点想法曾经的我还未被物理摧毁信心时，总会想着做一些数据驱动的科普小视频。这类视频没办法简单用 AE 做，因为 AE 的图像难以使用科学数据量化。 可视化编程则是没有什么思路，特别是三维。这个项目前我大概只知道 matplotlib 和 plotly 等一系列可视化项目，但 matplotlib 的三维简直垃圾，echarts 等可视化项目的包装程度太高了，有时候一些想法没办法做。 在这个项目后，确实是打开了思路。three.js/echarts/d3 等等优秀的前端可视化库也可以做到优秀的数据可视化。至于导出图片/视频的问题，因为 webGL 是渲染在 canvas 元素上，因此我们只需考虑如何导出 canvas 的数据即可。一些库如 node-canvas 和 CCapture.js 等就能做到。 当然，并不意味着 python 就一无是处了，有一些我以前不知道的优秀的 python3d 库也是很能胜任这个任务的，且 python 的科学库比 node 多得多，以后有机会也会去体验一下。","categories":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/categories/%E5%A4%A9%E6%96%87/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"wordpress初始配置及ip迁移","slug":"wordpress初始配置及ip迁移","date":"2021-01-10T12:54:39.000Z","updated":"2021-01-10T13:01:10.185Z","comments":true,"path":"2021/01/10/wordpress初始配置及ip迁移/","link":"","permalink":"https://mizarzh.github.io/2021/01/10/wordpress%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%8F%8Aip%E8%BF%81%E7%A7%BB/","excerpt":"初始配置2020-12-23这真的是大工程……简单说来，由于学生机服务器带宽过于拉跨，因此想使用学生机frp做内网穿透，使用raspberry作为wordpress服务器。wordpress中文官网此文章主要参考这个教程以及这个配置来操作。以下内容默认开启su","text":"初始配置2020-12-23这真的是大工程……简单说来，由于学生机服务器带宽过于拉跨，因此想使用学生机frp做内网穿透，使用raspberry作为wordpress服务器。wordpress中文官网此文章主要参考这个教程以及这个配置来操作。以下内容默认开启su 1、下载使用wget获取官网下载内容： 12wget https://cn.wordpress.org/latest-zh_CN.tar.gztar -zxvf latest-zh_CN.tar.gz 然后见到一大堆php文件，不要慌，先将文件夹中wp-config-sample.php复制一份并改名为wp-config.php。复制一份到/var/www/html或者其子文件夹处，这一份是被别人访问的。修改访问权限（不知道这步有没有用）： 1chown -R www-data:www-data /var/www/html 接下来整一些别的东西。 2、数据库wordpress是需要使用数据库的，我嫌弃mysql安装太麻烦而且不在apt中，改用mariadb，其用法与mysql基本一致。 123apt install mariadb-server #安装mysqladmin -u root password \"[enter your password here]\" #设置root密码mysql -u root -p #用root用户密码登录 123456# 以下是在mysql环境中操作CREATE DATABASE wordpress #创建新数据库wordpress# 这两句似乎是授予权限，但是感觉就在服务器本机做这个没什么必要GRANT ALL PRIVILEGES ON databasename.* TO \"wordpressusername\"@\"hostname\"FLUSH PRIVILEGES;EXIT; #退出 3、配置wp-config.php修改其中的内容： 1234567891011/** WordPress数据库的名称 */define( 'DB_NAME', 'database_name_here' );/** MySQL数据库用户名 */define( 'DB_USER', 'username_here' );/** MySQL数据库密码 */define( 'DB_PASSWORD', 'password_here' );/** MySQL主机 */define( 'DB_HOST', 'localhost' ); 这几句将之前创建的数据库数据填入即可 12345678define( 'AUTH_KEY', 'put your unique phrase here' );define( 'SECURE_AUTH_KEY', 'put your unique phrase here' );define( 'LOGGED_IN_KEY', 'put your unique phrase here' );define( 'NONCE_KEY', 'put your unique phrase here' );define( 'AUTH_SALT', 'put your unique phrase here' );define( 'SECURE_AUTH_SALT', 'put your unique phrase here' );define( 'LOGGED_IN_SALT', 'put your unique phrase here' );define( 'NONCE_SALT', 'put your unique phrase here' ); 填入随机数，在此处获取，直接复制进去就好了。填入后即完成配置 4、服务器配置（nginx）nginx代理这部分对于我这种新手来说做起来非常复杂（主要是由于php的原因），在网上也见到不下于三种对nginx的操作，这里选择了成功的一种讲。首先需要安装php相关服务： 1apt install php-fpm php-mysql 接下来修改nginx中的server block configuration部分： 1vim /etc/nginx/sites-available/default 在server出做出如下修改： 在index index.html那一行加上index.php 取消对location ~ .php$和location ~/.ht部分的注释，但注意location ~ .php 中只需要开启fastcgi_pass unix://那一条即可（记得匹配fpm版本号） nginx.conf就不需要修改了此步玩成了就算正式完成了wordpress的配置，打开nginx服务：1service nginx start 打开http://yourip/wp-login.php登陆使用gui配置就方便多啦。 ps：如果是放在/var/www/html的子文件夹处，如/var/www/html/blog，那么就需要在访问网址后加上这个名称，如http://yourip/wp-login.php/blog，或者将nginx配置中的root设为这个目录处。 5、frp配置放在有公网的学生机的frps配置： 123[common]bind_port = 7000vhost_http_port = 80 放在内网web服务的frpc配置： 1234567[common]server_addr = frp服务器ipserver_port = 7000[web]type = httplocal_port = 80custom_domains = frp服务器ip或服务器域名 使用nohup挂载在后台即可 ip迁移在宿舍迁回家，由于ip不同导致wordpress打开缓慢，这里写下解决方法以备不时之需。 暴力解决法在数据库中，修改以下几个表中的值： wp_options 直接将表中的option_value 字段中所有的老地址都替换成新地址 update wp_options set option_value = replace(option_value,’老地址’, ‘新地址’); wp_posts 修改guid字段和post_content字段，将其中的老ip替换为新IP wp_dtree_cache 在我的侧边栏菜单里，还需要修改一下这个表才能变过来： update wp_dtree_cache set content = replace(content, ‘老地址’, ‘新地址’); 12345UPDATE wp_options SET option_value = replace( option_value, 'http://www.old.com', 'http://www.new.com' ) WHERE option_name = 'home' OR option_name = 'siteurl';UPDATE wp_posts SET post_content = replace( post_content, 'http://www.old.com', 'http://www.new.com' ) ;UPDATE wp_posts SET guid = replace( guid, 'http://www.old.com', 'http://www.new.com' ) ; 在nginx中/etc/nginx/sites-available/default中修改地址为新地址 简单方法wp-login应该还是可以访问的。通过它进入管理界面，在设置中修改ip地址即可。","categories":[],"tags":[{"name":"备份","slug":"备份","permalink":"https://mizarzh.github.io/tags/%E5%A4%87%E4%BB%BD/"}]},{"title":"华工自动报平安脚本","slug":"华工自动报平安脚本","date":"2020-07-04T08:49:29.000Z","updated":"2020-07-04T09:44:24.334Z","comments":true,"path":"2020/07/04/华工自动报平安脚本/","link":"","permalink":"https://mizarzh.github.io/2020/07/04/%E5%8D%8E%E5%B7%A5%E8%87%AA%E5%8A%A8%E6%8A%A5%E5%B9%B3%E5%AE%89%E8%84%9A%E6%9C%AC/","excerpt":"","text":"github网址虽然离开学只有一个月了这个脚本估计也没什么用了233，但是研究这套系统对以后的自动化也是有帮助的。 研究历程：其实在五六月份的时候就已经开始想做这个脚本了。我以为只需要直接post账号和密码即可，但是发现是带加密的，当时又很菜不知道怎么搞定lt会更新的问题，于是便搁置了一段时间。但是在某日看到某位dalao在知乎发的贴子，突然就想到使用session保持状态即可（我太菜了）。登录的方法和知乎文章几乎一致。以下是过程： lt的值每次会话都会不一样。lt的值储存在页面&lt;input id=”lt”&gt;的控件中，因此需要使用get方法获取页面并得到lt值 接下来使用post登录，post需要传递的数据是rsa,ul,pl,lt,execution,_eventId。通过翻阅登录按钮的事件函数发现： ul、pl分别为账号和密码长度 rsa是由一个叫strEnc(u+p+lt,’1’,’2’,’3’)的函数算出来的 execution看不懂是什么，一般为e1s1，目测和url的长短有关 _eventId为固定值submit接下来要解决的问题是如何运行strEnc。首先将strEnc所在的des.js下载到本地，再通过pyExesJS的包运行js得到rsa，再由同一个session post即可完成登录验证。 接下来需要解决上报信息的问题。这里的表单比较长，建议不要自己填而是抓取网页中post的json下载到本地再加以改造。表单是报平安的各项数据，基本是固定值，但其中几个时间需要注意，不然可能时间冲突导致无法更新。键|值-|-“inHubeiToHubeiDate”| 固定为1580910916335“recordDate” “visitingRelativesOrTravelToWenzhouDate” “recordShowDate”| 每日0时的毫秒值“createTime” | 此页面创建时间的毫秒值，亲测可以使用当前时间代替“updateTime” | 当前时间的毫秒值 将这些时间数据更新后post即可 最后是每日定时执行脚本。使用python内部的sched的话需要一直运行python不太方便，于是转而使用系统的定时执行win系统为例： win + R，输入compmgmt.msc 打开任务计划程序栏，创建基本任务 输入名称和描述，设置每天某个时间点运行，操作为启动程序 最重要的一步：程序或脚本输入python.exe，添加参数为.py文件所在位置，起始于为python.exe的位置（添加到了PATH的话应该不需要填写这项）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://mizarzh.github.io/tags/python/"}]},{"title":"最近进展2020-6-3","slug":"最近进展2020-6-3","date":"2020-06-03T15:40:33.000Z","updated":"2020-06-04T15:17:07.277Z","comments":true,"path":"2020/06/03/最近进展2020-6-3/","link":"","permalink":"https://mizarzh.github.io/2020/06/03/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-6-3/","excerpt":"","text":"Nodejs服务器写了一个Tool-box，其中有下载视频的功能。原理是使用服务端的you-get识别下载网址的url从而得到下载地址，但却冒出一堆奇妙的bug。emm 起初的想法是用户端发送get/post到服务端，然后服务端调用you-get识别URL并将其返回，再由客户端开启下载。 首先解决要解决的问题是python的运行环境问题。对于我这种python渣渣来说，用了好一会才搞明白python（或者是anaconda吧）除了REPL还有命令行的直接运行环境（就是有一个base前面的）。使用you-get必须激活这个环境。12conda activate baseyou-get -u URL 然后是服务器的routing。用express并不难解决，但是后端功力仍需锻炼。 最后发现在下载bilibili时遇到了CORS不能跨域的问题（客户端无法调节referer，似乎使用xhr.setRequestHeader也无法设定access-control-allow-origin不过我觉得是我不会用），可能需要改用服务端下载并传输。然后发现无法调用下载的界面emmm，可能需要使用下载.js之类的组件。总之慢慢改善好了。 —6/4—access-control-allow-origin是使用在服务端的回应上的，客户端的Referer单纯用js无法伪造，这类的技术叫做防盗链。但是使用服务端可以伪造referer，因为可能需要将下载放在服务端了。bootstrap的使用还是比较正常的，就是在使用tab的时候使用flex结构会导致不能相互隐藏，可能是内部还要再套一层div吧。正在制作新主页。 计算机组成原理开始啃四大了233，计算机组成原理6/3到130页，继续加油。—6/4—计算机组成原理到170页，实在是太难刷了qwq。js算法也快读完了，接下来可以开始搞算(gua)法(ke)了。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"瞎折腾之frp","slug":"瞎折腾之frp","date":"2020-05-19T15:36:19.000Z","updated":"2020-05-20T15:48:48.653Z","comments":true,"path":"2020/05/19/瞎折腾之frp/","link":"","permalink":"https://mizarzh.github.io/2020/05/19/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8Bfrp/","excerpt":"众所周之frp是一款内网穿透工具，可以用来干很多神奇的事情。我使用frp也有很多种目的，接下来就慢慢细说。","text":"众所周之frp是一款内网穿透工具，可以用来干很多神奇的事情。我使用frp也有很多种目的，接下来就慢慢细说。 MC服务器在某个ddl成堆的晚上，某损友找上了我说要帮他整个MC服务器，并向我吹嘘它家的电脑多么强劲。我想着回头再帮他看看吧，最终碍于爱搞事情的本性愉快的放弃了一堆没做的东西开始折腾起怎么搭建mc服务器的事情。 其实搭建mc服务器本身并不难，在有一台云主机（没有公网ip也想整frp就别想了→_→）的情况下，第一反应就是在云主机上搭建mc服务器。我在之前的blog中已经写过mc服务器应该如何搭建了，但是这孱弱的性能怕撑不起这么多人，加上他吹嘘他家的电脑，我决定使用本地主机搭建服务器+内网穿透的方法搭建多人mc服务器。 首先先下载frp。frps是frp的服务器，应放置在有公网ip的服务器上（这里指的是孱弱服务器）。使用scp传文件到服务器上frpc是frp的客户端，应放置在要暴露服务的机器上（这里指的是损友电脑）。 接下来在服务端配置frps.ini： 12[common]bind_port = // 其他机器访问的端口 客户端frpc.ini的配置: 12345678[common]server_addr = // 服务器的地址server_port = // frps.ini中的bind_port[minecraft]type = tcplocal_ip = 127.0.0.1 // 本地local_port = 25565 // mc开启的端口remote_port = 25565 都配置好之后就在命令行中分别运行 12./frps./frpc 同时开启mc服务器，在其他机器上输入连接frpc.ini中的server_addr:server_port即可开始游戏。","categories":[{"name":"日常","slug":"日常","permalink":"https://mizarzh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"瞎折腾之家庭服务器","slug":"瞎折腾之家庭服务器","date":"2020-05-19T15:36:02.000Z","updated":"2020-05-21T05:55:16.372Z","comments":true,"path":"2020/05/19/瞎折腾之家庭服务器/","link":"","permalink":"https://mizarzh.github.io/2020/05/19/%E7%9E%8E%E6%8A%98%E8%85%BE%E4%B9%8B%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"自从上大学换了新电脑以后，家里的这台没啥电脑知识的我爸在电脑城买的联想傻大黑粗配置还不怎么样的旧笔记本就闲置在家多月。前几个月疫情肆虐，待在家里使用内网的需求也大大提升，于是这台旧电脑就被我改造成了家庭内网服务器。","text":"自从上大学换了新电脑以后，家里的这台没啥电脑知识的我爸在电脑城买的联想傻大黑粗配置还不怎么样的旧笔记本就闲置在家多月。前几个月疫情肆虐，待在家里使用内网的需求也大大提升，于是这台旧电脑就被我改造成了家庭内网服务器。 VNC viewer由于旧电脑存了太多的黑历史，一时半会还整理不完全，于是没有办法装linux系统。众所周知win的cmd是个废柴，因此决定使用VNC来远程操控服务器。 去到VNC的官网下载Windows版本的Server，在一系列操作后就装好了VNC Server。新电脑装上VNC Client就可以访问服务器电脑了。 Plex在家庭服务器上部署plex媒体服务，然后就可以在其他设备上自由浏览家庭服务器上的视频资源了。 去Plex下载处下载windows server，也是和VNC一样简单易用。再给电视装上Plex的应用就可以直接访问服务器的视频资源而不是用蠢到要死的自带资源了。 初级文件管理及分享使用windows的鸡肋分享功能做了个简易的文件分享。不得不说windows的配置和用户管理让我摸不着头脑。首先是文件夹右键-属性-共享-共享…，然后在下拉框内选择Everyone并添加。这还没完，还需要在高级共享…勾选共享此文件夹，并在权限内添加everyone的读取/写入权限，才能算完全开启文件夹的共享功能。这一套下来就搞不懂用户的用处以及为什么要分两个共享……，之前有一段时间似乎是想明白有什么区别，但是现在又搞不清楚了。anyway，总之共享上能用，没有什么问题了。然后android手机安装文件管理器app，就可以远程访问服务器内的资源了。只不过访问必须要使用anonymous访问，不然不管输入什么用户名什么密码都无法连接。 aria2","categories":[{"name":"日常","slug":"日常","permalink":"https://mizarzh.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"nodejs入门笔记","slug":"nodejs入门笔记","date":"2020-05-19T14:54:13.000Z","updated":"2020-05-19T16:31:27.955Z","comments":true,"path":"2020/05/19/nodejs入门笔记/","link":"","permalink":"https://mizarzh.github.io/2020/05/19/nodejs%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"nodejs入门笔记","text":"nodejs入门笔记 全局对象 globalprocess属性提供了一个与操作系统的简单接口 process.argv是命令行参数数组 process.stdout是标准输出流。stdout.write()更加底层 process.stdin是标准输入流。初始被暂停，要读取必须恢复流：1process.stdin.resume(); process.nextTick(callback)的功能是为事件循环设置一项任务，Node.js 会在下次事件循环调响应时调用 callback。 console用于向标准输出流（stdout）或标准错误流（stderr）输出字符 log() error() trace(),向标准错误流输出当前的调用栈。 常用工具 util inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。 还有isArray(),isRegExp(),isDate(),isError(),format(),debug() 事件驱动 events EventEmitter事件发射器。123456var events = require('events');var emitter = new events.EventEmitter();emitter.on('aEvent',function(arg1,arg2)&#123; //dosomething();&#125;)emitter.emit('aEvent',arg1,arg2) EventEmitter.on(event, listener) 为指定事件注册一个监听器EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件EventEmitter.once(event, listener) 为指定事件注册一个单次监听器EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器。EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。 error事件1emitter.emit('error'); 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它fs readFile(filename,[encoding],[callback(err,data)])或readFile(filename,[callback(err,data)])同步版本readFileSync(filename, [encoding]) open(path, flags, [mode], [callback(err, fd)])flags:r r+ w w+ a a+mode:用于创建文件时给文件指定权限fd:文件描述符。是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引 read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])write同理 httpHTTP 服务器1234567var http = require('http');http.createServer(function (req,res)&#123; res.writeHead('200',&#123;'Content-Type':'text/html'&#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end('&lt;p&gt;test&lt;/p&gt;');&#125;).listen(3000);console.log('http server is listening at port 3000'); http.createServer 创建了一个 http.Server 的实例 http.Server 的事件 request:当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是 http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。 connection:当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为 net.Socket 的实例。 close:当服务器关闭时，该事件被触发。除此之外还有 checkContinue、upgrade、clientError 事件createServer（创建一个 HTTP 服务器并将requestListener 作为 request 事件的监听函数）拆开写法：123456789var server = new http.Server(); // 新建http.Server实例// 在服务器收到请求时的事件响应server.on('request', function (req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end('&lt;p&gt;Hello World&lt;/p&gt;');&#125;);// 指定服务器监听端口server.listen(3000); http.ServerRequest事件 data:当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。 end:当请求体数据传输完成时，该事件被触发 close： 用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。 属性complete 客户端请求是否已经发送完成httpVersion,method,url,headers,trailers,connection,socket,client 获取GET内容使用url模块中的parse解析url参数，生成一个对象 获取POST内容12345678910111213var querystring = require('querystring'); http.createServer(function (req, res) &#123; var post = ''; // 侦测POST传入的data事件并记录 req.on('data', function (chunk) &#123; post += chunk; &#125;); // 检测传入是否结束 req.on('end', function () &#123; post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000); http.ServerResponse返回给客户端的信息 writeHead(statusCode, [headers])：向请求的客户端发送响应头。 write(data, [encoding])：向请求的客户端发送响应内容。 end([data], [encoding])：结束响应，必须被调用一次。 HTTP 客户端http.request(options, callback) 发起 HTTP 请求。options: 1234567&#123; host : 127.0.0.1, // 请求网站的ip地址 port : 3000, // 请求网站的端口 method : 'get', //请求方法 path : //相对于根的路径，应该包括queryString headers : //请求头的内容&#125; callback 传递一个参数，为 http.ClientResponse 的实例。http.request 返回一个 http.ClientRequest 的实例。 http.get(options, callback),自动将请求方法设为了 GET 请求，同时不需要手动调用req.end()。 http.ClientRequest它提供一个 response 事件提供了 write 和 end 函 数，用于向服务器发送请求体request.abort()：终止正在发送的请求。request.setTimeout(timeout, [callback])：设置请求超时时间request.setNoDelay([noDelay])、request.setSocketKeepAlive ([enable], [initialDelay]) http.ClientResponse事件 data、end 和 closeresponse.setEncoding([encoding])：设置默认的编码response.pause()：暂停接收数据和发送事件response.resume()：从暂停的状态中恢复","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://mizarzh.github.io/tags/nodejs/"}]},{"title":"最近进展2020-5-10","slug":"最近进展2020-5-10","date":"2020-05-10T15:17:07.000Z","updated":"2020-05-11T11:11:28.234Z","comments":true,"path":"2020/05/10/最近进展2020-5-10/","link":"","permalink":"https://mizarzh.github.io/2020/05/10/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-5-10/","excerpt":"科学动画","text":"科学动画 5-10有两种类型的图片：1、类似于js中canvas和python中matplotlib的位图2、类似于svg或操作html DOM元素的矢量图 使用js做动画本来想使用canvas或anime.js做动画，但碍于一些原因（比如不能生成图片），甚至不如python直接画 使用python做动画本来想使用matplotlib.animation做动画，但是发现ffmpeg的配置有问题（即使将ffmpeg放到PATH或者使用pip和conda安装ffmpeg都不行）。于是就使用最原始的方法：生成图片再使用ffmpeg合成视频 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import matplotlib.pyplot as pltimport numpy as npimport scipy as sciimport mathimport randoma = 100b = 90c = math.sqrt(abs(a**2 - b ** 2))theta = []x = []y = []color = ['red','blue','green']SMI_max = 2 * c#ellipsefor i in np.linspace(0 , math.pi * 2, 300): x.append(a * math.cos(i)) y.append(b * math.sin(i)) line = np.linspace(-b,b,100)#for theta in np.linespace(0, math.pi * 2, 10000)#知道theta的情况def calc(theta): SMI = (math.sqrt((a+c)**2 - (c * math.sin(theta))**2) - c * math.cos(theta) - \\ math.sqrt((a * math.cos(theta))**2 + (b * math.sin(theta))**2)) / (2 * c) return SMIplt.figure(figsize=[6,6],dpi = 300)count = 0for theta in np.linspace(0, math.pi * 8, 300): ax = plt.gca() ax.set_aspect(1) plt.axis('off') plt.plot(x,y,c='C1',zorder=0) for i in range(0,99): plt.plot([120,120],[line[i],line[i+1]],c = color[i % 3],zorder=0) plt.scatter(-c,0,s = 100) plt.scatter(a * math.cos(theta),b * math.sin(theta),zorder = 1, c='gray',s=10) plt.scatter(120,calc(theta) * 2 * b - b,zorder = 1,c='purple',s=10) plt.savefig('pictures2/' + str(count) + '.jpg') plt.clf() count += 1 然后就在pictures2中生成了300张图片，再使用ffmpeg： 1ffmpeg -i %d.jpg -r 25 output.mp4 -r指fps 5-11将右侧坐标变为渐变色：plot是不能直接使用渐变色的，因此这里使用scatter强行画出渐变色 1234567891011121314# 渐变颜色cmap_i = np.linspace(-b, b, 100)plt.scatter([110]*100, cmap_i, zorder=0,c=cmap_i, cmap=plt.get_cmap('cool'),marker='s',s=5)# 标注plt.plot([109, 111], [-b, -b], zorder=0, c='black')plt.plot([109, 111], [b, b], zorder=0, c='black')plt.plot([109, 111], [0, 0], zorder=0, c='black')plt.plot([109, 111], [b/2, b/2], zorder=0, c='black')plt.plot([109, 111], [-b/2, -b/2], zorder=0, c='black')plt.text(112, -b - 2, '0%', fontsize=8)plt.text(112, b - 2, '100%', fontsize=8)plt.text(112, -2, '50%', fontsize=8)plt.text(112, b/2 - 2, '75%', fontsize=8)plt.text(112, -b/2 - 2, '25%', fontsize=8) 去除图片周围空白： 1plt.savefig('pictures3/' + str(count) + '.png', bbox_inches='tight') 每次打开生成图片使用clf()清理后，循环内使用的就是一个新的figure，其他图片设置中的设置就不会起作用。如果将plt.figure放到循环内，就会因为生成太多figure而出错原代码： 1234567plt.figure(figsize=[6, 6], dpi=300)for theta in np.linspace(0, 8 * math.pi, 300): #其他图片设置 #作图 plt.clf() 使用plt.close()就可以真正的清理掉一个figure修改后： 1234567for theta in np.linspace(0, 8 * math.pi, 300): plt.figure(figsize=[6, 6], dpi=300) #其他图片设置 #作图 plt.close() 生成图片后，使用PIL放入月球和地球的图片。接下来就遇到了最难受的坐标转化问题。一开始月球和点之间总是差一点点距离，后来强行乘了一个系数后便正常了 123456789101112131415161718192021moon = Image.open('moon.png').resize([50, 50])earth = Image.open('earth.png').resize([500, 500])im = Image.open('pictures3/0.png')arg = 0.96centerX = im.size[0] / 2centerY = im.size[1] / 2c_c = c / figlen / 2 * im.size[0] * argimc = 0for theta in np.linspace(0, 8 * math.pi, 300): im = Image.open('pictures3/' + str(imc) + '.png') c_x = a * math.cos(theta) / figlen / 2 * im.size[0] * arg c_y = b * math.sin(theta) / figlen / 2 * im.size[1] * arg layer = Image.new('RGBA', im.size, (0, 0, 0, 0)) layer.paste( earth, (int(centerX - c_c - earth.size[0] / 2), int(centerY - earth.size[1] / 2))) layer.paste(moon, (int(centerX + c_x - moon.size[0] / 2), int(centerY - c_y - moon.size[1] / 2))) out = Image.composite(layer, im, layer) out.save('output/' + str(imc) + '.png', 'PNG') imc += 1 最终效果： （未完待续）","categories":[{"name":"杂项","slug":"杂项","permalink":"https://mizarzh.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"js的读取文本与跨网页","slug":"js的读取文本与跨网页","date":"2020-04-24T15:23:20.000Z","updated":"2020-04-24T15:40:00.927Z","comments":true,"path":"2020/04/24/js的读取文本与跨网页/","link":"","permalink":"https://mizarzh.github.io/2020/04/24/js%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8E%E8%B7%A8%E7%BD%91%E9%A1%B5/","excerpt":"这两天闲来无事，写了两个和展示文字相关的页面，其中遇到了读取文本与跨网页通信的问题。","text":"这两天闲来无事，写了两个和展示文字相关的页面，其中遇到了读取文本与跨网页通信的问题。 文件操作js中直接读取和处理本地的文件是很困难的（除非nodejs），这种事情还是交给python比较好但是可以手动上传文件从而达到读取的目的。使用HTML5的新功能。首先使用\\ 从而获得文件。 选择文件后可以通过inputDOM.files获取文件的FileList，再通过数组访问则可以得到文件（但是不能直接显示内容）1234567inputDOM = document.querySelector(input[type=file])inputDOM.files // FileListfile = inputDOM.files[0]file.name //文件名file.size //文件大小file.webkitRelativePath //路径file.type //文件类型使用FileReader来读取文件中的内容。123var fReader = new FileReader()fReader.readAsText(file) //读取文件fReader.result //显示文本内容FileReader有四种打开方式，我们这里只用到了readAsText。 跨网页通信跨域通信可以直接使用XHR，不在这里的讨论范围。使用H5的新功能localStorage：12localStorage.setItem('name','value') //设置本地储存值localStorage.removeItem('name') //移除本地储存值这样在两个不同的网页也可以读取相同的本地存储另一种方法（H5之前）是使用Cookie。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"最近进展2020-4-9","slug":"最近进展2020-4-9","date":"2020-04-09T03:50:15.000Z","updated":"2020-04-25T15:36:48.205Z","comments":true,"path":"2020/04/09/最近进展2020-4-9/","link":"","permalink":"https://mizarzh.github.io/2020/04/09/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-9/","excerpt":"wincmd脚本ffmpeg1ffmpeg -ss 00:00:00 -t 00:00:03.000 -i \"x.wav\" -filter_complex afade=t=out:st=1:d=2 \"y.wav\" -filter_complex afade=t=out:st=1:d=2 代表从1s开始淡出，持续2s","text":"wincmd脚本ffmpeg1ffmpeg -ss 00:00:00 -t 00:00:03.000 -i \"x.wav\" -filter_complex afade=t=out:st=1:d=2 \"y.wav\" -filter_complex afade=t=out:st=1:d=2 代表从1s开始淡出，持续2s js文件读取界面机理html&lt;audio&gt; 的使用 python 月球项目首先调用astropy的solar_system_ephemeris.set(‘jpl’)，从jpl处下载数据然后使用astropy.coordinates中的get_moon()和get_sun()函数获取日月的RA、DEC、distance先找到满月的第一个点，然后取下一次时间时增加一个朔望月周期，并在其周围(-1.2,1.2,0.1)进行校正，矫正次数记录在err.txt，因此这种计算的误差为+-0.05d 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from astropy import units as ufrom astropy.time import Timeimport numpy as npfrom astropy.coordinates import solar_system_ephemerisfrom astropy.coordinates import get_moon, get_sunx = open('datafull.txt', 'w')y = open('datanew.txt', 'w')z = open('err.txt', 'w')jds = Time('1900-01-15T19:12:00.000', format='isot', scale='tdb').jdjds2 = Time('1900-01-01T14:24:00.000', format='isot', scale='tdb').jdjde = Time('2100-01-01T00:00:00', format='isot', scale='tdb').jd # 2488069.5circle = 29.53059 #一个朔望月周期h = True #进度条相关m = (jde + jds)/2 #进度条相关def diff(ra1, ra2): dra = abs(ra1-ra2) if dra &gt; 180: dra = 360 - dra return drafor i in np.arange(jds, jde, circle): largest = 0 #最大RA距离 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i &gt; m and h): print('half1') h = False z.write('--------------\\n') for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format='jd', scale='tdb') #在朔望月周期附近微调 moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra &gt; largest): #判断是否为最大 largest = dra #最大RA距离 dis = moon.distance.value #最大RA距离时距离 time = t #最大RA距离时时间 errcount += 1 z.write(str(errcount)) z.write('\\n') x.write(time.iso + ' ') x.write(str(time.jd) + ' ') x.write(str(dis)) x.write('\\n')print('end1')h = Truem = (jde + jds2)/2x.close()z.write('++++++++++++++++++++++++++\\n')for i in np.arange(jds2, jde, circle): smallest = 180 errcount = 0#计算矫正次数（最大24次），大于24次说明有问题 if(i &gt; m and h): print('half2') h = False z.write('--------------\\n') for j in np.arange(-1.2, 1.2, 0.1): t = Time(i+j, format='jd', scale='tdb') moon = get_moon(t) sun = get_sun(t) dra = diff(moon.ra.value, sun.ra.value) if(dra &lt; smallest): smallest = dra dis = moon.distance.value time = t errcount += 1 z.write(str(errcount)) z.write('\\n') y.write(time.iso + ' ') y.write(str(time.jd) + ' ') y.write(str(dis)) y.write('\\n')print('end2')y.close()z.close() 文件读取： 123x = open('xxx','r') #有很多选项x.read()x.readlines() csv: 1234567891011with open('xxx.csv','r') as f freader = csv.reader(f) for row in freader: #... fdreader = csv.DictReader(f) #读字典with open('xxx.csv','w',newline='') as f #newline = ''是为了防止每次写完之后都换行 fwriter = csv.writer(f) fwriter.writerow([xx,xx,xx]) fdwriter = csv.DictWriter(f) #写字典 json: 123import jsonjson.dumps(某个数据结构) #将某个数据结构转化为jsonj = json.loads(某json) #将json转化为python内置数据结构 从香港天文台获取数据，使用爬虫： 123456789101112131415161718192021222324from urllib.request import urlopenfrom urllib.request import Requestimport time#for i in range(0,100):maping = &#123;&#125;file = open('s2l.txt','a')url = 'https://www.hko.gov.hk/tc/gts/time/calendar/text/files/'headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0\", \"Accept\": 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'&#125;for i in range(0,200): fileName = 'T' + str(1901 + i) +'c.txt' req = Request(url = url + fileName,headers = headers) x = urlopen(req) fulltext = x.read().decode('Big5') fulllist = fulltext.split('\\n')[3:-1] for j in range(0,len(fulllist)): file.write(fulllist[j] + '\\n') print(i) time.sleep(1)file.close() 后续将尝试转化农历和公历","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"最近进展2020-4-2","slug":"最近进展2020-4-2","date":"2020-04-02T15:39:38.000Z","updated":"2020-04-14T11:26:50.011Z","comments":true,"path":"2020/04/02/最近进展2020-4-2/","link":"","permalink":"https://mizarzh.github.io/2020/04/02/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-4-2/","excerpt":"1、写了一个网页前端练习website","text":"1、写了一个网页前端练习website 2、配置服务器Jupyter notebook 3、学习爬虫4、事件相关某同学的一个网页，写一个js脚本，重复点击四（五）个按钮。 首先找出每个按钮（button）的定位，这里使用document.querySelector()定位 1234var x = document.querySelector(str[0]);var button = [\".call-to-action\",\".buyButton\",\".ut-button-group:first-child\",\"ut-navigation-button-control\"]; 接下来调试，发现无法使用x.click()点击按钮。使用浏览器查看事件发现使用了mousedown和mouseup确定点击事件修改代码： 1234567891011function handler(str)&#123; var x = document.querySelector(str); var down = document.createEvent(\"MouseEvents\"); down.initMouseEvent(\"mousedown\", true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\"MouseEvents\"); up.initMouseEvent(\"mouseup\", true, true, document.defaultView); x.dispatchEvent(up);&#125;var button = [\".call-to-action\",\".buyButton\",\".ut-button-group:first-child\",\"ut-navigation-button-control\"]; 再令其每隔一段时间点击一次按钮，则： 12345while(true)&#123; for(let i = 0;i &lt; button.length;++i)&#123; setTimeout(handler(button[i]),1000); &#125;&#125; 发现setTimeout好像并不是很符合要求（似乎是因为setTimeout并不会真的等待一段时间才执行下一个循环，而是生成四个setTimeout进程）。于是改用了setInterval，并增加了一些东西： 12345678910111213141516171819202122232425var button = ['.increment-value',\".call-to-action\",\".buyButton\",'section.Dialog .ut-button-group button',\".ut-navigation-button-control\"];var i = button.length - 1;var count = 0;var id;function handler()&#123; loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\"MouseEvents\"); down.initMouseEvent(\"mousedown\", true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\"MouseEvents\"); up.initMouseEvent(\"mouseup\", true, true, document.defaultView); x.dispatchEvent(up);&#125;function loop_i()&#123; ++count; if(i === button.length - 1) i = 0; else ++i; if(count &gt;= 500)&#123; clearInterval(id) &#125;&#125;id = setInterval(handler,5000); （所有代码，以后可能会增加try catch块） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var button = ['.increment-value',\".call-to-action\",\".buyButton\",'section.Dialog .ut-button-group button',\".ut-navigation-button-control\"];var input = document.querySelector('.numericInput');var i = button.length - 1;var count = 0;var id;function doer(ci = i)&#123; var x = document.querySelector(button[ci]); var down = document.createEvent(\"MouseEvents\"); down.initMouseEvent(\"mousedown\", true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\"MouseEvents\"); up.initMouseEvent(\"mouseup\", true, true, document.defaultView); x.dispatchEvent(up);&#125;function handler()&#123; try&#123; loop_i(); doer(); &#125; catch(e)&#123; if(e instanceof TypeError)&#123; console.error(\"TypeError\"); i = 0; doer(4); &#125; else&#123; console.error(\"UnknownError\"); i = 0; doer(4); &#125; &#125; &#125;function loop_i()&#123; ++count; if(i === button.length - 1) i = 0; else ++i; if(count &gt;= 20)&#123; input.value = 0; &#125;&#125;id = setInterval(handler,5000);clearInterval(id) 加入try catch块 1234567891011121314151617181920212223242526272829303132var button = ['.increment-value',\".call-to-action\",\".buyButton\",'section.Dialog .ut-button-group button',\".ut-navigation-button-control\"];var i = button.length - 1;var clear = document.querySelector('.flat.camel-case');var count = 0;var id;function handler()&#123; loop_i(); var x = document.querySelector(button[i]); var down = document.createEvent(\"MouseEvents\"); down.initMouseEvent(\"mousedown\", true, true, document.defaultView); x.dispatchEvent(down); var up = document.createEvent(\"MouseEvents\"); up.initMouseEvent(\"mouseup\", true, true, document.defaultView); x.dispatchEvent(up);&#125;function loop_i()&#123; ++count; if(i === button.length - 1) i = 0; else ++i; if(count &gt;= 5)&#123; var down = document.createEvent(\"MouseEvents\"); down.initMouseEvent(\"mousedown\", true, true, document.defaultView); clear.dispatchEvent(down); var up = document.createEvent(\"MouseEvents\"); up.initMouseEvent(\"mouseup\", true, true, document.defaultView); clear.dispatchEvent(up); count = 0; &#125;&#125;id = setInterval(handler,5000); 另一种解法","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"jupyter notebook配置","slug":"jupyter-notebook配置","date":"2020-03-25T09:01:13.000Z","updated":"2020-04-01T15:45:44.816Z","comments":true,"path":"2020/03/25/jupyter-notebook配置/","link":"","permalink":"https://mizarzh.github.io/2020/03/25/jupyter-notebook%E9%85%8D%E7%BD%AE/","excerpt":"远端jupyter notebook的配置","text":"远端jupyter notebook的配置 python下载这里使用anaconda 12wget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh./Anaconda3-2020.02-Linux-x86_64.sh 并一直yes，安装anaconda jupyter notebook配置12conda jupyter notebook #anaconda安装jupyter notebookjupyter notebook --generate-config #生成配置文件 配置文件为.jupyter/jupyter_notebook_config.py 打开IPython，产生密码： 12In [1]: from notebook.auth import passwdIn [2]: passwd() 接下来就会让你输入密码，输入密码后就会生成一个’sha1:xxx’的东西，复制它。 1vim .jupyter/jupyter_notebook_config.py 修改以下选项（可以使用vim ‘/‘的搜索功能）： 1234c.NotebookApp.ip='*' #可以由所有ip访问jupyter notebookc.NotebookApp.password = 'sha:xx' #刚刚复制的东西c.NotebookApp.open_browser = False #启动不打开浏览器c.NotebookApp.port =8888 #使用的端口 启动： 1jupyter notebook 或者后台一直启动： 1nohup jupyter notebook&amp; 使用插件12conda install -c conda-forge jupyter_contrib_nbextensionsjupyter contrib nbextension install --user 然后在header处就能见到多一个nbextensions选项卡，进入里面选择所需的插件即可","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://mizarzh.github.io/tags/python/"}]},{"title":"名著短评","slug":"名著赏析","date":"2020-03-16T15:12:57.000Z","updated":"2020-06-04T15:42:16.974Z","comments":true,"path":"2020/03/16/名著赏析/","link":"","permalink":"https://mizarzh.github.io/2020/03/16/%E5%90%8D%E8%91%97%E8%B5%8F%E6%9E%90/","excerpt":"一个文学渣的瞎唠嗑","text":"一个文学渣的瞎唠嗑 《雪国》[日]川端康成创作于1935-1948年 自己的想法：这的确是一本非常晦涩难懂的书。驹子对岛村的感情表达地十分晦涩（当然在岛村每次到雪国时感情都会深入，但书中没有明说），而岛村对她的感想则是全书的核心：“徒劳”。岛村认为驹子的生活是徒劳的，也能在书中读出来驹子平日生活（忍不住打扫）、待人（为了行男和养家而做艺妓）的辛苦。结尾最后很短的篇幅爆发，虽然结尾很难读懂就是了…… 参考资料后：岛村追求的是一种虚幻的美丽（虚无主义）。他热衷于写舞蹈的文章，却不去追求真正的舞蹈；他对叶子映在车窗上的倒影入迷，却对驹子注重现实生活而感到徒劳。他觉得现实生活中的一切东西都是“徒劳”的，去做也没有什么用。叶子暗喻了驹子的精神。叶子对驹子的责怪就是驹子对自己的责怪；叶子对驹子的嫉妒就是驹子对自己的嫉妒；叶子对岛村的爱慕就是驹子对岛村的爱慕。而最后叶子在火灾中死去，驹子失去了精神，便是结尾处的“疯掉了”。展现了作者的一些看法：死的唯美意境，虚无与悲观。 《雷雨》曹禺1934年7月发表，背景在1925年前后受某人推荐，同时因为在教科书中有出现过所以感觉挺有意思的，就决定开始看了。 自己的想法：如果不考虑什么文学性和时代背景的话，剧情可以说算是很狗血了233。当然评判这一部冲突性极强的戏剧单纯考虑男欢女爱的情节是不合适的。文章主要围绕着当时贫苦人民和资本家之间的矛盾与冲突，非常生动的展示了当时的社会大环境——资本家毫无同情心的剥削普通民众，普通人民苦不堪言；男权（不知道作者有没有这方面的想法了）主导，女性成为附庸。在这个背景下，许多人的关系交织。鲁家有没文化的鲁贵频频向资本家低头不肯斗争，有涉世未深的四凤还未看出资本家的邪恶，也有鲁侍萍、鲁大海坚决与资本家势不两立（但是反抗程度有所不同）；周家有象征着当时资本家的周朴园，有在周朴园压迫下的蘩漪，有儒弱的周萍，也有作为地主和资本家的儿子但却关心鲁家的周冲。路人也有在吃到甜头后就不再反抗的工人。人物代表了当时各种态度的人，性格丰富，冲突也十分激烈，着实精彩（就是情节是有点狗血233）。虽然我并不是很认同将这部作品强加在工人阶级觉醒之类的上面（不然鲁大海的下场也不会是这样了，但显然语文课本就是这么做的），但是可以确定这部作品绝对是有对于资本家和大地主对普通人民各种手段的剥削和压制的严厉的批判的。 参考资料后（直接抄百度）：《雷雨》所展示的是一幕人生大悲剧，是不平等的社会里，命运对人残忍的捉弄。周朴园的专制、冷酷和伪善；周冲的热情和单纯；以及蘩漪对爱情的深挚乃至略显变态的执着；痛悔着罪孽却又不自知地犯下更大罪孽的软弱的周萍；被侮辱的被捉弄的悲苦的鲁妈……还有家庭的秘密，身世的秘密，所有这一切在一个雷雨夜爆发。最后，有错的、有罪的，无错的、无辜的人，竟然一起走向了毁灭。它讲述了资产阶级周家和城市平民鲁家两个家庭纠结复杂的悲剧故事。一是以周朴园为代表的带有浓厚封建色彩的资产阶级家庭的生活悲剧：二是以鲁妈为代表的城市平民不能把握自己命运、被别人所操控的悲惨境遇。而周、鲁两家复杂的血缘联系，更是突出、生动地反映了两个不同阶层的家庭之间的矛盾。揭露了旧中国旧家庭的种种黑暗现象以及地主资产阶级的专横、冷酷与伪善，反映了中国20世纪二、三十年代正在酝酿着一场大变动的社会现实，对受压迫者给予了深切的同情。","categories":[{"name":"文学","slug":"文学","permalink":"https://mizarzh.github.io/categories/%E6%96%87%E5%AD%A6/"}],"tags":[{"name":"文学","slug":"文学","permalink":"https://mizarzh.github.io/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"工作日志(C 2019 Y4 comet)","slug":"工作日志1","date":"2020-02-28T09:57:43.000Z","updated":"2020-03-30T11:54:14.517Z","comments":true,"path":"2020/02/28/工作日志1/","link":"","permalink":"https://mizarzh.github.io/2020/02/28/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%971/","excerpt":"思路：模型：$$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$ 其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离","text":"思路：模型：$$m=V(1,0)+5\\lg{\\frac{r\\Delta}{a^2}}-2.5\\lg{\\Phi(\\alpha)}$$ 其中m为视星等，V(1,0)为绝对星等，r为该星体距离太阳的距离，$\\Delta$为该星体距离地球的距离 轨道计算：先计算出椭圆轨道的参数，再映射到实际轨道当中 数据Orbital elements: C/2019 Y4 (ATLAS)Epoch 2020 May 31.0 TT = JDT 2459000.5T 2020 May 30.99149 TT Bellq 0.2522871 (2000.0) P Qz +0.0052736 Peri. 177.54315 +0.48067371 +0.62763038 +/-0.0005749 Node 120.47328 -0.81617007 +0.57558163e 0.9986695 Incl. 45.27974 -0.32065433 -0.52420025From 171 observations 2019 Dec. 28-2020 Jan. 9, mean residual 0”.4. e (eccentricity) : 0.9991890q (perihelion distance) : 0.2529910i (inclination) : 45.39050Ω (Longitude of ascending node) : 120.57800ω (Argument of perihelion) : 177.39850L (Longitude of perihelion) : 118.75041B (Latitude of perihelion) : 1.85172T (Time of perihelion passage) : 2459000.54440P (Orbital period in years) : 5509.68Epoch : 2020 Feb 27Family/Group: : Nearly isotropic 02 January 2020 00:00 UTC Element Symbol Value Orbit eccentricity e 0.99871621 Orbit inclination i 45.31898912&deg; Perihelion distance q 0.25306404 AU37,857,841 km Aphelion distance Q 393.99356831 AU58,940,599,007 km Semi-major axis a 197.12331617 AU29,489,228,424 km Orbital period period 2,767.6800 years1,010,893.5413 days Date of perihelion transit Tp 2020-May-31 02:27:302,459,000.6024 JD Argument of perihelion peri 177.46987924671&deg; Longitude of the ascending node node 120.51143626815&deg; Mean anomaly M 359.94690155178&deg; Mean motion n 0.00035612&deg;/day 轨道根数：– semimajor axis a,– eccentricity e,– inclination i (or ι),– longitude of the ascending node Ω,– argument of the perihelion ω,– time of the perihelion τ.(或者true anomaly或者mean anomaly) 作图三维图：mplot3d 1234567891011from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as npax1 = plt.axes(projection=\"3d\")ax1.set_xlim3d(-lim,lim)ax1.set_ylim3d(-lim,lim)ax1.set_zlim3d(-lim,lim)ax1.plot3D(x,y,z)plt.show() 在jupyter notebook上： 123%matplotlib notebookax1.mouse_init() #使用鼠标操控ax1.view_init(elev=number, azim=number) #调整视角 交互式plotly 天文相关poliastro问题：使用Orbit.from_classical时的ecc过大，导致数据精度不足（或者是使得运行时间过长），但是使用直接绘图就没有这个问题poliastro astropy 1234from astropy import units as ufrom astropy.coordinates import CartesianRepresentationu.deg u.one u.km u.AU #单位CartesianRepresentation.x.value #带单位转化为值 astropy 目前状况（2020-03-16）爆肝到两点emm之前某个时间也强行写了很久 结构：轨道运算、画图、Mk计算轨道运算：poliastro库导入轨道后再导出数据使用近日点的true anomaly和mean anomaly都为0的方法规避这个库只能输入true anomaly的缺点（使用t代替，然后再使用propagation()确定相应的时间） 1234567891011121314151617181920212223242526272829time2 = \"2020-05-31T00:51:39\"t2 = Time(time2, format='isot', scale='tdb')se = Orbit.from_body_ephem(Earth,t2)sc = Orbit.from_classical(Sun,a,ecc,inc,raan,argp,0 * u.deg,t2)setemp = Orbit.from_classical(Sun,se.a,se.ecc,se.inc,se.raan,se.argp,se.nu,t2) #鬼知道我遇到了什么，必须再导入时间才能正常orbnc = [[],[],[]] #comet[[xs],[ys],[zs]]orbne = [[],[],[]] #earthfor x in np.linspace(-60 * u.day,60 * u.day,120): #-60 - 60 天 orbnctemp = sc.propagate(x) #x为astropy.unit的时间，用来计算经过某段时间后的轨道 pn1 = orbnctemp.represent_as(CartesianRepresentation) #表示为xyz轴 orbnc[0].append(pn1.x.value) orbnc[1].append(-pn1.y.value) orbnc[2].append(-pn1.z.value) xc = pn1.x.value / (1.5 * 10**8) #转化为AU yc = pn1.y.value / (1.5 * 10**8) zc = pn1.z.value / (1.5 * 10**8) orbnetemp = setemp.propagate(x) pn2 = orbnetemp.represent_as(CartesianRepresentation) orbne[0].append(pn2.x.value) orbne[1].append(-pn2.y.value) orbne[2].append(-pn2.z.value) xe = pn2.x.value / (1.5 * 10**8) ye = pn2.y.value / (1.5 * 10**8) ze = pn2.z.value / (1.5 * 10**8) r.append(math.sqrt(xc**2+yc**2+zc**2)) d.append(math.sqrt((xe-xc)**2+(ye-yc)**2+(ze-zc)**2)) #计算 m = M + 5lgd + klgr 的参数r,d 最小二乘： 123456789101112131415161718192021222324252627#此处lgr lgd m已输入数据A = np.vstack([lgr, np.ones(len(lgr))]).Tnp.linalg.lstsq(A,m - 5 * lgd,rcond=None) #输出[[斜率，截距],[方差],xx,xx]plt.scatter(lgr,m - 5 * lgd) #观察离散程度M = 3.94k = 25y1 = []y2 = []for x in np.linspace(0,119,120): x = int(x) #此处使用 m - 5lgd = klgr + M 进行最小二乘拟合 y1.append(M + 5 * math.log10(d[x]) + k * math.log10(r[x])) y2.append(12 + 5 * math.log10(d[x]) + 10 * math.log10(r[x]))x = np.linspace(-60,61,120)plt.figure(figsize = [6,4],dpi=150) #设置图的大小plt.xlabel('days from perihelion')plt.ylabel('magnitude')plt.title('picutre')plt.plot(x,y1,color=\"blue\")plt.plot(x,y2,color=\"red\")plt.ylim(max([max(y1),max(y2)])+1,min([min(y1),min(y2)])-1) #奇妙的做法，为了翻转y轴，想使用plt.gca().invert_yaxis()但不起作用，于是使用ylim反转上下限plt.savefig(\"figure.jpg\") #保存图片plt.show() 目前状况（2020-03-17）解决plt绘图重复的问题（前面分开，后面合并，连着直接绘制会出现问题）（可能是和figure()相关的问题）plt.grid()plt.legend()的配置plt.subplotlinewidthmatplotlib的documentation:matplotlib 重构了代码，更多地使用数组储存数据 双曲线a为负数Time(2439054.6837, format=’jd’,scale=’tdb’) #JD时间 poliastro.twobody.propagation.propagate相关：可以由orbit.propagate()调用，其中第一个参数为经过的时间，第二个参数为求解的方法（mean_motion,kepler,cowell），返回经过时间后的轨道 下一步：研究python的封装（函数、库、class之类）下一步：自写轨道库 matplotlib颜色映射（默认颜色）np.arange([start,],stop,[step]) 目前状况（2020-03-19）plt.xticks([array])x轴的刻度标记（如[1,2,3,4,5]，则刻度显示出来的就是12345）xticks系列大概都是用来设置轴的刻度标记的吧plt.xtickslabel([array])使用string设置x轴刻度 plt.axis([xlim,-xlim,ylim,-ylim])相当于设置plt.xlim和plt.ylim","categories":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/categories/%E5%A4%A9%E6%96%87/"}],"tags":[{"name":"天文","slug":"天文","permalink":"https://mizarzh.github.io/tags/%E5%A4%A9%E6%96%87/"}]},{"title":"最近进展2020-2-19","slug":"最近进展2020-2-19","date":"2020-02-19T04:42:14.000Z","updated":"2020-02-23T13:02:19.933Z","comments":true,"path":"2020/02/19/最近进展2020-2-19/","link":"","permalink":"https://mizarzh.github.io/2020/02/19/%E6%9C%80%E8%BF%91%E8%BF%9B%E5%B1%952020-2-19/","excerpt":"推箱子pushbox过于羞耻.jpg","text":"推箱子pushbox过于羞耻.jpg HTML与CSS知识相关这次使用的是外层创建div并限定长度、窗口居中（margin : auto），内部嵌套float:left的元素应该有更高效的（absolute+计算坐标），但还没搞清楚盒式模型 js文件过程js的调用并不是一次性的，可以使用函数重复调用（文件只可以进行一次，但是函数可以进行多次） 事件监听事件的监听是并行的，前面定义了click，后面定义了keydown，并不会停留在监听的函数中。（另外的问题：每个对象的监听是否只能有一个） 全局变量在window定义变量，再用window.xxx调用全局变量 数组嵌套对象concat(),slice(0)对一维数组有效数组中如果嵌套了对象，那么concat()、slice(0))也会对数组中的东西产生影响，换句话说就是没有进行深复制。这里应该深入对作用链的理解 混乱不堪的代码 运动系统过于复杂 或许可以换种架构，不需要每次移动都更新全部的DOM 全局变量和局部变量纠缠不清 贪吃蛇Greedy-Snake-js 随机数使用Math.random()生成[0-1)的一个数，配合Math.floor()食用更佳 数组判断相等数组的判断无法直接使用===号如果是较简单的数组可以使用Array.toString()方法比较。嵌套且长短不一的数组可能就需要单独比较了 深复制假设一个对象/数组a需要深复制，可使用JSON进行转化 1copy = JSON.parse(JSON.stringify(a)); 方法对于数组与对象的方法不熟悉（例如迭代等） 全局变量这次使用了对象包裹的方法定义全局变量，应该是稍微科学一点了也使用了ES6的let及const，更好的控制变量范围 throwthrow错误之后程序将停止运行","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记13","slug":"js高设笔记13","date":"2020-02-12T10:28:18.992Z","updated":"2020-02-14T09:54:07.142Z","comments":true,"path":"2020/02/12/js高设笔记13/","link":"","permalink":"https://mizarzh.github.io/2020/02/12/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B013/","excerpt":"13事件js与HTML之间的交互是通过事件实现的可以使用侦听器（或处理程序）来预订事件 13.1事件流13.1.1事件冒泡即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 13.1.2事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 13.1.3DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。","text":"13事件js与HTML之间的交互是通过事件实现的可以使用侦听器（或处理程序）来预订事件 13.1事件流13.1.1事件冒泡即事件开始时由具体的元素（文档中嵌套层次深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档） 13.1.2事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而具体的节点应该后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 13.1.3DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 13.2事件处理程序而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以”on”开头 13.2.1HTML事件处理程序属性onclick=”javascript代码” 12//前面定义了showMessage()&lt;input type=\"button\" value=\"ClickMe\" onclick=\"showMessage()\"/&gt; 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象在这个函数内部，this值等于事件的目标元素在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员。 很多HTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面 13.2.2DOM0级事件处理程序每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。 1234varbtn=document.getElementById(\"myBtn\");btn.onclick=function()&#123;alert(\"Clicked\");&#125;; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行也可以删除通过DOM0级方法指定的事件处理程序，将onclick属性设为null即可。 13.2.3DOM2级事件处理程序addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法。它们都接受3个参数：要处理的事件名（意味着没有on前缀）、作为事件处理程序的函数和一个布尔值。这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。 13.2.4IE事件处理程序过时了吧emm 13.2.5跨浏览器的事件处理程序IE、DOM2、DOM0三种方法创建，创建为一个EventUtil的对象。 13.3事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。 13.3.1DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。 event属性：见书355页其中两个属性：currentTarget：其事件处理程序当前正在处理事件的那个元素target：事件的目标this始终等于currentTarget的值要阻止特定事件的默认行为，可以使用preventDefault()方法。只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则event-Phase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。 13.3.2IE中的事件对象过时了吧 13.3.3跨浏览器的事件对象13.4事件类型 UI（UserInterface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为IME（InputMethodEditor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层DOM结构发生变化时触发。 13.4.1UI事件详细见书362DOMActivate,(un)load,abort,error,select,resize,scroll除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件 13.4.2焦点事件blur,focus,focusin,focusout 13.4.3鼠标与滚轮事件click,dblclick,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup 鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的clientX和clientY属性中，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，坐标是从页面本身而非视口的左边和顶边计算的。在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。 DOM规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。 对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。但对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的按钮。DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠标按钮（鼠标滚轮按钮），2表示次鼠标按钮。在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。 “DOM2级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。 当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel 事件。与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。Firefox支持一个名为 DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。与 mousewheel 事件一样，DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。而有关鼠标滚轮的信息则保存在 detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是-3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是 3 的倍数 触摸设备： 不支持 dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。 轻击可单击元素会触发 mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生； 如果屏幕没有因此变化，那么会依次发生 mousedown、mouseup 和 click 事件。 轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 onclick 事件处理程序的元素。 mousemove 事件也会触发 mouseover 和 mouseout 事件。 两个手指放在屏幕上且页面随手指移动而滚动时会触发 mousewheel 和 scroll 事件。 13.4.4 键盘与文本事件keydown,keypress,keyup前两者如果按住不放的话，会重复触发此事件。只有一个文本事件：textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。 在发生 keydown 和 keyup 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同。表见P380 IE9、Firefox、Chrome 和 Safari的 event 对象都支持一个 charCode 属性，这个属性只有在发生 keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的 ASCII 编码。此时的 keyCode 通常等于0或者也可能等于所按键的键码 DOM3级变化：不再包含 charCode 属性，而是包含两个新属性：key 和 char。 key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时，key 的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key 的值是相应键的名（如“Shift” 或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。不同浏览器有不同实现 DOM3级事件还添加了一个名为 location 的属性，这是一个数值，表示按下了什么位置上的键： 0表示默认键盘，1表示左侧位置（例如左位的 Alt键），2表示右侧位置（例如右侧的 Shift键），3表示 数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂 Wii控制器）。 后是给 event 对象添加了 getModifierState()方法。这个方法接收一个参数，即等于 Shift、Control、AltGraph 或 Meta 的字符串，表示要检测的修改键。 “DOM3级事件”规范中引入了一个新事件，名叫 textInput。根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。由于 textInput 事件主要考虑的是字符，因此它的 event 对象中还包含一个 data 属性，这个属性的值就是用户输入的字符（而非字符编码）。event 对象上还有一个属性，叫 inputMethod，表示把文本输入到文本框中的方式。 （值见P383） 13.4.5 复合事件复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。compositionstart,compositionupdate,compositionend 13.4.6 变动事件DOM2级的变动（mutation）事件能在 DOM中的某一部分发生变化时给出提示。DOMSubtreeModified,DOMNodeInserted,DOMNodeRemoved,DOMNodeInsertedIntoDocument,DOMNodeRemovedFromDocument,DOMAttrModified,DOMCharacterDataModified 13.4.7 HTML5事件 contextmenu 事件：上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单 beforeunload 事件：是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件的意图是将离开页面的控制权交给用户。 DOMContentLoaded 事件：在形成完整的 DOM树之后就会触发，不理会图像、JavaScript 文件、CSS文件或其他资源是否已经下载完毕。 readystatechange 事件：这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。 pageshow 和 pagehide 事件：这个事件在页面显示时触发，无论该页面是否来自 bfcache（来自bfcache的页面不会有load事件）。 hashchange 事件：在 URL的参数列表（及 URL中“#”号后面的所有字符串）发生变化时通知开发人员。 13.4.8 设备事件 orientationchange 事件 MozOrientation 事件 deviceorientation 事件 devicemotion 事件 13.4.9 触摸与手势事件 触摸事件 手势事件 13.5 内存和性能在 JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。 13.5.1 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。 1234567891011121314151617var list = document.getElementById(\"myLinks\"); EventUtil.addHandler(list, \"click\", function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case \"doSomething\": document.title = \"I changed the document's title\"; break; case \"goSomewhere\": location.href = \"http://www.wrox.com\"; break; case \"sayHi\": alert(\"hi\"); break; &#125; &#125;); //而不是三个对象分别设置不同的方法 这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress 13.5.2 移除事件处理程序内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成 Web 应用程序内存与性能问题的主要原因。直接移除元素（removeChild())好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。 13.6 模拟事件13.6.1 DOM中的事件模拟document 对象上使用 createEvent()方法创建 event 对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在 DOM2 级中，所有这些字符串都使用英文复数形式，而在 DOM3级中都变成了单数。 UIEvents：一般化的 UI事件。鼠标事件和键盘事件都继承自 UI事件。DOM3级中是 UIEvent。 MouseEvents：一般化的鼠标事件。DOM3级中是 MouseEvent。 MutationEvents：一般化的 DOM变动事件。DOM3级中是 MutationEvent。 HTMLEvents：一般化的 HTML事件。没有对应的 DOM3级事件（HTML事件被分散到其他类别中）。 传入参数见书","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记10","slug":"js高设笔记10","date":"2020-02-11T08:11:37.000Z","updated":"2020-02-16T14:49:02.266Z","comments":true,"path":"2020/02/11/js高设笔记10/","link":"","permalink":"https://mizarzh.github.io/2020/02/11/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B010/","excerpt":"10 DOMDOM（文档对象模型）是针对 HTML和 XML文档的一个 API 10.1 节点层次DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。&lt;html&gt; 文档元素文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。","text":"10 DOMDOM（文档对象模型）是针对 HTML和 XML文档的一个 API 10.1 节点层次DOM可以将任何 HTML 或 XML文档描绘成一个由多层节点构成的结构。&lt;html&gt; 文档元素文档元素是文档的外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。 10.1.1 Node类型DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现，JavaScript中的所有节点类型都继承自 Node 类型。每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12个数值常量来表示Node.ELEMENT_NODE(1)；Node.ATTRIBUTE_NODE(2)；Node.TEXT_NODE(3)；Node.CDATA_SECTION_NODE(4)；Node.ENTITY_REFERENCE_NODE(5)；Node.ENTITY_NODE(6)；Node.PROCESSING_INSTRUCTION_NODE(7)；Node.COMMENT_NODE(8)；Node.DOCUMENT_NODE(9)；Node.DOCUMENT_TYPE_NODE(10)；Node.DOCUMENT_FRAGMENT_NODE(11)；Node.NOTATION_NODE(12)。 nodeName 和 nodeValue：对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。 每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组对象（类似但不是Array），用于保存一组有序的节点，可以通过位置来访问这些节点。访问NodeList可通过方括号，也可以使用 item()方法转化为数组（或者手动循环）： 1var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0); 每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中后一个节点的 nextSibling 属性的值同样也为 null。父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和后一个节点。 hasChildNodes()方法 所有节点都有的后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。 appendChild()，用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点及以前的后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild() 返回新增的节点。 insertBefore() 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作 replaceChild() 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。 removeChild() 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。 并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。 cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制（复制节点及其整个子节点树，浅复制只复制节点本身）。副本没有指定父节点。 normalize()，这个方法唯一的作用就是处理文档树中的文本节点。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。 10.1.2 Document类型JavaScript通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。 nodeType 的值为 9； nodeName 的值为”#document”； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null；其子节点可能是一个 DocumentType（多一个）、Element（多一个）、ProcessingInstruction 或 Comment。 documentElement 属性，该属性始终指向HTML页面中的元素。document 对象还有一个 body 属性，直接指向元素。Document 另一个可能的子节点是 DocumentType。通常将&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype）来访问它的信息。 不同浏览器支持情况不同出现在元素外部的注释的引用不同浏览器的支持程度不同。 document.title：通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变&lt;title&gt;元素URL、domain 和 referrer。只有 domain 是可以设置的。但由于安全方面的限制，也并非可以给 domain 设置任何值。 getElementById()和getElementsByTagName()。前者id不存在返回null，id特性（attribute）严格匹配，包括大小写。后者返回的是包含零或多个元素的 NodeList。在 HTML文档中，这个方法会返回一个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name 特性取得集合中的项。（方括号访问亦可）后者可传入*，代表全部 虽然标准规定标签名需要区分大小写，但为了最大限度地与既有 HTML 页面兼容，传给 getElementsByTagName()的标签名是不需要区分大小写的。但对于 XML 页面而言（包括 XHTML），getElementsByTagName()方法就会区分大小写。 只有 HTMLDocument 类型才有的方法，是 getElementsByName()。顾名思义，这个方法会返回带有给定 name 特性的所有元素。 特殊集合：anchors(&lt;a name=”xxx”&gt;),forms(&lt;form&gt;),images(&lt;img&gt;),links(&lt;a href=”xxx”&gt;) document.implementation 属性为浏览器实现了DOM的哪些部分提供相应信息和功能的对象，其中的方法hasFeature()接受两个参数：要检测的 DOM功能的名称及版本号。若支持返回true。 write()、writeln()、open()和 close() 1234document.write(\"&lt;strong&gt;\" + (new Date()).toString() + \"&lt;/strong&gt;\");//载入外部脚本document.write(\"&lt;script type=\\\"text/javascript\\\" src=\\\"file.js\\\"&gt;\" + \"&lt;\\/script&gt;\"); 如果在文档加载结束后再调用 document.write()，那么输出的内容将会重写整个页面 10.1.3 Element类型 nodeType 的值为 1； nodeName 的值为元素的标签名； nodeValue 的值为 null； parentNode 可能是 Document 或 Element； 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。 HTML元素 id，元素在文档中的唯一标识符。 title，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang，元素内容的语言代码，很少使用。 dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），也很少使用。 className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为 class 是 ECMAScript的保留字 所有 HTML元素都是由 HTMLElement 或者其更具体的子类型来表示的。getAttribute()、setAttribute()和 removeAttribute()三个方法。最前者的返回可能会有差异1 返回的 style 特性值中包含的是 CSS文本，直接访问则是对象，2 事件处理程序。当在元素上使用时，onclick 特性中包含的是 JavaScript 代码，如果通过 getAttribute()访问，则会返回相应代码的字符串。通常不使用getAttribute() setAttribute()通过这个方法设置的特性名会被统一转换为小写形式，即”ID”终会变成”id” 根据 HTML5规范，自定义特性应该加上 data-前缀以便验证。 Element 的attributes 属性中包含一个 NamedNodeMap，与 NodeList 类似，也是一个“动态”的集合。元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象拥有下列方法。 getNamedItem(name)：返回 nodeName 属性等于 name 的节点； removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos)：返回位于数字 pos 位置处的节点。 attributes 属性中包含一系列节点，每个节点的 nodeName 就是特性的名称。节点的 nodeValue 就是特性的值。removeNamedItem()返回表示被删除特性的 Attr 节点，removeAttribute()不返回attributes属性一般用于遍历元素属性返回属性的顺序不一定相同 每个特性节点都有一个名为 specified 的属性，这个属性的值如果为 true，则意味着要么是在 HTML中指定了相应特性，要么是通过 setAttribute()方法设置了该特性。 document.createElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。返回一个 DOM元素的引用 12345&lt;ul id=\"myList\"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; 返回后会有7个元素，包括3个li元素和4个空白符（li之间）可以通过nodeType的判断消除空白符 10.1.4 Text类型 nodeType 的值为 3； nodeName 的值为”#text”； nodeValue 的值为节点所包含的文本； parentNode 是一个 Element； 不支持（没有）子节点。 操作文本的方法： appendData(text)：将 text 添加到节点的末尾。 deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset+ count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。文本节点还有一个 length 属性，保存着节点中字符的数目。每个可以包含内容的元素多只能有一个文本节点，而且必须确实有内容存在。 document.createTextNode()创建新文本节点 normalize()浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行 DOM操作的结果出现。splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 parentNode 相同。 10.1.5 Comment类型 nodeType 的值为 8； nodeName 的值为”#comment”； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element； 不支持（没有）子节点。 其他有CDATASection类型，DocumentType类型 ，DocumentFragment类型 ，Attr类型 DOM操作技术（待续）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记8","slug":"js高设笔记8","date":"2020-02-10T05:24:43.000Z","updated":"2020-02-11T07:32:20.082Z","comments":true,"path":"2020/02/10/js高设笔记8/","link":"","permalink":"https://mizarzh.github.io/2020/02/10/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B08/","excerpt":"BOMBOM（浏览器对象模型） 8.1 window 对象BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。","text":"BOMBOM（浏览器对象模型） 8.1 window 对象BOM的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，它既是通过 JavaScript访问浏览器窗口的一个接口，又是 ECMAScript规定的 Global 对象。 8.1.1 全局作用域全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。 12345var age = 29; window.color = \"red\"; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false delete window.age; //在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true delete window.color; //returns true 使用 var 语句添加的 window 属性的[[Configurable]]特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除通过查询 window 对象，可以知道某个可能未声明的变量是否存在。 8.1.2 窗口关系及框架页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。 123window.frames[0] window.frames[\"name属性\"]top.frames[0] top对象始终指向高（外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。与 top 相对的另一个 window 对象是 parent。顾名思义，parent（父）对象始终指向当前框架的直接上层框架。 除非高层窗口是通过 window.open()打开的（本章后面将会讨论），否则其 window 对象的 name 属性不会包含任何值。self始终指向 window；实际上，self 和 window 对象可以互 换使用。引入 self 对象的目的只是为了与 top 和 parent 对象对应起来这些对象都为window的属性，可通过window.xxx访问对象名|指向-|-top|始终指向高（外）层的框架parent|始终指向当前框架的直接上层框架self|始终指向 window 在使用框架的情况下，浏览器中会存在多个 Global 对象。在每个框架中定义的全局变量会自动成为框架中 window 对象的属性。由于每个 window 对象都包含原生 类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。 8.1.3 窗口位置screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。screenX 和 screenY各浏览器间实现不同 使用moveTo() 和 moveBy() 方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，moveTo()接收的是新位置的 x和 y坐标值，而 moveBy()接收的是在水平和垂直方向上移动的像素数。另外，这两个方法都不适用于框架，只能对外层的 window 对象使用。 8.1.4 窗口大小innerWidth、innerHeight、outerWidth 和 outerHeightouterWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从外层的 window 对象还是从某个框架访问）innerWidth 和innerHeight 则表示该容器中页面视图区的大小（减去边框宽度）。不同浏览器代表不同。 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息 对于移动设备，window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。 resizeTo()和 resizeBy()方法可以调整浏览器窗口的大小 8.1.5 导航和打开窗口window.open()方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示（如top=100，注意，整个特性字符串中不允许出现空格）调用 close()方法还可以关闭新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但仅能用类似alert的方法检测closed参数了 新创建的 window 对象有一个 opener 属性，其中保存着打开它的原始窗口对象。虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口 将 opener 属性设置为 null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。 浏览器扩展或其他程序阻止的弹出窗口，那么 window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open()的调用封装在一个try-catch 块中 8.1.6 间歇调用和超时调用JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。 前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。超时调用需要使用 window 对象的 setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。第一个参数可以是一个包含 JavaScript代码的字符串（就和在 eval()函数中使用的字符串一样），也可以是一个函数。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。（一般用匿名函数）第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个 参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。调用 setTimeout()之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 clearTimeout()方法并将相应的超时调用 ID作为参数传递给它。 间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 setInterval()取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。 123456789101112var num = 0; var max = 10; //使用递归方法function incrementNumber() &#123; num++; //如果执行次数未达到 max 设定的值，则设置另一次超时调用 if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert(\"Done\"); &#125; &#125; setTimeout(incrementNumber, 500); 一般认为，使用超时调用来模拟间歇调用的是一种佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，好不要使用间歇调用。 8.1.7 系统对话框alert()、confirm()和 prompt()为了确定用户是单击了 OK还是 Cancel，可以检查 confirm()方法返回的布尔值：true 表示单击了 OK，false 表示单击了 Cancel或单击了右上角的 X按钮。 prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK和 Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。如果用户单击了OK按钮，则 prompt()返回文本输入域的值；如果用户单击了 Cancel或没有单击 OK而是通过其他方式关闭了对话框，则该方法返回 null。 find() 查找 和 print() 打印 方法 8.2 location对象location它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。是window对象的属性，也是document的属性。属性 8.2.1 查询字符串参数location.search 返回从问号到 URL末尾的所有内容可以新建函数获取?后面的参数 decodeURIComponent()解码URL 8.2.2 位置操作location 对象可以通过很多方式来改变浏览器的位置。使用assign()方法改变window.location或者location.href会调用assgin()方法每次修改 location 的属性（hash 除外），页面都会以新 URL重新加载。要禁用生成记录行为，应使用replace()方法，不能回到前一个页面reload()，作用是重新加载当前显示的页面。传入参数true，则强制从服务器重新加载数据，而不传入则可能从缓存中加载。 8.3 navigator 对象navigator对象属性见书P200-201 8.3.1 检测插件plugins属性 name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME类型数量。因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。plugins 集合有一个名叫 refresh()的方法，用于刷新 plugins 以反映最新安装的插件。 8.3.2 注册处理程序registerContentHandler()和registerProtocolHandler()这两个方法可以让一个站点指明它可以处理特定类型的信息。前者接收参数：要处理的 MIME类型、可以处理该 MIME 类型的页面的 URL以及应用程序的名称。后者接收参数：要处理的协议（例如，mailto 或 ftp）、处理该协议的页面的 URL和应用程序的名称。 12navigator.registerContentHandler(\"application/rss+xml\", \"http://www.somereader.com?feed=%s\",\"Some Reader\"); //%s代表RSS源URL 8.4 screen 对象用处不大用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息书中P214 8.5 history 对象go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置近。如果历史记录中不包含该字符串，那么这个方法什么也不做还可以使用两个简写方法 back()和 forward()来代替 go()。history 对象有一个 length 属性，保存着历史记录的数量。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记7","slug":"js高设笔记7","date":"2020-02-10T04:17:39.000Z","updated":"2020-02-11T07:32:19.270Z","comments":true,"path":"2020/02/10/js高设笔记7/","link":"","permalink":"https://mizarzh.github.io/2020/02/10/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B07/","excerpt":"7 函数表达式7.1 递归使用argument.callee严格模式下，可使用命名函数表达式来达成相同的结果 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125; &#125;); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。","text":"7 函数表达式7.1 递归使用argument.callee严格模式下，可使用命名函数表达式来达成相同的结果 1234567var factorial = (function f(num)&#123; if (num &lt;= 1)&#123; return 1; &#125; else &#123; return num * f(num-1); &#125; &#125;); 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。 7.2 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125; &#125;; &#125; 在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记6","slug":"js高设笔记6","date":"2020-02-07T10:14:42.000Z","updated":"2020-02-09T15:31:37.514Z","comments":true,"path":"2020/02/07/js高设笔记6/","link":"","permalink":"https://mizarzh.github.io/2020/02/07/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B06/","excerpt":"6 面向对象的程序设计（注意：js中的面向对象实现与C++中不同） 6.1 理解对象1234567891011121314151617var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\"; person.sayName = function()&#123; alert(this.name); &#125;; var person = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125; &#125;;","text":"6 面向对象的程序设计（注意：js中的面向对象实现与C++中不同） 6.1 理解对象1234567891011121314151617var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\"; person.sayName = function()&#123; alert(this.name); &#125;; var person = &#123; name: \"Nicholas\", age: 29, job: \"Software Engineer\", sayName: function()&#123; alert(this.name); &#125; &#125;; 6.1.1 属性类型数据属性ECMA-262第 5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。 实现 JavaScript引擎用的，因此在 JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。 [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认的特性，必须使用 ECMAScript 5的Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。 12345var person = &#123;&#125;; Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\" &#125;); 这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。 把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。 访问器属性访问器属性不包含数据值；它们包含一对 getter和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter函数并传入新值，这个函数负责决定如何处理数据。 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特 性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这 个特性的默认值为 true。 [[Get]]：在读取属性时调用的函数。默认值为 undefined。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。 1234567891011121314151617var book = &#123; _year: 2004, edition: 1 &#125;; Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;); book.year = 2005; alert(book.edition); //2 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。只指定 getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。 6.1.2 多个属性123456789101112131415161718192021var book = &#123;&#125;; Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125; &#125;); 6.1.3 读取属性的特性Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述 符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。 123456789var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); alert(descriptor.value); //2004 alert(descriptor.configurable); //falsealert(typeof descriptor.get); //\"undefined\" var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value); //undefined alert(descriptor.enumerable); //false alert(typeof descriptor.get); //\"function\" 6.2 创建对象6.2.1 工厂模式123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\"); var person2 = createPerson(\"Greg\", 27, \"Doctor\"); 6.2.2 构造函数模式12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\"); 构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。使用了函数就是对象的想法，将属性添加到this上。 两个对象都有一个 constructor（构造函数）属性，该属性指向 Person。 若Person不使用new，则认为是在为window添加属性可使用call将作用域限定为某个对象 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。不同实例上的同名函数是不相等的。 6.2.3 原型模式解决构造函数的方法不相等问题。prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 12345678function Person()&#123;&#125; Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; 在此，我们将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。 原型对象的理解：只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。 Person 的每个实例—— person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与构造函数没有直接的关系。所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。 in操作符单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 1\"name\" in person1; ECMAScript 5也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5的 Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames() 方法。 更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象: 123456789function Person()&#123; &#125; Person.prototype = &#123; name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125; &#125;; 有一个例外：constructor 属性不再指向 Person 了，指向Object如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。可用defineproperty重设回来。 1constructor : Person, 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。如果是重写整个原型对象，实例中的指针仅指向原来的原型，而不指向构造函数。调用构造函数时会为实例添加一个指向初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与初原型之间的联系。总结：先定义原型再创建实例，不然实例指向的是原prototype 问题它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。共享，有时候需要分离的属性因此不经常单独使用 6.2.4 组合使用构造函数模式和原型模式123456789101112function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; &#125; Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125; &#125; 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，大限度地节省了内存。 是目前在 ECMAScript中使用广泛、认同度高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 6.2.5 动态原型模式(理解？)它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。 123456789101112function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125; &#125; 6.2.6 寄生构造函数模式寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。 12345678910function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; 除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。 首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。我们建议在可以使用其他模式的情况下，不要使用这种模式。 6.2.7 稳妥构造函数模式稳妥对象（durable objects）。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 123456789101112function Person(name, age, job)&#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function()&#123; alert(name); &#125;; //返回对象 return o; &#125; 除了使用 sayName()方法之外，没有其他办法访问 name 的值。 6.3 继承继承分为接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ECMAScript使用实现继承。通过原型链实现 6.3.1 原型链其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 123456789101112131415function SuperType()&#123; this.property = true; &#125;SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125;; function SubType()&#123; this.subproperty = false; &#125; //继承了 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function ()&#123; return this.subproperty; &#125;; var instance = new SubType(); alert(instance.getSuperValue()); //true instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，后一步才会找到该方法。 最上层的原型链继承自Object，因此也可以使用Object的方法。 使用instanceof/isPrototypeof()对原型链上的对象进行比较都会返回true 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。 即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链 问题1 SubType 的所有实例都会共享属性。2 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 6.3.2 借用构造函数在子类型构造函数的内部调用超类型构造函数。通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数 1234567function SuperType()&#123; this.colors = [\"red\", \"blue\", \"green\"]; &#125; function SubType()&#123; //继承了 SuperType SuperType.call(this); &#125; 两者没有关系如果SuperType可以传递参数，则使用call()方法也可传递参数问题：方法都在构造函数中定义，无法复用函数。 6.3.3 组合继承组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 过程：先定义supertype的属性，再定义subtype的私有属性，再定义原型链。js中最常用的继承模式 6.3.4 原型式继承12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; 进行浅复制，复制后仍指向原来的对象（共享属性） ECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。 6.3.5 寄生式继承1234567function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象 &#125; 6.3.6 寄生组合式继承组合继承大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。|不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。 12345function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象 &#125; 在定义完supertype和subtype之后调用此函数，则完成了继承。 总结[[xxx]]当作是属性的属性，则可理解defineProperty和defineProperties的写法，以及getOwnPropertyDescripter指向的东西模式：[[Prototype]]实例所有，指向该实例的构造函数的原型对象prototype为构造函数所有，指向该构造函数的原型对象constructor实例所有，指向构造函数 工厂模式 createPerson() + return 构造函数模式 Person() + new 原型模式 Person()的对象名prototype含有的属性Person.prototype.xxx 上面两个组合 动态原型 寄生构造函数、稳妥构造函数 继承： 原型链。subType的prototype指向superType的实例，则逻辑：subType为superType的一个实例 -&gt; subType拥有[[Prototype]]属性，且指向构造函数superType的原型对象superType.prototype -&gt; 原型链构造完成，可以寻找到superType.prototype的属性 借用构造函数：在subType内使用call()或apply()构建superType属性的深复制。 上面两者组合 原型式继承 寄生式继承 寄生组合式继承","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高设笔记5","slug":"js高设笔记5","date":"2020-02-07T10:13:27.000Z","updated":"2020-02-09T14:05:19.957Z","comments":true,"path":"2020/02/07/js高设笔记5/","link":"","permalink":"https://mizarzh.github.io/2020/02/07/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B05/","excerpt":"5 引用类型引用类型是一种结构。 5.1 Object类型创造实例的两种方法：1、new+构造函数2、对象字面量 12345678910var person = new Object();person.name = \"Nicholas\";person.age = 29;var person = &#123; name : \"Nicholas\", age : 29&#125;;var person = &#123;&#125;; //相当于new Object()","text":"5 引用类型引用类型是一种结构。 5.1 Object类型创造实例的两种方法：1、new+构造函数2、对象字面量 12345678910var person = new Object();person.name = \"Nicholas\";person.age = 29;var person = &#123; name : \"Nicholas\", age : 29&#125;;var person = &#123;&#125;; //相当于new Object() 属性名可以使用字符串（包括字符串数字）。使用对象字面量定义对象不会调用Object()构造函数 访问方法：person[“name”]或person.name除非必须通过方括号法表示，否则用点表示法 5.2 Array每一项可保存不同的数据类型 1234567//构造函数法var colors = new Array();var colors = new Array(20);// len=20var colors = new Array(\"blue\",\"green\");//字面量法var colors = [];var colors = [\"blue\",\"green\"]; length属性设定length，短了切除，长了用undefined填充。在超远的距离填充（如colors[99] = “xx”，那么2-98都为undefined。套路： 1colors[colors.length] = \"xx\";//在最后一项添加 5.2.1 检测数组instanceof（假定只有一个全局环境）Array.isArray()方法（不管有多少个环境） 5.2.2 转换方法toLocaleString(),toString(),valueOf()调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf()返回的还是数组。 12345678var person = &#123; toLocaleString : function&#123; ... &#125; toStirng : function&#123; ... &#125;&#125;;//这样改变方法 join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串（不传入值或undefined就用逗号）。 5.2.3 栈方法LIFO:push() pop()push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除后一项，减少数组的 length 值，然后返回移除的项。 5.2.4 队列方法FIFO:shift()和push():能够移除数组中的第一个项并返回该项，同时将数组长度减 1unshift():在数组前端添加任意个项并返回新数组的长度。 5.2.5 重排序方法reverse()sort() 方法按升序排列数组项。sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。传入比较function判断排序。如： 12345678910function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;values.sort(compare); 5.2.6 操作方法concat() 方法可以基于当前数组中的所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，后返回新构建的数组。 slice() 能够基于当前数组中的一或多个项创建一个新数组。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。注意，slice()方法不会影响原始数组。（可为负数） splice() 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。 插入：可以向指定位置插入任意数量的项，只需提供 3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 总结：splice(start,length,insert_values…) 5.2.7 位置方法indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。比较使用=== 5.2.8 迭代方法 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。 5.2.9 归并方法reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个终返回的值。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。 5.3 Date类型1var d = new Date();//括号中填入毫秒数 表示自 UTC（Coordinated Universal Time，国际协调时间）1970年 1月 1日午夜（零时）开始经过的毫秒数来保存日期。parse():不固定具体格式，转化为该日期的毫秒数UTC()：按照年、月、日、时、分、秒、毫秒顺序填入。其中月和时从0开始，转化为该日期的毫秒数。toString()/toLocaleString()：转化为日期表示。（目测toLocaleString()会考虑到时区的问题）now()：返回现在时间的毫秒数 如同模仿 Date.parse()一样，Date 构造函数也会模仿 Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。 Date 构造函数接收的参数仍然与 Date.UTC()相同。 valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。格式方法与组件方法见书P101-102 5.4 RegExp类型见另外的文档RegExp 5.5 Function类型函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。 1234567function sum (num1, num2) &#123; return num1 + num2; &#125;var sum = function(sum1, sum2)&#123; return num1 + num2;&#125;;var sum = new Function(\"sum1\",\"sum2\",\"return num1 + num2\")//不推荐 不推荐的那种会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。 5.5.1 没有重载函数名为指针，如果定义了另外一个函数则会指向另外一个函数。 5.5.2 函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 解析器就已经通过一个名为函数声明提升 （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。 5.5.3 作为值的函数因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。函数的return可返回一个函数 5.5.4 函数内部属性arguments和this。arguments的callee属性：该属性是一个指针，指向拥有这个 arguments 对象的函数。如： 123456789function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) //不是factorial，消除了与这个名字的耦合 &#125; &#125; var trueFactorial = factorial; //可正常调用，factorial则不行 this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时， this 对象引用的就是 window） ECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。 ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是 undefined。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。 5.5.5 函数属性和方法每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数 在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。 apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。 它们真正强大的地方是能够扩充函数 赖以运行的作用域。 123456789window.color = \"red\"; var o = &#123; color: \"blue\" &#125;; function sayColor()&#123; alert(this.color); &#125; sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值。 (待续)","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"Regexp相关","slug":"Regexp相关","date":"2020-02-04T16:57:40.000Z","updated":"2020-02-08T14:31:13.495Z","comments":true,"path":"2020/02/05/Regexp相关/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/Regexp%E7%9B%B8%E5%85%B3/","excerpt":"正则表达式的表示方法来自：regexlab 1、直接写内容直接匹配内容 2、转义字符1 字符 含义 \\n \\r 换行符 \\t 制表符 \\\\ \\的字符 \\$ $的字符 \\^ ^的字符 \\. .的字符","text":"正则表达式的表示方法来自：regexlab 1、直接写内容直接匹配内容 2、转义字符1 字符 含义 \\n \\r 换行符 \\t 制表符 \\\\ \\的字符 \\$ $的字符 \\^ ^的字符 \\. .的字符 2 字符 含义 \\d 任意数字 \\w 任意数字、字母及下划线_ \\s 空白或制表符或换页符 . 任意字符（除换行符） 3、方括号使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。如：[abc] (a,b,c中任意一个)、[^ f-k] (不是f-k的任意一个字母)、[A-F0-9] (A-F和0-9中任意一个) 4、数量匹配{n}重复n次{m,n}重复至少m次至多n次{m,}至少重复m次? 相当于 {0,1}+ 相当于 {1,}* 相当于 {0,} 5、位置匹配？^ 与字符串开始的地方匹配，不匹配任何字符（若匹配到的字符不是开始则错误）$ 与字符串结束的地方匹配，不匹配任何字符\\b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符 6、其他| 左右两边表达式之间 “或” 关系，匹配左边或者右边( )(1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 7、高级技巧贪婪与非贪婪默认是贪婪（匹配得越多越好）在数量符号后面加上?（如w+?）则为非贪婪模式，匹配越少越好 引用\\1、\\2等符号获取在( )中匹配的字符 预搜索，不匹配；反向预搜索，不匹配(?=xxxx) 8、其他\\xXX \\uXXXX 表示字符（编码相关？）\\S \\D \\W \\B 代表相反意义（非数字等） 注意事项 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。 需注意贪婪与非贪婪模式 或 “|” 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 “|” 两边的表达式因为交换位置而有所不同。 js里面的正则表达式形式：12var exp = / pattern / flags;//字面量类型var exp2 = new RegExp(\"[bc]at\", \"i\"); //构造函数 模式（pattern）为表达式。flags:g表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。传入构造函数的字符串需双重转义如匹配\\：字符串|字面量|匹配-|-|-\\\\\\\\|\\\\|\\（嗯其实这里打的markdown已经是四重转义了） 实例的属性 global：布尔值，表示是否设置了 g 标志。 ignoreCase：布尔值，表示是否设置了 i 标志。 lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。 multiline：布尔值，表示是否设置了 m 标志。 source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 实例的方法exec()：接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null。 返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。 在数组中，第一项是与整个模式匹配 的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，常与for函数一起使用用于找出所有匹配项。 test():它接受一个字符串参数。在模式与该参数匹配的情况下返回 true；否则，返回 false。 toLocaleString()和toString() 方法都会返回正则表达式的字面量。valueOf()方法返回正则表达式本身。 RegExp构造函数属性原理（NFA）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"JSON相关","slug":"JSON相关","date":"2020-02-04T16:56:57.000Z","updated":"2020-02-11T16:02:52.487Z","comments":true,"path":"2020/02/05/JSON相关/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/JSON%E7%9B%B8%E5%85%B3/","excerpt":"JSON组成简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。","text":"JSON组成简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON不支持 JavaScript中的特殊值 undefined。对象：对象作为一种复杂数据类型，表示的是一组无序的键值对。而每个键值对中的值可以是简单值，也可以是复杂数据类型的值。数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 例子：“Hello world!” 简单值{“name”: “Nicholas”,”age”: 29} 对象[25, “hi”, true] 数组 js中解析与序列化12345var book = &#123; //JSON表达式&#125;var jsontext = JSON.stringify(book);var bookC = JSON.parse(book); JSON 对象的两个方法：stringify()和 parse()将 JSON字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript对象（或数组、值）。 过滤结果123456stringify(book,[year,edition]);JSON.stringify(book, function(key, value)&#123; switch(key)&#123; //判定是哪个属性，不要就返回undifined &#125;&#125; 第三个参数用于控制结果中的缩进和空白符如果是一个数值，则为缩进数如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON字符串中被用作缩进字符 如果某些对象无法使用JSON对象转化，可以自己定义该对象的toJSON()方法 序列化顺序：(1) 如果存在 toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。(3) 对第(2)步返回的每个值进行相应的序列化。(4) 如果提供了第三个参数，执行相应的格式化。 JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。这个函数被称为还原函数（reviver）","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"js高级设计笔记（第四章）","slug":"js高设笔记4","date":"2020-02-04T16:35:24.000Z","updated":"2020-02-08T14:30:51.296Z","comments":true,"path":"2020/02/05/js高设笔记4/","link":"","permalink":"https://mizarzh.github.io/2020/02/05/js%E9%AB%98%E8%AE%BE%E7%AC%94%E8%AE%B04/","excerpt":"第四章4.1 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。引用类型值（Object？） js不允许直接访问内存 4.1.1 属性对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。不能给基本类型值添加属性。","text":"第四章4.1 基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 五种基本数据类型：Undifined,Null,Boolean,Number,String，按值访问。引用类型值（Object？） js不允许直接访问内存 4.1.1 属性对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。不能给基本类型值添加属性。 4.1.2 复制基本类型值”=”将进行值的复制，两个值之间不相关而引用类型值的”=”将指向同一个对象 4.1.3 传递参数 ECMAScript 中所有函数的参数都是按值传递的。把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。可以把 ECMAScript函数的参数想象成局部变量。 my comprehension:不管什么值进入函数都会复制一遍，并在函数内部赋值到一个临时变量上。基本类型值基本没问题，但引用类型值的引用也被复制了，当在内部改变临时变量的属性时，随着引用外部的对象也会随着改变。 4.1.4 检测类型typeof方法和instanceof方法 4.2 执行环境及作用域 执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。全局变量与每个函数的执行环境每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。 4.2.1 延长作用域链try-catch语句的catch块：with语句：不解释 4.2.2 没有块级作用域 变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完add()之后，添加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。 4.3 垃圾收集自动垃圾手机机制 4.3.1 标记清除变量进入环境时，将变量标记为“进入环境”。离开时标记为“离开环境”。 4.3.2 引用清除用得不多。跟踪记录每个值使用的次数。问题：循环引用。需手动切断链接。（设置引用为null） 4.3.3 性能问题注意性能相关问题。 4.3.4 管理内存不需要时手动解除引用。","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mizarzh.github.io/tags/javascript/"}]},{"title":"有用的网址","slug":"有用的网址","date":"2020-01-30T05:20:56.000Z","updated":"2020-02-09T14:06:52.513Z","comments":true,"path":"2020/01/30/有用的网址/","link":"","permalink":"https://mizarzh.github.io/2020/01/30/%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/","excerpt":"NexT文档 https://theme-next.org/docs/http://theme-next.iissnan.com/网上搜索很方便（hexo文档和blog很多） mc相关： 中文论坛 https://www.mcbbs.net/mod https://www.mcmod.cn/class/category/1-1.htmlcusreforge https://curseforge.comHMCL https://hmcl.huangyuhui.netgamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wikigamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki","text":"NexT文档 https://theme-next.org/docs/http://theme-next.iissnan.com/网上搜索很方便（hexo文档和blog很多） mc相关： 中文论坛 https://www.mcbbs.net/mod https://www.mcmod.cn/class/category/1-1.htmlcusreforge https://curseforge.comHMCL https://hmcl.huangyuhui.netgamepedia https://minecraft-zh.gamepedia.com/Minecraft_Wikigamepedia英文版 https://minecraft.gamepedia.com/Minecraft_Wiki","categories":[{"name":"杂物","slug":"杂物","permalink":"https://mizarzh.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[]},{"title":"mc相关配置解释","slug":"mc相关配置解释","date":"2020-01-30T03:50:14.000Z","updated":"2020-02-26T07:05:40.372Z","comments":true,"path":"2020/01/30/mc相关配置解释/","link":"","permalink":"https://mizarzh.github.io/2020/01/30/mc%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/","excerpt":"1.mc版本mc（pc端）分为java版与基岩版（C++编写）java版可自行下载，基岩版必须购买 java版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接） 以下讨论只针对java版","text":"1.mc版本mc（pc端）分为java版与基岩版（C++编写）java版可自行下载，基岩版必须购买 java版购买与自行下载的唯一区别在于购买的游戏可以登录正版的公开服务器，自行下载只能进行离线模式（或者与自建服务器连接） 以下讨论只针对java版 2.配置方法启动游戏需配置三样东西：java环境，游戏本体，启动器 游戏运行于java环境，因此首先需下载JDK（java development kit）并安装 目前许多启动器可以直接下载游戏本体，因此不需要再专门下载游戏本体。游戏本体位于.minecraft文件夹内 启动器用于启动游戏，常见的有HMCL等 3、mod相关安装mod需要下载forge（然鹅官网好像访问很慢）安装后会出现mods文件夹，直接将mod的jar包拖入其中即可 4、自建服务器以ubuntu为例首先需下载server.jarmc_serverubuntu需要使用wget获得服务器再安装jdk： 1sudo apt install openjdk-11-jre-headless 安装完成后再在bash输入： 1sudo java -Xms512m -Xmx1024m -jar /path/to/server.jar nogui 就可生成文件使用文本编辑器在生成的eula.txt文件中修改为true，在server.properties文件中修改online-mode=false制作启动脚本： 123#!/bin/shjava -Xms512m -Xmx1024m -jar /path/to/server.jar nogui;","categories":[{"name":"游戏","slug":"游戏","permalink":"https://mizarzh.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"mc","slug":"mc","permalink":"https://mizarzh.github.io/tags/mc/"}]},{"title":"杂项问题","slug":"small-problem","date":"2020-01-28T03:38:56.000Z","updated":"2020-04-04T15:16:28.238Z","comments":true,"path":"2020/01/28/small-problem/","link":"","permalink":"https://mizarzh.github.io/2020/01/28/small-problem/","excerpt":"hexo相关1. vscode使用markdown相关preview：右上角点击preview即可可装插件Markdown Preview Enhanced使得preview更好看 2、hexo标签问题设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法： 1hexo n page tags #或categories等 然后在source/tags目录中配置index.md","text":"hexo相关1. vscode使用markdown相关preview：右上角点击preview即可可装插件Markdown Preview Enhanced使得preview更好看 2、hexo标签问题设置了hexo的tags或者是categories，一开始是没有对应的页面的。生成页面的做法： 1hexo n page tags #或categories等 然后在source/tags目录中配置index.md 123456---title: 标签date:type: \"tags\" //或者\"categories\"--- 然后hexo g即可 3、hexo目录乱序需要按顺序一级一级使用#如##后应该跟###而不是#### 4、hexo插入图片摸索出来的新方法： 手动在_post文件夹建立与md相同名字的文件夹（不含.md)，往里面放入图片 直接使用![](xxx/文件名) 后面这种网上常见方法在我这里不适用/会出bug例如我使用了之后就会使得地址处多了一个/.io/，无法连接到正确图片上 _config.yml里面的post_asset_folder设为true 安装插件1cnpm install hexo-asset-image --save 安装完成后后hexo n “xxx”就会生成xxx.md的同时生成一个同名文件夹，图片放在里面即可。 调用图片的命令为![](xxx/文件名) 5、hexo启用公式使用kramed渲染 1cnpm install hexo-renderer-kramed --save 在_config.yml中将mathjax enable，并在每篇文章的head中添加mathjax: true有时候遇到pandoc exited with code null的问题，可以直接将pandoc整个卸载： 1npm remove hexo-renderer-pandoc --save git相关1、git速度过慢需设置hosts文件，隔一段时间需重新设置 浏览器配置使用firefox 标签设置about:config收藏栏打开使用新标签browser.tabs.loadBookmarksInTabs设为true新标签在当前标签右侧打开browser.tabs.insertAfterCurrent设为true 拓展安装tabliss：主要看重其中的TODO（懒= =）Simple Tab Groups： Tab Center Redux: 使用的拓展Dark Reader: IDM: uBlock Origin: Video DownloadHelper: To Google Translate: 打开被禁用端口config:aboutnetwork.security.ports.banned.override添加字符串xxxx,xxxx,xxxx格式 ssh传文件本地-&gt;远程 1scp local_file remote_username@remote_ip:remote_folder 远程-&gt;本地 1scp remote_username@remote_ip:remote_folder local_folder ffmpeg叠加图片1./ffmpeg -r 一秒帧数 -start_number 起始数字 -i img_%04d.jpg（4位整数） output.mp4 剪片-ss 00:00:00.000 开始时间-t 00:00:10.000 持续时间-to 00:00:10.000 结束时间 旋转顺时针旋转画面90度ffmpeg -i test.mp4 -vf “transpose=1” out.mp4逆时针旋转画面90度ffmpeg -i test.mp4 -vf “transpose=2” out.mp4顺时针旋转画面90度再水平翻转ffmpeg -i test.mp4 -vf “transpose=3” out.mp4逆时针旋转画面90度水平翻转ffmpeg -i test.mp4 -vf “transpose=0” out.mp4水平翻转视频画面ffmpeg -i test.mp4 -vf hflip out.mp4垂直翻转视频画面ffmpeg -i test.mp4 -vf vflip out.mp4","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"hexo win10配置方法，并使用github作为博客地址","slug":"hexo-blog-in-windows","date":"2020-01-27T14:46:41.000Z","updated":"2020-02-08T14:30:49.829Z","comments":true,"path":"2020/01/27/hexo-blog-in-windows/","link":"","permalink":"https://mizarzh.github.io/2020/01/27/hexo-blog-in-windows/","excerpt":"0、准备： node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： 12git config --global user.name \"Firstname Lastname\"git config --global user.email \"your-email@youremail.com\" github新建repository的地址需命名为your-github-name.github.io 1、使用cnpmnpm命令在国内较慢，需要安装cnpm(淘宝镜像) 1npm install -g cnpm --registry=https://registry.npm.taobao.org","text":"0、准备： node.js官网下载node并安装 安装git for windows，以后将使用git bash作为命令行操4作 配置git账号信息： 12git config --global user.name \"Firstname Lastname\"git config --global user.email \"your-email@youremail.com\" github新建repository的地址需命名为your-github-name.github.io 1、使用cnpmnpm命令在国内较慢，需要安装cnpm(淘宝镜像) 1npm install -g cnpm --registry=https://registry.npm.taobao.org 2、安装hexo1cnpm install -g hexo-cli 3、新建文件夹新建一个文件夹，里面将存储blog所需文件 12mkdir my_blogcd my_blog 4、初始化hexo1hexo init 5、安装hexo部署至github的工具1cnpm install --save hexo-deployer-git （若出现ERROR Deployer not found: git错误，则是这个工具未安装） 6、其他配置其中文件_config.yml是配置文件部署到github上需要配置deploy部分 1type: 'git' 添加两行： 12repo: _path-to-github-blog_branch: master 可在theme中更换主题 本地临时服务器：12hexo s s 代表 start 默认地址为localhost:4000 新建文档：12hexo n \"name\" n 代表 new 文档存放在/source/_post/中 生成文档：12hexo g g 代表 generate 部署文档到github上： 12hexo d d 代表 deploy 第一次配置可能需要输入github的账号密码若是git bash内提示账号相关的错误，返回第零步进行账号的配置","categories":[{"name":"编程","slug":"编程","permalink":"https://mizarzh.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://mizarzh.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T13:59:53.866Z","updated":"2020-01-27T13:59:53.866Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"https://mizarzh.github.io/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}