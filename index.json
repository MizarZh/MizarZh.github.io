[{"categories":["计算机"],"content":"在使用 windows 11 的时候，我发现它总是默认折叠同一程序。我对此很不适应，因为我通常会打开多个 obsidian 和 vscode 的窗口，在它们之间切换十分麻烦。 经过一番摸索，发现 windows 11 有自带的不折叠选项，但是各任务栏的长度竟然是不一样的！ Pasted image 20250309154518.png 这让我十分不爽，想要回到 windows 10 的不折叠选项（保持相同长度）。 Pasted image 20250309154657.png 而我又很喜欢 windows 11 的任务栏风格。所以我开始四处寻找解决方法，最后找到了 Windhawk。 Windhawk 是一个修改 windows 外观的工具。其中的一个插件 Taskbar Labels for Windows 11 - Windhawk 可以设置任务栏不合并 + 相同长度的任务栏标签长度，且保留 windows 11 的风格。至此我十分满意，总算是找到一个可行的方案了。 接下来我又有了一个想法：因为 windows 11 的单个图标风格比显示标签会更加好看，我能否定制某一个程序使用不同的颜色呢？ 既然是自定义样式，我就转向了另一个插件 Windows 11 Taskbar Styler - Windhawk。这个插件主要是用来调整整个任务栏的样式风格的，但是我尝试用它自定义单个程序使用的不同颜色。 自定义guide： ramensoftware/windows-11-taskbar-styling-guide 查看样式代码：UWPSpy - Ramen Software 通过这两个教程，我找到了定制某一个程序背景颜色的方法（半成功）： /* Target */ Taskbar.TaskListButton[AutomationProperties.Name=Anki - 1 个运行窗口] \u003e Taskbar.TaskListLabeledButtonPanel \u003e Border#BackgroundElement /* Styles */ Background=#000000 CornerRadius=5 即：选择窗口名为 Anki - 1 个运行窗口 的程序，找到 background 所对应的元素，设置颜色为 #000000。 这种方法的缺点在于只要程序名字一变就无法进行设置了。Windhawk 也没有提供 css [x~=x] 的 selector，因此只能暂时搁置。 ","date":"2025-03-09","objectID":"/posts/windhawk-%E6%8A%98%E8%85%BE%E5%8D%8A%E5%A4%B1%E8%B4%A5%E6%94%B9%E5%8F%98%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/:0:0","tags":["windows","折腾","windhawk"],"title":"Windhawk 折腾（半失败：改变任务栏的背景颜色）","uri":"/posts/windhawk-%E6%8A%98%E8%85%BE%E5%8D%8A%E5%A4%B1%E8%B4%A5%E6%94%B9%E5%8F%98%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/"},{"categories":["读书"],"content":"\r核心思想高质量成果 = 集中时间 x 集中的强度 集中时间是有限的（每天最多 4 小时），因此为了提高成果的质量只能提升集中的强度。 只有在全身心投入工作的情况下（心流状态）才能产出高质量的成果。而影响集中的原因是其他因素的干扰（特别是网络/社交媒体/邮件）。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r四种类型的深度工作 修道院型：全年只做这一个类型的工作。 双峰型：半年集中学计算机，半年集中学物理。 节奏型：一天中 9:00-13:00 深度工作。本人用的是这种。 记者型：随时随地进入深度工作。不推荐一开始的时候使用 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r策略","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r4DX 集中在最重要的事情上。 根据领先指标采取行动。即以花了多少时间在深度工作上作为指标，而不是做了多少份工作 记录一个分数表。记录一周花了多少时间在深度工作上，从而可以随时调整和鼓励自己 建立问责节奏。在记录的基础上反思什么做对了，什么做错了。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:3:1","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r浅工作以及休息浅工作可以换一些更有意义的事情做。例如：刷视频 -\u003e 看书。 休息很重要，不要在一天中超负荷工作，一天四小时的深度工作即可。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:3:2","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r时间\u0026项目的管理使用时间块去计划一天的时间。同时使用时间压力逼迫自己去做事情。 项目要思考是否值得做，先做优先级最高的项目和任务。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:3:3","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r仪式感在开始和结束深度工作时，可以设定一些动作，快速进度集中模式。这一点和 Atomic Habit 里面的思想有点相似。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:3:4","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r减少干扰因素 断网、黑名单网站或不去访问他们。网络是当代第一干扰因素。 使用大段时间。短时间会导致集中和放松状态的频繁切换。 清理工作环境中的干扰因素。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r其他一些有意思的点 In a post-Enlightenment world we have tasked ourselves to identify what’s meaningful and what’s not, an exercise that can seem arbitrary and induce a creeping nihilism. 在曾经，我们可以有宗教等指导我们的思想，让我们知道朝什么方向做什么事。但是在科学兴起后，人们开始需要自己去选择目标和方向，从而导致虚无主义的出现。 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:5:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r记录2024-12-10 - 2024-12-10 ","date":"2025-01-05","objectID":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/:6:0","tags":null,"title":"Deep work 笔记","uri":"/posts/deep-work-cal-newport-%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r感受\u0026笔记这本书从一个没有什么大事发生的年份（公元1587年，明万历十五年）说起，引出了 6 个人物：皇帝万历，改革者张居正，和稀泥的申时行，儒家模范海瑞，武将戚继光以及离经叛道的李贽。他们都通过自己的方式尝试去改变国家，但是最终都走向了失败。正如整本书的结尾那样说道： 在这个时候（1587年），皇帝的励精图治或者宴安耽乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能在事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败而兼名裂。 作者想要做的就是了解为何明朝无法解决自身的问题。 ","date":"2025-01-05","objectID":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"《万历十五年》读后感想\u0026笔记","uri":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r主要的问题：文官制度一个重要的原因是来自于房间里的大象——文官制度，这个制度在明朝尤为显著。文官的特点（某种程度上是儒家的特点）： 信仰儒家，以至于到了“祖宗之法不可变”的程度。 重农轻商。 重道德而轻法制，也没有对民众权力的尊重。 认为文化与生活水平和国家安全不能相容。 相互抱团，坚如盘石。 这些问题就导致了发展停滞、制度缺乏弹性且市民阶层无法发展。同时文官们会坚决维持自己的地位，不能抛弃儒家，因为一旦抛弃就会威胁到王朝以至于自身的安全。 为什么这些人都失败了： 万历在文官制度下是某种意义上的“吉祥物”，只需要扮演仪式的工具人即可。他本人因为无法对抗文官而选择摆烂。 张居正将文官当作行政工具，殊不知他们已经从曾经的“公仆”变成了权力的源泉，因而在死后遭到了报复。 申时行知道无法对抗文官，因此选择调和皇帝和文官之间的矛盾。但是在立储这个大问题上也无法调和，最后被弹劾。 海瑞试图将上古或本朝刚开时的道德思想应用到现实中，但文官有着双面性格：阳的仁义道德、治国平天下以及阴的利益换取和中饱私囊。当阴被禁止，势必引起文官集团的强势反扑。最后海瑞被罢职。 武将和文官之间的施政原则在根本上是不能相容的。文官的观念是即上自国家，下至个人，不能把力量作为权威。如果一个地区有什么特殊的经济利益，那么就应当加以压抑，而不是提倡。因此文官经常凌驾于武官之上，控制着武官的行为，让他们无法壮大。戚继光的崛起也是因为收到了文官的庇护，但当他真的强大后，就引起了文官们的警觉，最后被弹劾。 李贽提出了反对儒家的思想，但文官需要维持社会的稳定，异端的学说是不允许被扩大的。因此最后被抓入狱，郁郁而终。 所有人都成了文官制度机器下的一个个齿轮，困于制度的牢笼中。想要做成事的必须顺着文官或者达成某种程度的妥协，反对文官的行为和思想都会被消灭。 这是我认为的本书的核心论点：明帝国的衰败来自于文官的腐化，同时文官占据了极大的地位，无法撼动。这就导致社会发展停滞，要想改变或者做点什么都只能顺着文官，否则就会被消灭。 ","date":"2025-01-05","objectID":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/:1:1","tags":null,"title":"《万历十五年》读后感想\u0026笔记","uri":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r其他的一些有意思的点 这一帝国既无崇尚武功的趋向，也没有改造社会、提高生活程度的宏愿，它的宗旨，只是在于使大批人民不为饥荒所窘迫，即在“四书”所谓“黎民不饥不寒”的低标准下以维持长治久安。 封建（这个词不准确，但暂时还没找到更好的词，就暂时这么用吧）帝国的本质 他（海瑞）当然是极端地廉洁，极端地诚实，然而从另外一个角度来看，也可能就是极端地粗线条，极端地喜欢吹毛求疵。 一个农民家庭如果企图生活稳定，并且获得社会声望，惟一的道路是读书做官。然而这条道路漫漫修远，很难只由一个人或一代人的努力就能达到目的。 然而我们这个庞大的帝国，在本质上无非是数不清的农村合并成的一个集合体，礼仪和道德代替了法律，对于违法的行为作掩饰则被认为忠厚识大体。 封建帝国控制力看上去很强，实则很弱 地区间的人口过剩、灾害频仍、农民的流离失所、官吏的苛刻暴虐，都可以迫使暴动随时发生，而以我国幅员之大，这种所谓造反作乱的地点也极难预测，所以这个任务就不是一支高效率的机动部队所得以完成的。在多数情况下，官军会被造反者死死吸住，造反者熟悉当地的地理民风，官军往往会因之陷入被动而使质量的优势无从发挥。因此，数量的多寡就成为决定胜负的因素。 为何官军要数量多 《论语》中这六十六条有关仁的语录，为孔子的学说安排了形而上的根据，成为儒家一元论宇宙观的基础。……这种把具体和抽象混为一谈的方法，是中国思想家的传统习惯，也合于他们一元论的宇宙观，因为他们认为，一个人看到一件事物，这种事物就不是孤立的，不可能与环境隔离。他们着重于事物的功能。一件事物具有特性，就是因为它和其他事物发生了关系。 儒家竟然是一元论，以前我仅仅认为儒家是一种社会制度，其实它也有自己的一套世界观。这么一看有些人称之为“儒教”其实也是有一定道理的 在一种社会形态之中，道德的标准可以历久不变，但把这些标准在生活中付诸实践，则需要与不同的时代、环境相适应而有所通变。……本朝开国二百年，始终以“四书”所确定的道德规范作为法律裁判的根据，而没有使用立法的手段，在伦理道德和日常生活之间建立一个“合法”的缓冲地带。惟有这种缓冲地带，才能为整个社会带来开放的机能，使政府的政治措施得以适合时代的需要，个人独创精神也得以发挥。 ","date":"2025-01-05","objectID":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/:1:2","tags":null,"title":"《万历十五年》读后感想\u0026笔记","uri":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r后记这本书的后记中记录的出版的事也是十分有意思的。由于这本书在引入时刚好是改革开放初期，因此引进前后也有一些争论。 （徐卫东：两声欢呼和一声倒彩）笔者还以为，凡事拿“科学”来贴标签，本身就不科学；把科学当宗教来崇拜，其实质不是出于普遍的无知（如笔者此前认识，见有些人什么名词前面加上“科学”二字，便以为端的是“科学”，即使有疑，也无从辩驳），就是自以为真理在手，压制一切异己意见 ","date":"2025-01-05","objectID":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/:1:3","tags":null,"title":"《万历十五年》读后感想\u0026笔记","uri":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/"},{"categories":["读书"],"content":"\r记录时间：2025-1-1 - 2025-1-4 ","date":"2025-01-05","objectID":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"《万历十五年》读后感想\u0026笔记","uri":"/posts/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E8%AF%BB%E5%90%8E%E6%84%9F%E6%83%B3%E7%AC%94%E8%AE%B0/"},{"categories":["计算机"],"content":"\rVNC 的问题上次用 VNC 的时候还是在上次，回来之后发现 VNC 已经变成收费的模样了。这可不行，要用就必须用免费的 VNC。 ","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:1:0","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\r使用 tightvncTightvnc 是免费且开源的 VNC，在树莓派上安装： sudo apt install tightvncserver 记得关闭原来的 real-vnc： sudo raspi-config # 选择 interface - vnc - 关闭 启动 vncserver： vncserver :1 # vncserver :2 # 启动第二个 默认端口是 5900 + 窗口。例如 vncserver :1 的端口就是 5901。 ","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:2:0","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\r访问Windows: 从 Tightvnc 下载 viewer，然后连接访问即可。 我使用的是 mobaXterm 因此没有什么访问上的问题。 ","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:3:0","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\r一些有用的命令","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:4:0","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\rToo many authentication failures 错误如果出现了 Too many authentication failures 错误，意味着可能有多个 vnc 实例正在运行，我们可以用以下方法解决冲突的问题： $ pgrep vnc 4456 45890 $ kill 4456 $ kill 45890 $ vncserver // your vnc server will start ","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:4:1","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\rReferencehttps://pimylifeup.com/raspberry-pi-vnc-server/ https://askubuntu.com/questions/973055/too-many-authentication-failures-vnc-server https://www.raspberrypi.com/documentation/computers/remote-access.html ","date":"2024-06-29","objectID":"/posts/raspberry-pi-vnc/:5:0","tags":["Raspberry pi","VNC"],"title":"Raspberry pi VNC","uri":"/posts/raspberry-pi-vnc/"},{"categories":["计算机"],"content":"\r介绍oh-my-posh 是一个命令行美化工具。 ","date":"2024-05-29","objectID":"/posts/oh-my-posh-powershell-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:0","tags":["oh-my-posh","powershell"],"title":"oh-my-posh powershell 配置方法","uri":"/posts/oh-my-posh-powershell-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["计算机"],"content":"\r安装和启动 安装脚本。见 https://ohmyposh.dev/docs/installation/windows 安装字体。oh-my-posh 基于 Nerds Font 字体，因此我们需要安装它，否则就会出现奇怪的 ? 字符。安装方法见 https://ohmyposh.dev/docs/installation/fonts 设置启动。启动命令 oh-my-posh init pwsh | Invoke-Expression，如果要打开启动则需要将其写入一个。详情见 https://ohmyposh.dev/docs/installation/prompt 选择一个主题。见 https://ohmyposh.dev/docs/themes 和 https://ohmyposh.dev/docs/installation/customize 。oh-my-posh init pwsh --config 'C:/Users/Posh/jandedobbeleer.omp.json' | Invoke-Expression ","date":"2024-05-29","objectID":"/posts/oh-my-posh-powershell-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:2:0","tags":["oh-my-posh","powershell"],"title":"oh-my-posh powershell 配置方法","uri":"/posts/oh-my-posh-powershell-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["数学"],"content":"\r起因闲来无事，尝试去写一个多摆的模拟程序。为了效率，我尝试去矢量化计算二次导数。但是网上查到的资料只有拉格朗日方程代入坐标后算出的原式，没有矢量形式： $$ \\begin{align} \u0026\\sum_{k=1}^{n}\\left[gl_{j}\\sin(\\theta_{j})m_{k}\\sigma_{jk}+m_{k}l_{j}^2\\ddot{\\theta}{j}\\sigma{jk}\\right.+ \\ \u0026(\\sum_{q\\ge k}^{n}m_{q}\\sigma_{jq})l_{j}l_{k}\\left(\\sin\\left(\\theta_{j}-\\theta_{k}\\right)\\dot{\\theta}{k}^2+\\phi{jk}\\cos\\left(\\theta_{j}-\\theta_{k}\\right)\\ddot{\\theta_k}\\right)\\Big]=0 \\end{align} $$ 其中： $$ \\sigma_{jk}=\\left{\\begin{array}{ll}0\u0026\\quad j\u003ek\\1\u0026\\quad j\\leq k\\end{array}\\right. \\qquad\\phi_{jk}=\\left{\\begin{array}{ll}0\u0026\\quad j=k\\1\u0026\\quad j\\neq k\\end{array}\\right. $$ （出处 https://arxiv.org/pdf/1910.12610 式 38，但不知道为啥原文章没有约掉中间的一大团东西）。 接下来需要将这一大团东西转换成 $Mx=b$ （这里的 $x$ 为 $\\ddot{\\theta}$） 的矢量形式。 ","date":"2024-05-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/:1:0","tags":["线性代数","Python"],"title":"如何将求和矢量化（以多摆的公式为例）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/"},{"categories":["数学"],"content":"\r方法换个思路看求和：求和的对象是一个矩阵（张量），求和是在这个矩阵的某个方向上相加。 Pasted image 20240518161558.png 我们想要将这个矩阵变成 $Mx=b$ 的形式，即将 $x$ 项提取出来： $$ \\begin{pmatrix} \u0026\u0026\u0026\u0026\u0026\u0026 \\ \u0026\u0026\u0026\u0026\u0026\u0026 \\ \u0026\u0026\u0026M_{ij}\u0026\u0026\u0026 \\ \u0026\u0026\u0026\u0026\u0026\u0026 \\ \u0026\u0026\u0026\u0026\u0026\u0026 \\end{pmatrix} \\begin{pmatrix} \\ \\ x_{j} \\ \\ \\ \\end{pmatrix} = \\begin{pmatrix} \\ \\ b_{i} \\ \\ \\ \\end{pmatrix} $$ 依照此想法，我们可以假设求和所求矩阵的表达式为： $$ M_{ij}=A_{ij}+B_{ij}x_{ij}+C_{ij}x_{j} $$ 其中 $x$ 为我们想要的矢量。 两个说明： 因为我们想要分离出 $x$，所以我们才这样分解 为什么没有更高阶项？因为我们想要的是线性方程。如果出现了更高阶项，那么就无法线性化，这种方法就是徒劳的。 回到原想法：在某个轴上相加。假设我们对 $j$ 轴相加并设为 0： $$ \\sum_{j} (A_{ij}+B_{ij}x_{i}+C_{ij}x_{j}) = 0 $$ 显然 $b=-\\sum_{j}A_{ij}$，而 $C_{ij}$ 是 $M$ 的一部分。 $B_{ij}x_{i}$ 这一项显得有些棘手。那么应该如何处理呢？ 我们可以假设 $i$ 只有三行，我们就可以写出加法的形式： $$ \\begin{align} \u0026A_{i1}+B_{i 1}x_{i}+C_{i 1}x_{1}+ \\ \u0026A_{i2}+B_{i 2}x_{i}+C_{i 2}x_{2}+ \\ \u0026A_{i3}+B_{i 3}x_{i}+C_{i 3}x_{3}=0 \\ \u0026\\Rightarrow \\sum_{j} (A + C_{ij} x_{j}) + \\left( \\sum_{j} B_{ij}\\right)x_{i}=0 \\end{align} $$ 我们可以发现，只有到了相应的式子时，$x_{i}$ 才会出现。与这个性质类似的矩阵是单位矩阵。因此我们可以认为这一项在求和后的表现为：$\\left( \\sum_{j} B_{ij} \\right)\\delta_{ij}$。总结： $$ \\begin{align} M \u0026= \\left( \\sum_{j}B_{ij} \\right) \\delta_{ij} + C_{ij} \\ b \u0026= -\\sum_{j}A_{ij} \\end{align} $$ ","date":"2024-05-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/:2:0","tags":["线性代数","Python"],"title":"如何将求和矢量化（以多摆的公式为例）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/"},{"categories":["数学"],"content":"\r多摆的向量表达式因此，多摆的向量化表达式为： $$\\begin{align} \u0026 b=-\\sum_{k=1}^{n}\\left(gl_{j}\\sin(\\theta_{j})m_{k}\\sigma_{jk}+(\\sum_{q\\ge k}^{n}m_{q}\\sigma_{jq})l_{j}l_{k}\\sin\\left(\\theta_{j}-\\theta_{k}\\right)\\dot{\\theta}{k}^2\\right)\\ \u0026 M=(\\sum{k=1}^{n}m_{k}l_{j}^2\\sigma_{jk})\\delta_{jk}+(\\sum_{q\\ge k}^{n}m_{q}\\sigma_{jq})l_{j}l_{k}\\phi_{jk}\\cos\\left(\\theta_{j}-\\theta_{k}\\right)\\end{align}$$ ","date":"2024-05-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/:3:0","tags":["线性代数","Python"],"title":"如何将求和矢量化（以多摆的公式为例）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/"},{"categories":["数学"],"content":"\r如何在 python 中表达为了产生矩阵，我们会重度使用 numpy.ufnc.outer 这个函数。 原则： 搞清楚坐标的顺序。有些符号并不关心坐标在前还是在后（例如加法乘法），但是有些是相关的（例如减法，多摆中的 $\\sigma$ 函数） 表达式中有些看起来像是一维的，但实际上是一个矩阵。（例如 $\\sum_{q\\ge k}^{n}m_{q}\\sigma_{jq}$，看起来很像加法后变成了向量，但实际上由于 $q$ 依赖于 $k$，因此出来的是一个矩阵）。 一些例子： $$ \\cos(\\theta_{j}-\\theta_{k}) $$ # 注意顺序。如果想要表达 theta_k - theta_j 那就必须加上负号 np.cos(np.subtract.outer(theta, theta)) $$ l_{j}\\sin(\\theta_{j})m_{k}\\sigma_{jk} $$ # 将 jk 分别合在一起后再相乘。如果无法分开的就把它当成独立的另一个矩阵再相乘 np.outer(l * np.sin(theta), m) * sigma 详情见项目： https://github.com/MizarZh/n-pendulum ","date":"2024-05-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/:4:0","tags":["线性代数","Python"],"title":"如何将求和矢量化（以多摆的公式为例）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/"},{"categories":["数学"],"content":"\r参考https://travisdoesmath.github.io/pendulum-explainer/ https://arxiv.org/pdf/1910.12610 https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods ","date":"2024-05-18","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/:5:0","tags":["线性代数","Python"],"title":"如何将求和矢量化（以多摆的公式为例）","uri":"/posts/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B1%82%E5%92%8C%E7%9F%A2%E9%87%8F%E5%8C%96%E4%BB%A5%E5%A4%9A%E6%91%86%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B8%BA%E4%BE%8B/"},{"categories":["计算机"],"content":"\rPython 性能分析最简单的方法：datetime import datetime start = datetime.datetime.now() # do something end = datetime.datetime.now() print(start - end) 但是每个地方都要自己加确实有点麻烦。于是选择自动定位并测试函数的工具 cProfile import cProfile cProfile.run('xxx') 然后你就会得到一个表格，其中记录了哪个部分用时多少。 但是这个包输出的表格不太好读，因此我们再转向另一个包：pyinstrument： from pyinstrument import Profiler profiler = Profiler() profiler.start() HTML(ani.to_html5_video()) profiler.stop() # profiler.output_text() # 输出 文本 # profiler.output_html() # 输出 html profiler.open_in_browser() # 在浏览器中打开 html 这个包可以更加详细的分析各个部分的占比。 ","date":"2024-05-16","objectID":"/posts/python-profiling/:1:0","tags":["Python","Profiling"],"title":"Python profiling","uri":"/posts/python-profiling/"},{"categories":["计算机"],"content":"\r错误一大团 lib 的错误，然后说 LNK1181 错误 有可能是 msvc 安装上的问题。不过大部分应该都是正常的 是否编译了 sqlite3.lib 文件。 ","date":"2024-05-15","objectID":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/:1:0","tags":["rust","diesel","sqlite3"],"title":"rust diesel sqlite3 错误","uri":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/"},{"categories":["计算机"],"content":"\r解决方法 从 https://www.sqlite.org/download.html 下载 dll 包（内含 dll 文件和 exp 文件）和 tools 包（加入 PATH）。 cd 至 dll 包的文件夹。 64位操作系统输入： lib /DEF:sqlite3.def /OUT:sqlite3.lib /MACHINE:x64；32位操作系统输入：lib /DEF:sqlite3.def /OUT:sqlite3.lib /MACHINE:x86，完成编译。 找到输出的 sqlite3 文件， 放到 rust 使用的 msvc lib 的位置。 或者放到要使用这个文件的 cargo 中。 或者加入 PATH 变量。 ","date":"2024-05-15","objectID":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/:2:0","tags":["rust","diesel","sqlite3"],"title":"rust diesel sqlite3 错误","uri":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/"},{"categories":["计算机"],"content":"\r参考资料https://blog.itdevwu.com/post/915/ ","date":"2024-05-15","objectID":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/:3:0","tags":["rust","diesel","sqlite3"],"title":"rust diesel sqlite3 错误","uri":"/posts/rust-diesel-sqlite3-lnk1181-%E9%94%99%E8%AF%AF/"},{"categories":["计算机"],"content":"\rResizeObserver监测元素的 resize 需要使用 ResizeObserver 类： new ResizeObserver((entries) =\u003e { for (const x of iframe) { x.resize() } for(const entry of entries) { abc.size = entry.borderBoxSize } }).observe(root) 其中 ResizeObserver callback 中的参数 entries 指的是这个 observer 正在观察元素的数组。 ","date":"2024-04-16","objectID":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/:1:0","tags":["resize","js","Snippit","How-to","front-end"],"title":"监测一个元素是否 resize （ResizeObserver） 以及与 resize 事件的比较","uri":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"},{"categories":["计算机"],"content":"\r与 resize 事件的比较resize event 文档视图（窗口）调整大小时会触发 resize 事件。现在 resize 事件只针对窗口（window）触发。 window.onresize = (xxx) =\u003e {xxx} 即 resize 事件仅作用在窗口上，观测的是窗口大小的改变。而 ResizeObserver 作用在元素上，观测的是元素大小的改变。 ","date":"2024-04-16","objectID":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/:2:0","tags":["resize","js","Snippit","How-to","front-end"],"title":"监测一个元素是否 resize （ResizeObserver） 以及与 resize 事件的比较","uri":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"},{"categories":["计算机"],"content":"\r解析 DOM 文本使用 DOMParser： const parser = new DOMParser(); const xmlString = \"\u003cwarning\u003eBeware of the tiger\u003c/warning\u003e\"; const doc1 = parser.parseFromString(xmlString, \"application/xml\"); const htmlString = \"\u003cstrong\u003eBeware of the leopard\u003c/strong\u003e\"; const doc2 = parser.parseFromString(htmlString, \"text/html\"); parser.parseFromString 返回类型为 Document，这种格式含有完整的 \u003chead\u003e\u003cbody\u003e 元素，也无法直接打印，也没有 toString 方法，总之就是无法直接转换成文本。 ","date":"2024-04-16","objectID":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/:1:0","tags":["DOM","js","Snippit","How-to","front-end"],"title":"js 解析以及文本化 DOM 元素的做法","uri":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/"},{"categories":["计算机"],"content":"\r文本化 DOM 元素我翻了半天都没找到将 DOM 元素变成文本的函数。最后问了 chatgpt 才知道原来精髓就在类型本身： doc.documentElement.innerHTML // DOM 文本 ","date":"2024-04-16","objectID":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/:2:0","tags":["DOM","js","Snippit","How-to","front-end"],"title":"js 解析以及文本化 DOM 元素的做法","uri":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/"},{"categories":["计算机"],"content":"\r起因在写 obsidian-mdx-dictoinary 插件时，我在其中加入了一个 express 后端，结果旧遇到了问题： require_streams(...) is not a function 查了很久，最后问题终结在这个 issue 上：Not working with Karma and Webpack 4。 问题出在一个叫做 iconv-lite 的包上。出问题的语句： require(\"./streams\")(iconv);。由于这个语句使用了两个连续的函数调用，打包库对这种写法不太高兴，这就是为什么 issue 中的 webpack 和 obsidian 插件使用的 esbuild 都报错了。 iconv-lite 作者已对此进行了更新，但是某一些包仍然使用了旧版的 iconv-lite。由于 npm 依赖十分复杂，我尝试了很多方法去解决这个问题。在经历了无数次试错之后，我发现只需要很简单的一个做法就可以解决这个问题：强制所有包使用 iconv-lite 的某个版本。 ","date":"2024-04-16","objectID":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/:1:0","tags":["npm","yarn","pnpm","Snippit","How-to","front-end"],"title":"npm package 强制使用特定版本","uri":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/"},{"categories":["计算机"],"content":"\r做法对于低版本的 npm，我们可以使用 npm-force-resolutions。yarn 也支持类似的写法： // package.json { ... \"resolutions\": { \"foo\": \"1.0.0\", // foo 版本强制为 1.0.0 \"pac-a/pac-b\": \"3.3.2\" // pac-a 下的 pac-b 应该使用 3.3.2 版本 } } 高版本的 npm 以及 pnpm 都支持 override 的写法： // package.json { ... \"overrides\": { \"foo\": \"1.0.0\", // foo 版本强制为 1.0.0 \"bar@2.0.0\": { \"baz\": 1.0.0 // 只有当 bar 为版本 2.0.0 时，才强制 baz 使用 1.0.0 版本 } } } ","date":"2024-04-16","objectID":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/:2:0","tags":["npm","yarn","pnpm","Snippit","How-to","front-end"],"title":"npm package 强制使用特定版本","uri":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/"},{"categories":["计算机"],"content":"来源 obsidian-tracker ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:0:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r代码 name: Release # action 的名字 on: push: tags: - \"*\" # 在 push tags 后触发 action jobs: build: permissions: contents: write # 给 action 写的权限 runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Use Node.js uses: actions/setup-node@v4 with: node-version: '20.x' - name: Build run: | # 这两句是核心，安装包\u0026构建程序 yarn yarn run build - name: Release with Notes uses: softprops/action-gh-release@v1 # 使用了 gh-release 的包，快速生成文件 with: files: | main.js manifest.json styles.css env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} gh-relsease ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:1:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r如何发布 git push 到 remote，注意 package.json 和 manifest.json 中的版本。 使用命令 git tag x.x.x 来标记 tag git push origin x.x.x （仅 push 一个版本） 或 git push --tags （push 所有版本） ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:2:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r注意事项如果出现 403 错误，可能是没有给 workflow 写入的权限。可以在 settings - Actions - General - workflow permissions 中进行修改，修改为 Read and write permissions。 构建的过程是这样的（以推送 0.0.1 版本为例）： 推送到云端后，生成了一个 0.0.1 的分支。 接下来 actions 会根据这个 0.0.1 的分支构建。 如果说你更改了 main 的 workflow，这个 0.0.1 的分支仍然会按照之前的方式进行构建。 因此如果修改了 workflow，记得删除相应的分支再重新 push tags（20多次 commit 修改 release.yml 的痛）。 删除分支的方式：git tag -d x.x.x。 ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:3:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["其他"],"content":"很久没有写博客了。恰逢迷茫之时，且之前一股脑将所有东西都扔到博客上面导致难以管理，决定重开博客，记录一下接下来时间遇到的问题和各种事情。 ","date":"2024-01-06","objectID":"/posts/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/:0:0","tags":[],"title":"新博客的第一篇博客","uri":"/posts/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"}]