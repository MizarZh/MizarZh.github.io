[{"categories":["计算机"],"content":"\rResizeObserver监测元素的 resize 需要使用 ResizeObserver 类： new ResizeObserver((entries) =\u003e { for (const x of iframe) { x.resize() } for(const entry of entries) { abc.size = entry.borderBoxSize } }).observe(root) 其中 ResizeObserver callback 中的参数 entries 指的是这个 observer 正在观察元素的数组。 ","date":"2024-04-16","objectID":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/:1:0","tags":["resize","js","Snippit","How-to","front-end"],"title":"监测一个元素是否 resize （ResizeObserver） 以及与 resize 事件的比较","uri":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"},{"categories":["计算机"],"content":"\r与 resize 事件的比较resize event 文档视图（窗口）调整大小时会触发 resize 事件。现在 resize 事件只针对窗口（window）触发。 window.onresize = (xxx) =\u003e {xxx} 即 resize 事件仅作用在窗口上，观测的是窗口大小的改变。而 ResizeObserver 作用在元素上，观测的是元素大小的改变。 ","date":"2024-04-16","objectID":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/:2:0","tags":["resize","js","Snippit","How-to","front-end"],"title":"监测一个元素是否 resize （ResizeObserver） 以及与 resize 事件的比较","uri":"/posts/%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6-resize-resizeobserver-%E4%BB%A5%E5%8F%8A%E4%B8%8E-resize-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"},{"categories":["计算机"],"content":"\r解析 DOM 文本使用 DOMParser： const parser = new DOMParser(); const xmlString = \"\u003cwarning\u003eBeware of the tiger\u003c/warning\u003e\"; const doc1 = parser.parseFromString(xmlString, \"application/xml\"); const htmlString = \"\u003cstrong\u003eBeware of the leopard\u003c/strong\u003e\"; const doc2 = parser.parseFromString(htmlString, \"text/html\"); parser.parseFromString 返回类型为 Document，这种格式含有完整的 \u003chead\u003e\u003cbody\u003e 元素，也无法直接打印，也没有 toString 方法，总之就是无法直接转换成文本。 ","date":"2024-04-16","objectID":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/:1:0","tags":["DOM","js","Snippit","How-to","front-end"],"title":"js 解析以及文本化 DOM 元素的做法","uri":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/"},{"categories":["计算机"],"content":"\r文本化 DOM 元素我翻了半天都没找到将 DOM 元素变成文本的函数。最后问了 chatgpt 才知道原来精髓就在类型本身： doc.documentElement.innerHTML // DOM 文本 ","date":"2024-04-16","objectID":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/:2:0","tags":["DOM","js","Snippit","How-to","front-end"],"title":"js 解析以及文本化 DOM 元素的做法","uri":"/posts/js-%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%96%87%E6%9C%AC%E5%8C%96-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E5%81%9A%E6%B3%95/"},{"categories":["计算机"],"content":"\r起因在写 obsidian-mdx-dictoinary 插件时，我在其中加入了一个 express 后端，结果旧遇到了问题： require_streams(...) is not a function 查了很久，最后问题终结在这个 issue 上：Not working with Karma and Webpack 4。 问题出在一个叫做 iconv-lite 的包上。出问题的语句： require(\"./streams\")(iconv);。由于这个语句使用了两个连续的函数调用，打包库对这种写法不太高兴，这就是为什么 issue 中的 webpack 和 obsidian 插件使用的 esbuild 都报错了。 iconv-lite 作者已对此进行了更新，但是某一些包仍然使用了旧版的 iconv-lite。由于 npm 依赖十分复杂，我尝试了很多方法去解决这个问题。在经历了无数次试错之后，我发现只需要很简单的一个做法就可以解决这个问题：强制所有包使用 iconv-lite 的某个版本。 ","date":"2024-04-16","objectID":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/:1:0","tags":["npm","yarn","pnpm","Snippit","How-to","front-end"],"title":"npm package 强制使用特定版本","uri":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/"},{"categories":["计算机"],"content":"\r做法对于低版本的 npm，我们可以使用 npm-force-resolutions。yarn 也支持类似的写法： // package.json { ... \"resolutions\": { \"foo\": \"1.0.0\", // foo 版本强制为 1.0.0 \"pac-a/pac-b\": \"3.3.2\" // pac-a 下的 pac-b 应该使用 3.3.2 版本 } } 高版本的 npm 以及 pnpm 都支持 override 的写法： // package.json { ... \"overrides\": { \"foo\": \"1.0.0\", // foo 版本强制为 1.0.0 \"bar@2.0.0\": { \"baz\": 1.0.0 // 只有当 bar 为版本 2.0.0 时，才强制 baz 使用 1.0.0 版本 } } } ","date":"2024-04-16","objectID":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/:2:0","tags":["npm","yarn","pnpm","Snippit","How-to","front-end"],"title":"npm package 强制使用特定版本","uri":"/posts/npm-package-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC/"},{"categories":["计算机"],"content":"来源 obsidian-tracker ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:0:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r代码 name: Release # action 的名字 on: push: tags: - \"*\" # 在 push tags 后触发 action jobs: build: permissions: contents: write # 给 action 写的权限 runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Use Node.js uses: actions/setup-node@v4 with: node-version: '20.x' - name: Build run: | # 这两句是核心，安装包\u0026构建程序 yarn yarn run build - name: Release with Notes uses: softprops/action-gh-release@v1 # 使用了 gh-release 的包，快速生成文件 with: files: | main.js manifest.json styles.css env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} gh-relsease ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:1:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r如何发布 git push 到 remote，注意 package.json 和 manifest.json 中的版本。 使用命令 git tag x.x.x 来标记 tag git push origin x.x.x （仅 push 一个版本） 或 git push --tags （push 所有版本） ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:2:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["计算机"],"content":"\r注意事项如果出现 403 错误，可能是没有给 workflow 写入的权限。可以在 settings - Actions - General - workflow permissions 中进行修改，修改为 Read and write permissions。 构建的过程是这样的（以推送 0.0.1 版本为例）： 推送到云端后，生成了一个 0.0.1 的分支。 接下来 actions 会根据这个 0.0.1 的分支构建。 如果说你更改了 main 的 workflow，这个 0.0.1 的分支仍然会按照之前的方式进行构建。 因此如果修改了 workflow，记得删除相应的分支再重新 push tags（20多次 commit 修改 release.yml 的痛）。 删除分支的方式：git tag -d x.x.x。 ","date":"2024-02-17","objectID":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/:3:0","tags":["Obsidian","Github action","Snippit","How-to"],"title":"Obsidian 插件的 github action 设置","uri":"/posts/obsidian-%E6%8F%92%E4%BB%B6%E7%9A%84-github-action-%E8%AE%BE%E7%BD%AE/"},{"categories":["其他"],"content":"很久没有写博客了。恰逢迷茫之时，且之前一股脑将所有东西都扔到博客上面导致难以管理，决定重开博客，记录一下接下来时间遇到的问题和各种事情。 ","date":"2024-01-06","objectID":"/posts/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/:0:0","tags":[],"title":"新博客的第一篇博客","uri":"/posts/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"}]